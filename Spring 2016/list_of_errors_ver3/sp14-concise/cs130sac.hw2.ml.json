{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Printf.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Printf.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Printf.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then return h else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if h = k then return h else assoc (d, k, t);;\n", "out": "Characters 72-78:\n  | h::t -> if h = k then return h else assoc(d,k,t);;\n                          ^^^^^^\nError: Unbound value return\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if h = k then h else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if h = k then h else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" *) \nif List.mem h seen then seen else h::seen in\nlet rest' = (*failwith \"to be written\"*) \nt in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nmatch (f, b) with\n(x, trueOrFalse) -> if trueOrFalse then wwhile(f, x) else x", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"}, {"type": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nmatch f b with\n(x, trueOrFalse) -> if trueOrFalse then wwhile(f, x) else x", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =  (*failwith \"to be written\" *)\n\nmatch e with\n| VarX                    -> \"x\"\n| VarY                    -> \"y\"\n| Sine e                  -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e                -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 40-42:\n  assert (-1.0 <= rv && rv <= 1.0);\n                  ^^\nError: Unbound value rv\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 40-42:\n  assert (-1.0 <= rv && rv <= 1.0);\n                  ^^\nError: Unbound value rv\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 40-42:\n  assert (-1.0 <= rv && rv <= 1.0);\n                  ^^\nError: Unbound value rv\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 40-42:\n  assert (-1.0 <= rv && rv <= 1.0);\n                  ^^\nError: Unbound value rv\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 40-42:\n  assert (-1.0 <= rv && rv <= 1.0);\n                  ^^\nError: Unbound value rv\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nassert (-1.0 <= eval && eval <= 1.0);\neval", "min": "\nlet rec eval (e,x,y) = assert (((-1.0) <= eval) && (eval <= 1.0)); eval;;\n", "out": "Characters 40-44:\n  assert (-1.0 <= eval && eval <= 1.0);\n                  ^^^^\nError: This expression has type 'a * 'b * 'c -> 'd\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =  (*failwith \"to be written\" *)\nmatch e with\n| VarX                    -> \"x\"\n| VarY                    -> \"y\"\n| Sine e                  -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e                -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nfloat_of_string(exprToString eval)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString eval);;\n", "out": "Characters 53-57:\n  float_of_string(exprToString eval);;\n                               ^^^^\nError: This expression has type 'a * 'b * 'c -> 'd\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nfloat_of_string(exprToString e * x * y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (((exprToString e) * x) * y);;\n", "out": "Characters 40-54:\n  float_of_string(exprToString e * x * y);;\n                  ^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nfloat_of_string(exprToString e)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *)\nlet randNum = rand(1,2) in\nif randNum = 1 then buildSine(buildY()) else buildCosine(buildY)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildY ()) else buildCosine buildY;;\n", "out": "Characters 114-122:\n  if randNum = 1 then buildSine(buildY()) else buildCosine(buildY);;\n                                                          ^^^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}, {"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *)\nlet randNum = rand(1,2) in\nif randNum = 1 then buildSine(buildX()) else buildCosine(buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let xi = f(x) in (xi, f(xi) != xi || f(f(xi)))), b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun x  -> let xi = f x in (xi, (((f xi) != xi) || (f (f xi))))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun x  -> let xi = f x in (xi, (((f xi) != xi) || (f (f xi))))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( f(b)\nb)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile (f b b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let xi = f(x) in (xi, f(xi) != xi || f(f(xi)))), b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun x  -> let xi = f x in (xi, (((f xi) != xi) || (f (f xi))))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( failwith \"to be written\" , b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Op1      of expr\n| Op2      of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (( fun x -> ((f x), (not (x = (f x))))) , b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (not (x = (f x))))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =  (*failwith \"to be written\" *)\nmatch e with\n| VarX                    -> \"x\"\n| VarY                    -> \"y\"\n| Sine e                  -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e                -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Op1 e                   -> \"((tan(pi*\" ^ exprToString e ^ \"))-(tan(pi*\" ^ exprToString e ^ \"))/2)\"\n| Op2 (e1, e2, e3)    -> \"(\" ^ exprToString e1 ^ \">\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^ \":(\" ^ exprToString e1 ^ \"-\" ^ exprToString e2 ^ \"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let buildOp2()                     = Op2(e1,e2,e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 () = Op2 (e1, e2, e3);;\n", "out": "Characters 41-43:\n  let buildOp2()                     = Op2(e1,e2,e3);;\n                                           ^^\nError: Unbound value e1\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less,b_less)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less, b_less);;\n", "out": "Characters 37-59:\n  let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less,b_less);;\n                                       ^^^^^^^^^^^^^^^^^^^^^^\nError: The constructor Op2 expects 3 argument(s),\n       but is applied here to 4 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)\n| Op1 e                   -> (tan(pi *. eval(e,x,y))) -. ((tan(pi *.eval(e,x,y)))/2.0)\n| Op2 (e1, e2, e3)    -> if eval(e1,x,y) > eval(e2,x,y) \nthen eval(e3,x,y) else eval(e1,x,y) -. eval(e2,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "out": "Characters 483-506:\n  | Op1 e                   -> (tan(pi *. eval(e,x,y))) -. ((tan(pi *.eval(e,x,y)))/2.0)\n                                                            ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)\n| Op1 e                   -> (tan(pi *. eval(e,x,y))) -. ((tan(pi *. eval(e,x,y)))/2.0)\n| Op2 (e1, e2, e3)    -> if eval(e1,x,y) > eval(e2,x,y) \nthen eval(e3,x,y) else eval(e1,x,y) -. eval(e2,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "out": "Characters 483-507:\n  | Op1 e                   -> (tan(pi *. eval(e,x,y))) -. ((tan(pi *. eval(e,x,y)))/2.0)\n                                                            ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)\n| Op1 e                   -> ((tan(pi *. eval(e,x,y))) -. ((tan(pi *. eval(e,x,y)))/2.0))\n| Op2 (e1, e2, e3)    -> if eval(e1,x,y) > eval(e2,x,y) \nthen eval(e3,x,y) else eval(e1,x,y) -. eval(e2,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "out": "Characters 484-508:\n  | Op1 e                   -> ((tan(pi *. eval(e,x,y))) -. ((tan(pi *. eval(e,x,y)))/2.0))\n                                                             ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)\n| Op1 e                   -> ((tan(pi *. eval(e,x,y))) -. ((tan(pi *. eval(e,x,y)))/.2.0))\n| Op2 (e1, e2, e3)    -> if eval(e1,x,y) > eval(e2,x,y) \nthen eval(e3,x,y) else eval(e1,x,y) -. eval(e2,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)\n| Op1 e                   -> ((tan(pi *. eval(e,x,y))) -. ((tan(pi *. eval(e,x,y)))/.2.0))\n| Op2 (e1, e2, e3)    -> if eval(e1,x,y) > eval(e2,x,y) \nthen eval(e3,x,y) else eval(e1,x,y) -. eval(e2,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *)\nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX())) else\nif (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\nbuildCosine(buildOp2(buildX()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  let randNum2 = rand (3, 4) in\n  if (randNum = 1) && (randNum2 = 3)\n  then buildSine (buildOp1 (buildX ()))\n  else\n    if (randNum = 1) && (randNum2 = 4)\n    then buildSine (buildOp2 (buildX ()))\n    else\n      if (randNum = 2) && (randNum2 = 3)\n      then buildCosine (buildOp1 (buildX ()))\n      else buildCosine (buildOp2 (buildX ()));;\n", "out": "Characters 215-225:\n  if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX())) else\n                                                          ^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr * expr * 'a\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *)\nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX(),buildY(),buildX())) else\nif (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\nbuildCosine(buildOp2(buildY(),buildX(),buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  let randNum2 = rand (3, 4) in\n  if (randNum = 1) && (randNum2 = 3)\n  then buildSine (buildOp1 (buildX ()))\n  else\n    if (randNum = 1) && (randNum2 = 4)\n    then buildSine (buildOp2 ((buildX ()), (buildY ()), (buildX ())))\n    else\n      if (randNum = 2) && (randNum2 = 3)\n      then buildCosine (buildOp1 (buildX ()))\n      else buildCosine (buildOp2 ((buildY ()), (buildX ()), (buildY ())));;\n", "out": "Characters 215-243:\n  if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX(),buildY(),buildX())) else\n                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth = -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (buildOp1 (buildX ()))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 144-173:\n  if (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth = -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(build(rand, depth - 1))) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (buildOp1 (build (rand, (depth - 1))))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 144-187:\n  if (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(build(rand, depth - 1))) else\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth = -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine (build(rand, depth-1)) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 144-176:\n  if (randNum = 1 && randNum2 = 3) then buildSine (build(rand, depth-1)) else\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth = -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 144-152:\n  if (randNum = 1 && randNum2 = 3) then buildX() else\n                                        ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 144-152:\n  if (randNum = 1 && randNum2 = 3) then buildX() else\n                                        ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX(rand) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX rand\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 150-156:\n  if (randNum = 1 && randNum2 = 3) then buildX(rand) else\n                                              ^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 144-152:\n  if (randNum = 1 && randNum2 = 3) then buildX() else\n                                        ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then return() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then return ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 146-152:\n  if (randNum = 1 && randNum2 = 3) then return() else\n                                        ^^^^^^\nError: Unbound value return\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 146-154:\n  if (randNum = 1 && randNum2 = 3) then buildX() else\n                                        ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildCosine (buildOp1 (buildX ()))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "out": "Characters 146-177:\n  if (randNum = 1 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nmatch (randNum, randNum2) with\n| (1,3) -> buildCosine(buildOp1(buildX()))\n| (1,4) -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (2,3) -> buildCosine(buildOp1(buildX()))\n| (2,4) -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (x,y) -> failwith \"didnt work\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> buildCosine (buildOp1 (buildX ()))\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "out": "Characters 150-181:\n  | (1,3) -> buildCosine(buildOp1(buildX()))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nmatch (randNum, randNum2) with\n| (1,3) -> buildCosine(buildOp1(buildX(rand)))\n| (1,4) -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (2,3) -> buildCosine(buildOp1(buildX()))\n| (2,4) -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (x,y) -> failwith \"didnt work\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> buildCosine (buildOp1 (buildX rand))\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "out": "Characters 177-183:\n  | (1,3) -> buildCosine(buildOp1(buildX(rand)))\n                                        ^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type unit\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nmatch (randNum, randNum2) with\n| (1,3) -> failwith \"bahh\"\n| (1,4) -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (2,3) -> buildCosine(buildOp1(buildX()))\n| (2,4) -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (x,y) -> failwith \"didnt work\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> failwith \"bahh\"\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "out": "Characters 195-270:\n  .............................(  build(rand, depth - 1), \n  build(rand, depth - 1),\n  build(rand, depth - 1))...\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand,depth) = if depth = 0\nthen\nif rand(1,2) = 1 then buildX() else buildY()\nelse\nlet r = rand(1, 100000) in\nmatch r mod 39 with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> match r mod 9 with\n| 0 -> buildSine    (build(rand, depth - 1))\n| 1 -> buildCosine  (build(rand, depth - 1))\n| _ -> match r mod 13 with\n| 0 -> buildTan (build(rand, depth - 1))\n| _ -> match r mod 19 with\n| 0 -> buildAverage (build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 29 with\n| 0 -> buildTimes (build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 39 with\n| 0 -> buildThresh (build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 41 with\n| 0 -> buildDiff (build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> build (rand, depth)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildTan (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 ->\n                                       buildDiff\n                                         ((build (rand, (depth - 1))),\n                                           (build (rand, (depth - 1))),\n                                           (build (rand, (depth - 1))))\n                                   | _ -> build (rand, depth))))))));;\n", "out": "Error: Unbound value buildTan\nHint: Did you mean build, buildOp1, buildSine, buildOp2, buildY or buildX?\nError: Unbound value buildTan\nHint: Did you mean build, buildX, buildY or buildSine?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 326-334:\n  | 0 -> buildTan (build(rand, depth - 1))\n         ^^^^^^^^\nError: Unbound value buildTan\nHint: Did you mean build, buildOp1, buildSine, buildOp2, buildY or buildX?\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand,depth) = if depth = 0\nthen\nif rand(1,2) = 1 then buildX() else buildY()\nelse\nlet r = rand(1, 100000) in\nmatch r mod 39 with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> match r mod 9 with\n| 0 -> buildSine    (build(rand, depth - 1))\n| 1 -> buildCosine  (build(rand, depth - 1))\n| _ -> match r mod 13 with\n| 0 -> buildOp1 (build(rand, depth - 1))\n| _ -> match r mod 19 with\n| 0 -> buildAverage (build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 29 with\n| 0 -> buildTimes (build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 39 with\n| 0 -> buildThresh (build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 41 with\n| 0 -> buildDiff (build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> build (rand, depth)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 ->\n                                       buildDiff\n                                         ((build (rand, (depth - 1))),\n                                           (build (rand, (depth - 1))),\n                                           (build (rand, (depth - 1))))\n                                   | _ -> build (rand, depth))))))));;\n", "out": "Characters 727-736:\n  | 0 -> buildDiff (build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n         ^^^^^^^^^\nError: Unbound value buildDiff\nHint: Did you mean buildSine?\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type expr/8634\n       but an expression was expected of type expr/10486\nError: This variant pattern is expected to have type expr\n       The constructor Op1 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/8634\n       but an expression was expected of type expr/10486\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = if depth = 0\nthen\nif rand(1,2) = 1 then buildX() else buildY()\nelse\nlet r = rand(1, 100000) in\nmatch r mod 39 with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> match r mod 9 with\n| 0 -> buildSine    (build(rand, depth - 1))\n| 1 -> buildCosine  (build(rand, depth - 1))\n| _ -> match r mod 13 with\n| 0 -> buildOp1 (build(rand, depth - 1))\n| _ -> match r mod 19 with\n| 0 -> buildAverage (build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 29 with\n| 0 -> buildTimes (build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 39 with\n| 0 -> buildThresh (build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 41 with\n| 0 -> buildX()\n| _ -> build (rand, depth)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 -> buildX ()\n                                   | _ -> build (rand, depth))))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nmatch (randNum, randNum2) with\n| (1,3) -> failwith \"bahh\"\n| (1,4) -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (2,3) -> buildCosine(buildOp1(buildX()))\n| (2,4) -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| _ -> failwith \"didnt work\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> failwith \"bahh\"\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | _ -> failwith \"didnt work\";;\n", "out": "Characters 195-270:\n  .............................(  build(rand, depth - 1), \n  build(rand, depth - 1),\n  build(rand, depth - 1))...\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n"}, {"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 -> buildX ()\n                                   | _ -> build (rand, depth))))))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nbuildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nmatch randNum with\n| 1 -> buildSine(buildX())\n| _ -> buildCose(buildX())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     match randNum with\n     | 1 -> buildSine (buildX ())\n     | _ -> buildCose (buildX ()));;\n", "out": "Error: Unbound value buildCose\nHint: Did you mean buildCosine?\nError: Unbound value buildCose\nHint: Did you mean buildSine?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 155-164:\n  | _ -> buildCose(buildX());;\n         ^^^^^^^^^\nError: Unbound value buildCose\nHint: Did you mean buildCosine?\n"}, {"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nmatch randNum with\n| 1 -> buildSine(buildX())\n| _ -> buildCosine(buildX())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     match randNum with\n     | 1 -> buildSine (buildX ())\n     | _ -> buildCosine (buildX ()));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nmatch (randNum, randNum2) with\n| (1,3) -> buildSine(buildX())\n| _ -> buildCosine(buildX())", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (3, 4) in\n     match (randNum, randNum2) with\n     | (1,3) -> buildSine (buildX ())\n     | _ -> buildCosine (buildX ()));;\n", "out": "Characters 50-59:\n  buildSine(buildX())\n  ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(buildX())\n| (2,2) -> buildCosine(buildX())\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| 2 -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (buildX ())\n     | (2,2) -> buildCosine (buildX ())\n     | _ ->\n         (match randNum3 with\n          | 1 ->\n              buildSine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n          | 2 ->\n              buildCosine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))));;\n", "out": "Characters 50-59:\n  buildSine(buildX())\n  ^^^^^^^^^\nError: Unbound value buildSine\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| 2 -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 ->\n              buildSine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n          | 2 ->\n              buildCosine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))));;\n", "out": "Characters 50-59:\n  buildSine(buildX())\n  ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp1(build(rand, depth - 1)  ))\n| 2 -> buildCosine(buildOp1(build(rand, depth - 1) ))", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))));;\n", "out": "Characters 50-59:\n  buildSine(buildX())\n  ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,4) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp1(build(rand, depth - 1)  ))\n| 2 -> buildCosine(buildOp1(build(rand, depth - 1) ))\n| _ -> buildSine(buildCosine(build(rand, deth - 1)))", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (deth - 1))))));;\n", "out": "Characters 50-59:\n  buildSine(buildX())\n  ^^^^^^^^^\nError: Unbound value buildSine\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,4) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp1(build(rand, depth - 1)  ))\n| 2 -> buildCosine(buildOp1(build(rand, depth - 1) ))\n| _ -> buildSine(buildCosine(build(rand, depth - 1)))", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (depth - 1))))));;\n", "out": "Characters 50-59:\n  buildSine(buildX())\n  ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =  (*failwith \"to be written\" *)\nmatch e with\n| VarX                    -> \"x\"\n| VarY                    -> \"y\"\n| Sine e                  -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e                -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Op1 e                   -> \"((tan(pi*\" ^ exprToString e ^ \"))-(tan(pi*\" ^ exprToString e ^ \"))/2)\"\n| Op2 (e1, e2, e3)        -> \"(\" ^ exprToString e1 ^ \">\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^ \":(\" ^ exprToString e1 ^ \"-\" ^ exprToString e2 ^ \"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nlet randNumber = rand(1,2) in\nmatch randNumber with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,4) in\nlet randNum4 = rand(1,4) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildOp1(build(rand, depth - 1) )\n| 2 -> buildOp1(build(rand, depth - 1) )\n| _ -> match randNum4 with\n| 1 -> buildTimes (build(rand, depth - 1),(build(rand, depth - 1)))\n| 2 -> buildAverage (build(rand, depth - 1),(build(rand, depth - 1)))\n| 3 -> buildTimes (build(rand, depth - 2),(build(rand, depth - 2)))\n| 4 -> buildAverage (build(rand, depth - 2),(build(rand, depth - 2)))\n| _ -> fail", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> fail)));;\n", "out": "Characters 795-799:\n  | _ -> fail;;\n         ^^^^\nError: Unbound value fail\n"}, {"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ -> build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nlet randNumber = rand(1,2) in\nmatch randNumber with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,4) in\nlet randNum4 = rand(1,4) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildOp1(build(rand, depth - 1) )\n| 2 -> buildOp1(build(rand, depth - 1) )\n| _ -> match randNum4 with\n| 1 -> buildTimes (build(rand, depth - 1),(build(rand, depth - 1)))\n| 2 -> buildAverage (build(rand, depth - 1),(build(rand, depth - 1)))\n| 3 -> buildTimes (build(rand, depth - 2),(build(rand, depth - 2)))\n| 4 -> buildAverage (build(rand, depth - 2),(build(rand, depth - 2)))\n| _ -> failwith \"AHH\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nlet randNumber = rand(1,2) in\nmatch randNumber with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,4) in\nlet randNum4 = rand(1,4) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth - 1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildOp1(build(rand, depth - 1) )\n| 2 -> buildOp1(build(rand, depth - 1) )\n| _ -> match randNum4 with\n| 1 -> buildTimes (build(rand, depth - 1),(build(rand, depth - 1)))\n| 2 -> buildAverage (build(rand, depth - 1),(build(rand, depth - 1)))\n| 3 -> buildTimes (build(rand, depth - 2),(build(rand, depth - 2)))\n| 4 -> buildAverage (build(rand, depth - 2),(build(rand, depth - 2)))\n| _ -> failwith \"AHH\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen \nlet randNumber = rand(1,2) in\nmatch randNumber with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,4) in\nlet randNum4 = rand(1,2000) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildOp1(build(rand, depth - 1) )\n| 2 -> buildOp1(build(rand, depth - 1) )\n| _ -> match randNum4 mod 23 with\n| 0 -> buildTimes (build(rand, depth - 1),(build(rand, depth - 1)))\n| 1 -> buildAverage (build(rand, depth - 1),(build(rand, depth - 1)))\n| _ -> match randNum4 mod 15 with\n| 0 -> buildCosine(build(rand, depth - 1))\n| _ -> build(rand, depth)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 2000) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 mod 23 with\n               | 0 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 1 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | _ ->\n                   (match randNum4 mod 15 with\n                    | 0 -> buildCosine (build (rand, (depth - 1)))\n                    | _ -> build (rand, depth)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)\n| _          -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
