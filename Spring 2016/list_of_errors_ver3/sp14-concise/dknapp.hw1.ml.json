{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n % 2 = 0 then\n1\nelse []", "out": "Characters 30-31:\n  if n % 2 = 0 then\n       ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n = if (n % 2) = 0 then 1 else [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif (hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "out": "Characters 26-28:\n  if (hd xs) = [] then 0\n      ^^\nError: Unbound value hd\n", "min": "\nlet rec sumList xs =\n  if (hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif (xs hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "out": "Characters 29-31:\n  if (xs hd xs) = [] then 0\n         ^^\nError: Unbound value hd\n", "min": "\nlet rec sumList xs =\n  if (xs hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif (List.hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "out": "Characters 72-73:\n  h + (sumList t);;\n  ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs =\n  if (List.hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n mod 2 = 0 then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin List.rev (loop n)\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n mod 2) = 0\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    List.rev (loop n)\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n mod 2 = 0 then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n mod 2) = 0\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n mod 2 = 0 then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n mod 2) = 0\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n mod 2) = 0\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 2 = 0) & (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) & (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList digits n)", "out": "Characters 82-89:\n  else additivePersistence (sumList digits n);;\n                            ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then n else additivePersistence (sumList digits n);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList (digits n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then n else additivePersistence (sumList (digits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse let rec allDigits num =\nif num = 0 then []\nelse (allDigits (num / 10)) @ [num mod 10]\nin additivePersistence (sumList (allDigits n))", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then n\n  else\n    (let rec allDigits num =\n       if num = 0 then [] else (allDigits (num / 10)) @ [num mod 10] in\n     additivePersistence (sumList (allDigits n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif (n / 10) = 0 then 0\nelse let rec allDigits num =\nif num = 0 then []\nelse (allDigits (num / 10)) @ [num mod 10]\nin (additivePersistence (sumList (allDigits n))) + 1", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else\n    (let rec allDigits num =\n       if num = 0 then [] else (allDigits (num / 10)) @ [num mod 10] in\n     (additivePersistence (sumList (allDigits n))) + 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =  \nif (n / 10) = 0 then n\nelse let rec allDigits num =\nif num = 0 then []\nelse (allDigits (num / 10)) @ [num mod 10]\nin digitalRoot (sumList (allDigits n))", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0\n  then n\n  else\n    (let rec allDigits num =\n       if num = 0 then [] else (allDigits (num / 10)) @ [num mod 10] in\n     digitalRoot (sumList (allDigits n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.size lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.size (palHelper wEx)) = 0 then true\nelse false", "out": "Characters 71-80:\n  if (List.size lst) < 2 then []\n      ^^^^^^^^^\nError: Unbound value List.size\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.size lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.size (palHelper wEx)) = 0 then true else false;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "out": "Characters 124-137:\n  else if (List.hd lst) = (List.tl lst) then\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "out": "Characters 124-137:\n  else if (List.hd lst) = (List.tl lst) then\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) = (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "out": "Characters 124-137:\n  else if (List.tl lst) = (List.hd lst) then\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) == (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "out": "Characters 125-138:\n  else if (List.tl lst) == (List.hd lst) then\n                           ^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) == (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = (List.hd lst)) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "out": "Characters 125-138:\n  else if ((List.tl lst) = (List.hd lst)) then\n                           ^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = lst\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (sizeLst lst) < 2 then []\nelse \nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\nif b = b2 then palHelper rest2\nelse [1]\nin\nif (sizeLst (palHelper wEx)) = 0 then true\nelse false", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet rec sizeLst lst =\n  if lst = [] then 0 else (let h::t = lst in (sizeLst t) + 1);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (sizeLst lst) < 2\n    then []\n    else\n      (let b::rest = lst in\n       let b2::rest2 = listReverse rest in\n       if b = b2 then palHelper rest2 else [1]) in\n  if (sizeLst (palHelper wEx)) = 0 then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nif l = [] then []\nelse let rec revHelper (normLst, revLst) = \nif normLst = [] then ([], revLst)\nelse let h::nLst = normLst\nin (nLst, h::revLst)\n\nin let (x,y) = revHelper (l, [])\nin y", "out": "", "min": "\nlet rec listReverse l =\n  if l = []\n  then []\n  else\n    (let rec revHelper (normLst,revLst) =\n       if normLst = []\n       then ([], revLst)\n       else (let h::nLst = normLst in (nLst, (h :: revLst))) in\n     let (x,y) = revHelper (l, []) in y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nif l = [] then []\nelse let rec revHelper (normLst, revLst) = \nif normLst = [] then ([], revLst)\nelse let h::nLst = normLst\nin revHelper (nLst, h::revLst)\n\nin let (x,y) = revHelper (l, [])\nin y", "out": "", "min": "\nlet rec listReverse l =\n  if l = []\n  then []\n  else\n    (let rec revHelper (normLst,revLst) =\n       if normLst = []\n       then ([], revLst)\n       else (let h::nLst = normLst in revHelper (nLst, (h :: revLst))) in\n     let (x,y) = revHelper (l, []) in y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =  \nif (n / 10) = 0 then n\nelse let rec allDigits num =\nif num = 0 then []\nelse (allDigits (num / 10)) @ [num mod 10]\nin digitalRoot (sumList (allDigits n))", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0\n  then n\n  else\n    (let rec allDigits num =\n       if num = 0 then [] else (allDigits (num / 10)) @ [num mod 10] in\n     digitalRoot (sumList (allDigits n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nif l = [] then []\nelse let rec revHelper (normLst, revLst) = \nif normLst = [] then ([], revLst)\nelse let h::nLst = normLst\nin revHelper (nLst, h::revLst)\n\nin let (x,y) = revHelper (l, [])\nin y", "out": "", "min": "\nlet rec listReverse l =\n  if l = []\n  then []\n  else\n    (let rec revHelper (normLst,revLst) =\n       if normLst = []\n       then ([], revLst)\n       else (let h::nLst = normLst in revHelper (nLst, (h :: revLst))) in\n     let (x,y) = revHelper (l, []) in y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif (n / 10) = 0 then 0\nelse let rec allDigits num =\nif num = 0 then []\nelse (num mod 10)::(allDigits (num / 10))\nin (additivePersistence (sumList (allDigits n))) + 1", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else\n    (let rec allDigits num =\n       if num = 0 then [] else (num mod 10) :: (allDigits (num / 10)) in\n     (additivePersistence (sumList (allDigits n))) + 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =  \nif (n / 10) = 0 then n\nelse let rec allDigits num =\nif num = 0 then []\nelse (num mod 10)::(allDigits (num / 10))\nin digitalRoot (sumList (allDigits n))", "out": "", "min": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0\n  then n\n  else\n    (let rec allDigits num =\n       if num = 0 then [] else (num mod 10) :: (allDigits (num / 10)) in\n     digitalRoot (sumList (allDigits n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then input\nelse (loop (input / 10))::[(input mod 10)]\nin (loop n)\nelse []", "out": "Characters 109-146:\n  else (loop (input / 10))::[(input mod 10)]\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input < 10 then input else [loop (input / 10); input mod 10] in\n    loop n\n  else [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then [input]\nelse let [y] = (loop (input / 10)) in\ny::[(input mod 10)]\nin loop n\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input < 10\n      then [input]\n      else (let y::[] = loop (input / 10) in [y; input mod 10]) in\n    loop n\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then [input]\nelse let [y] = (loop (input / 10)) in\ny::[(input mod 10)]\nin loop n\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input < 10\n      then [input]\n      else (let y::[] = loop (input / 10) in [y; input mod 10]) in\n    loop n\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop (input, output) =\nif input = 0 then (0, output)\nelse loop ((input / 10), (input mod 10)::output)\nin let (x, y) = loop (n, [])\nin y\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop (input,output) =\n      if input = 0\n      then (0, output)\n      else loop ((input / 10), ((input mod 10) :: output)) in\n    let (x,y) = loop (n, []) in y\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop (input,output) =\n      if input = 0\n      then (0, output)\n      else loop ((input / 10), ((input mod 10) :: output)) in\n    let (x,y) = loop (n, []) in y\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop (input, output) =\nif input = 0 then (0, output)\nelse loop ((input / 10), (input mod 10)::output)\nin let (x, y) = loop (n, [])\nin y\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop (input,output) =\n      if input = 0\n      then (0, output)\n      else loop ((input / 10), ((input mod 10) :: output)) in\n    let (x,y) = loop (n, []) in y\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n > 0) then\nlet rec loop (input, output) =\nif input = 0 then (0, output)\nelse loop ((input / 10), (input mod 10)::output)\nin let (x, y) = loop (n, [])\nin y\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0\n  then\n    let rec loop (input,output) =\n      if input = 0\n      then (0, output)\n      else loop ((input / 10), ((input mod 10) :: output)) in\n    let (x,y) = loop (n, []) in y\n  else [];;\n", "type": ""}]}
