{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 30-31:\n  if n % 2 = 0 then\n       ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n = if (n % 2) = 0 then 1 else [];;\n", "in": "let rec digitsOfInt n = \nif n % 2 = 0 then\n1\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 26-28:\n  if (hd xs) = [] then 0\n      ^^\nError: Unbound value hd\n", "min": "\nlet rec sumList xs =\n  if (hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "in": "let rec sumList xs = \nif (hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-31:\n  if (xs hd xs) = [] then 0\n         ^^\nError: Unbound value hd\n", "min": "\nlet rec sumList xs =\n  if (xs hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "in": "let rec sumList xs = \nif (xs hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-73:\n  h + (sumList t);;\n  ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs =\n  if (List.hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "in": "let rec sumList xs = \nif (List.hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n mod 2 = 0 then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin List.rev (loop n)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n mod 2 = 0 then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n mod 2 = 0 then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 2 = 0) & (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-89:\n  else additivePersistence (sumList digits n);;\n                            ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then n else additivePersistence (sumList digits n);;\n", "in": "let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList digits n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse let rec allDigits num =\nif num = 0 then []\nelse (allDigits (num / 10)) @ [num mod 10]\nin additivePersistence (sumList (allDigits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n / 10) = 0 then 0\nelse let rec allDigits num =\nif num = 0 then []\nelse (allDigits (num / 10)) @ [num mod 10]\nin (additivePersistence (sumList (allDigits n))) + 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n =  \nif (n / 10) = 0 then n\nelse let rec allDigits num =\nif num = 0 then []\nelse (allDigits (num / 10)) @ [num mod 10]\nin digitalRoot (sumList (allDigits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 71-80:\n  if (List.size lst) < 2 then []\n      ^^^^^^^^^\nError: Unbound value List.size\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.size lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.size (palHelper wEx)) = 0 then true else false;;\n", "in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.size lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.size (palHelper wEx)) = 0 then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 124-137:\n  else if (List.hd lst) = (List.tl lst) then\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 124-137:\n  else if (List.hd lst) = (List.tl lst) then\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 124-137:\n  else if (List.tl lst) = (List.hd lst) then\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) = (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 125-138:\n  else if (List.tl lst) == (List.hd lst) then\n                           ^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) == (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) == (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 125-138:\n  else if ((List.tl lst) = (List.hd lst)) then\n                           ^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = (List.hd lst)) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (sizeLst lst) < 2 then []\nelse \nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\nif b = b2 then palHelper rest2\nelse [1]\nin\nif (sizeLst (palHelper wEx)) = 0 then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif l = [] then []\nelse let rec revHelper (normLst, revLst) = \nif normLst = [] then ([], revLst)\nelse let h::nLst = normLst\nin (nLst, h::revLst)\n\nin let (x,y) = revHelper (l, [])\nin y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif l = [] then []\nelse let rec revHelper (normLst, revLst) = \nif normLst = [] then ([], revLst)\nelse let h::nLst = normLst\nin revHelper (nLst, h::revLst)\n\nin let (x,y) = revHelper (l, [])\nin y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n =  \nif (n / 10) = 0 then n\nelse let rec allDigits num =\nif num = 0 then []\nelse (allDigits (num / 10)) @ [num mod 10]\nin digitalRoot (sumList (allDigits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif l = [] then []\nelse let rec revHelper (normLst, revLst) = \nif normLst = [] then ([], revLst)\nelse let h::nLst = normLst\nin revHelper (nLst, h::revLst)\n\nin let (x,y) = revHelper (l, [])\nin y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n / 10) = 0 then 0\nelse let rec allDigits num =\nif num = 0 then []\nelse (num mod 10)::(allDigits (num / 10))\nin (additivePersistence (sumList (allDigits n))) + 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n =  \nif (n / 10) = 0 then n\nelse let rec allDigits num =\nif num = 0 then []\nelse (num mod 10)::(allDigits (num / 10))\nin digitalRoot (sumList (allDigits n))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-146:\n  else (loop (input / 10))::[(input mod 10)]\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input < 10 then input else [loop (input / 10); input mod 10] in\n    loop n\n  else [];;\n", "in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then input\nelse (loop (input / 10))::[(input mod 10)]\nin (loop n)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then [input]\nelse let [y] = (loop (input / 10)) in\ny::[(input mod 10)]\nin loop n\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then [input]\nelse let [y] = (loop (input / 10)) in\ny::[(input mod 10)]\nin loop n\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop (input, output) =\nif input = 0 then (0, output)\nelse loop ((input / 10), (input mod 10)::output)\nin let (x, y) = loop (n, [])\nin y\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop (input, output) =\nif input = 0 then (0, output)\nelse loop ((input / 10), (input mod 10)::output)\nin let (x, y) = loop (n, [])\nin y\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n > 0) then\nlet rec loop (input, output) =\nif input = 0 then (0, output)\nelse loop ((input / 10), (input mod 10)::output)\nin let (x, y) = loop (n, [])\nin y\nelse []"}]}
