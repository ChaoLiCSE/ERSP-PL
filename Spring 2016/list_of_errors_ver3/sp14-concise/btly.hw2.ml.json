{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (h1, h2)::t -> if k = h1 then h2\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 86-88:\n  in f b';;\n       ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) =\n  let helper (b',c') = if c' then wwhile (f, b') else b' in f b';;\n", "in": "let rec wwhile (f,b) = \nlet helper (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet helper (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 43-45:\n  if c' then wwhile (f, b')\n     ^^\nError: Unbound value c'\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = if c' then wwhile (f, b') else b' in f b;;\n", "in": "let rec wwhile (f,b) = \nlet (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 27-29:\n  if c' then wwhile (f, b')\n     ^^\nError: Unbound value c'\n", "min": "\nlet _ =\n  let rec wwhile (f,b) = if c' then wwhile (f, b') else b' in f b (b', c');;\n", "in": "let rec wwhile (f,b) = \nif c' then wwhile (f, b')\nelse b'\nin f b(b', c')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f b with\n| (b', c') -> if c' then wwhile (f, b')\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nmatch f b with\n| (b', c') -> \nif c' then wwhile (f, b')\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> let x = f b in (x, b != x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-1:\n  l;;\n  ^\nError: Unbound value l\n", "min": "\nlet _ = l;;\n", "in": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> let x = f b in (f', f' != x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> let x = f b in (x, x != f')),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile ((fun f' -> let x = (f b) in (x, x != f')),b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun f' -> let x = (f b) in (x, x != f')),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun f'  -> let x = f b in (x, (x != f'))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile ((fun f' -> let x = (f f') in (x, x != f')),b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun f' -> let x = (f f') in (x, x != f')),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun f'  -> let x = f f' in (x, (x != f'))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e' -> \"sin (pi*\" ^ (exprToString e') ^ \")\"\n| Cosine e' -> \"cos (pi*\" ^ (exprToString e') ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \" * \" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \" ? \" ^ (exprToString e3) ^ \" : \" ^ (exprToString e4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e' -> \"sin (pi*\" ^ (exprToString e') ^ \")\"\n| Cosine e' -> \"cos (pi*\" ^ (exprToString e') ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \" * \" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \" ? \" ^ (exprToString e3) ^ \" : \" ^ (exprToString e4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e' -> \"sin(pi*\" ^ (exprToString e') ^ \")\"\n| Cosine e' -> \"cos(pi*\" ^ (exprToString e') ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^ (exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 89-91:\n  | Sine e' -> sin(pi *. (eval e'))\n                               ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval e' x y))\n| Cosine e' -> cos(pi *. (eval e' x y))\n| Average (e1, e2) -> (((eval e1 x y) +. (eval e2 x y))/2)\n| Times (e1, e2) -> ((eval e1 x y) *. (eval e2 x y))\n| Thresh (e1, e2, e3, e4) -> (if ((eval e1 x y)<(eval e2 x y)) then (eval e3 x y) else (eval e4 x y))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 89-91:\n  | Sine e' -> sin(pi *. (eval e' x y))\n                               ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) / 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1 x y) < (eval e2 x y) then eval e3 x y else eval e4 x y;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e'(e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))\n\n\n(* uncomment after implementing eval\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}, {"type": "scope", "out": "Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "*)\n\n\nlet eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv\n\nlet sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(******************** Random Number Generators ************)\n\n(* makeRand int * int -> (int * int -> int)\nReturns a function that, given a low and a high, returns\na random int between the limits.  seed1 and seed2 are the\nrandom number seeds.  Pass the result of this function\nto build \n\nExample:\nlet rand = makeRand(10,39) in \nlet x =  rand(1,4) in \n(* x is 1,2,3, or 4 *)\n*)\n\nlet makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(********************* Bitmap creation code ***************)\n\n(* \nYou should not have to modify the remaining functions.\nAdd testing code to the bottom of the file.\n*)\n\n(* Converts an integer i from the range [-N,N] into a float in [-1,1] *)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(* Converts real in [-1,1] to an integer in the range [0,255]  *)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(* ffor: int * int * (int -> unit) -> unit\nApplies the function f to all the integers between low and high\ninclusive; the results get thrown away.\n*)\n\nlet rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)\n\n(* emitGrayscale :  ((real * real) -> real) * int -> unit\nemitGrayscale(f, N) emits the values of the expression\nf (converted to intensity) to the file art.pgm for an \n2N+1 by 2N+1 grid of points taken from [-1,1] x [-1,1].\n\nSee \"man pgm\" on turing for a full description of the file format,\nbut it's essentially a one-line header followed by\none byte (representing gray value 0..255) per pixel.\n*)\n\nlet emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(* doRandomGray : int * int * int -> unit\nGiven a depth and two seeds for the random number generator,\ncreate a single random expression and convert it to a\ngrayscale picture with the name \"art.pgm\" *)\n\nlet doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)\n\n(* uncomment when you have implemented `build`\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") "}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 90-92:\n  | Sine e' -> sin(pi *. (eval (e'(e', x, y))))\n                                ^^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e' (e', x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 125-165:\n  | Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Cosine e' -> cos(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (h1, h2)::t -> if k = h1 then h2\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand 0 4 with\n| 0 -> buildSine(build(rand, (depth-1)))\n| 1 -> buildCosine(build(rand, (depth-1)))\n| 2 -> buildAverage((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 3 -> buildTimes((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 4 -> buildThresh((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))\n| 5 -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand 0 4 with\n| 0 -> buildSine(build(rand, (depth-1)))\n| 1 -> buildCosine(build(rand, (depth-1)))\n| 2 -> buildAverage((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 3 -> buildTimes((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 4 -> buildThresh((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then match rand (0, 1) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (0, 4) with\n| 0 -> buildSine(build(rand, (depth-1)))\n| 1 -> buildCosine(build(rand, (depth-1)))\n| 2 -> buildAverage((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 3 -> buildTimes((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 4 -> buildThresh((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then match rand (0, 1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"default\"\nelse\nmatch rand (0, 4) with\n| 0 -> buildSine(build(rand, (depth-1)))\n| 1 -> buildCosine(build(rand, (depth-1)))\n| 2 -> buildAverage((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 3 -> buildTimes((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 4 -> buildThresh((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))\n| _ -> failwith \"default\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Cosine e' -> cos(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then match rand (0, 1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"default\"\nelse\nmatch rand (0, 4) with\n| 0 -> buildSine(build(rand, (depth-1)))\n| 1 -> buildCosine(build(rand, (depth-1)))\n| 2 -> buildAverage((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 3 -> buildTimes((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 4 -> buildThresh((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))\n| _ -> failwith \"default\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then match rand (0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"default\"\nelse\nmatch rand (0, 4) with\n| 0 -> buildSine(build(rand, (depth-1)))\n| 1 -> buildCosine(build(rand, (depth-1)))\n| 2 -> buildAverage((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 3 -> buildTimes((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 4 -> buildThresh((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))\n| _ -> failwith \"default\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then match rand (0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"default\"\nelse\nmatch rand (0, 5) with\n| 0 -> buildSine(build(rand, (depth-1)))\n| 1 -> buildCosine(build(rand, (depth-1)))\n| 2 -> buildAverage((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 3 -> buildTimes((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 4 -> buildThresh((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))\n| _ -> failwith \"default\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Tangent of expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Custom1   of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildCustom1(e1, e2, e3)\t\t   = Custom1(e1, e2, e3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildCustom1(e1, e2, e3)\t   = Custom1(e1, e2, e3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 522-524:\n  | Custom1 (e1, e2, e3) -> ((cos(pi *. (eval (e1, x, y)))) *. (sin(pi *. (eval (e2, x, y)))))*.((cos(pi *. (eval (e3, x, y))))^.(2));;\n                                                                                                                               ^^\nError: Unbound value ^.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Custom1 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Custom1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        ((cos (pi *. (eval (e3, x, y)))) ^. 2);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Cosine e' -> cos(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))\n| Custom1 (e1, e2, e3) -> ((cos(pi *. (eval (e1, x, y)))) *. (sin(pi *. (eval (e2, x, y)))))*.((cos(pi *. (eval (e3, x, y))))**(2.0))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Cosine e' -> cos(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))\n| Custom1 (e1, e2, e3) -> ((cos(pi *. (eval (e1, x, y)))) *. (sin(pi *. (eval (e2, x, y)))))*.((cos(pi *. (eval (e3, x, y))))**(2.0))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Custom1  of expr * expr * expr\n| Custom2  of expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then match rand (0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"default\"\nelse\nmatch rand (0, 7) with\n| 0 -> buildSine(build(rand, (depth-1)))\n| 1 -> buildCosine(build(rand, (depth-1)))\n| 2 -> buildAverage((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 3 -> buildTimes((build(rand, (depth-1))), (build(rand, (depth-1))))\n| 4 -> buildThresh((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))\n| 5 -> buildCustom1((build(rand, (depth-1))), (build(rand, (depth-1))), (build(rand, (depth-1))))\n| 6 -> buildCustom2((build(rand, (depth-1))), (build(rand, (depth-1))))\n| _ -> failwith \"default\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
