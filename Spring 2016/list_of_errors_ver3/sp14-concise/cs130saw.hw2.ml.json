{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::ls -> if k = ki then vi else assoc (d, k, ls)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::ls -> if k = ki then vi else assoc (d, k, ls)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h :: seen in\nlet rest' = if List.mem h seen then rest else h :: rest in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = if List.mem h seen then rest else h :: rest in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if M.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if M.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 110-115:\n  let seen' = if M.mem h seen then seen else h :: seen in\n                 ^^^^^\nError: Unbound module M\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::ls -> if k = ki then vi else assoc (d, k, ls)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b\nin if c'\nthen wwhile (f, b')\nelse b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((f, f b != b),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "out": "Characters 29-42:\n  wwhile ((f, f b != b),b);;\n          ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((f, (f b) != b),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "out": "Characters 29-44:\n  wwhile ((f, (f b) != b),b);;\n          ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((f, f b = b),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "out": "Characters 29-41:\n  wwhile ((f, f b = b),b);;\n          ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((f, true),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, true), b);;\n", "out": "Characters 29-38:\n  wwhile ((f, true),b);;\n          ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", true),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), true), b);;\n", "out": "Characters 29-51:\n  wwhile ((failwith \"asd\", true),b);;\n          ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", failwith \"asd\"),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), (failwith \"asd\")), b);;\n", "out": "Characters 29-61:\n  wwhile ((failwith \"asd\", failwith \"asd\"),b);;\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", undefined),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), undefined), b);;\n", "out": "Characters 29-56:\n  wwhile ((failwith \"asd\", undefined),b);;\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((failwith \"Asd\"),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((failwith \"Asd\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), false) else (((f b), true), b));;\n", "out": "Characters 63-74:\n  wwhile (if f b = b then (f b, false) else (f b, true),b);;\n                                            ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else failwith \"asd\" ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), false) else ((failwith \"asd\"), b));;\n", "out": "Characters 79-80:\n  wwhile (if f b = b then (f b, false) else failwith \"asd\" ,b);;\n                                                            ^\nError: This expression has type bool -> bool * bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (f b, false) else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then ((f b), false) else failwith \"asd\"), b);;\n", "out": "Characters 46-58:\n  wwhile ((if f b = b then (f b, false) else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then failwith \"asd\" else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then failwith \"asd\" else failwith \"asd\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\") else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then failwith \"asd\" else failwith \"asd\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\", true) else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then ((failwith \"asd\"), true) else failwith \"asd\"), b);;\n", "out": "Characters 46-68:\n  wwhile ((if f b = b then (failwith \"asd\", true) else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (true, failwith \"asd\") else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then (true, (failwith \"asd\")) else failwith \"asd\"), b);;\n", "out": "Characters 46-68:\n  wwhile ((if f b = b then (true, failwith \"asd\") else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (b, failwith \"asd\") else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (b, (failwith \"asd\")) else failwith \"asd\"), b);;\n", "out": "Characters 46-65:\n  wwhile ((if f b = b then (b, failwith \"asd\") else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"Asd\", failwith \"asd\") else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then ((failwith \"Asd\"), (failwith \"asd\"))\n      else failwith \"asd\"), b);;\n", "out": "Characters 46-78:\n  wwhile ((if f b = b then (failwith \"Asd\", failwith \"asd\") else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (failwith \"Asd\", failwith \"asd\")) else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((failwith \"Asd\"), (failwith \"asd\"))\n      else failwith \"asd\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (f b, false)) else failwith \"asd\") ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then fun b''  -> ((f b), false) else failwith \"asd\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b''\n-> (f b, false)) \nelse (fun b'' -> (f b, true))) ,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b'' -> (f b, false)) \nelse (fun b'' -> (f b, true))), b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile ((fun b' -> if f b' = b' \nthen (f b, false)\nelse (f b, true)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((fun b'  -> if (f b') = b' then ((f b), false) else ((f b), true)), b);;\n", "out": "Characters 21-27:\n  wwhile ((fun b' -> if f b' = b' \n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile ((fun b' -> if f b' = b' \nthen (f b', false)\nelse (f b', true)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((fun b'  -> if (f b') = b' then ((f b'), false) else ((f b'), true)), b);;\n", "out": "Characters 21-27:\n  wwhile ((fun b' -> if f b' = b' \n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi*\" ^ (exprToString e) ^ \")\"\n| Cosine e -> \"cos(pi*\" ^ (exprToString e) ^ \")\"\n| Average (a, b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a, b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a, b, c, d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi * eval (i, x, y))\n| Cosine i -> cos (pi * eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi * (eval (i, x, y)))\n  | Cosine i -> cos (pi * (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "out": "Characters 75-77:\n  | Sine i -> sin (pi * eval (i, x, y))\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi * eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi * (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "out": "Characters 116-118:\n  | Cosine i -> cos (pi * eval (i, x, y))\n                     ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "out": "Characters 162-179:\n  | Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0);;\n                          ^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0;;\n", "out": "Characters 161-201:\n  | Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0);;\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) <. (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) <. (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n", "out": "Characters 320-322:\n  if (eval (i1, x, y)) <. (eval (i2, x, y)) \n                       ^^\nError: Unbound value <.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage (build (rand, depth - 1)) (build (rand, depth - 1))\n| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))\n| 6 -> VarX\n| 7 -> VarY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 -> buildAverage (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 4 -> buildTimes (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 5 ->\n      buildThresh (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n        (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "out": "Characters 192-204:\n  | 3 -> buildAverage (build (rand, depth - 1)) (build (rand, depth - 1))\n         ^^^^^^^^^^^^\nError: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))\n| 6 -> VarX\n| 7 -> VarY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 -> buildTimes (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 5 ->\n      buildThresh (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n        (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "out": "Characters 267-277:\n  | 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n         ^^^^^^^^^^\nError: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> VarX\n| 7 -> VarY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 -> VarX\n  | 7 -> VarY;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 -> VarX\n  | 7 -> VarY;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::ls -> if k = ki then vi else assoc (d, k, ls)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 8) else (1, 6)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> VarX\n| 7 -> VarY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 8) else (1, 6)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 8) else (1, 6)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 -> VarX\n  | 7 -> VarY;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::ls -> if k = ki then vi else assoc (d, k, ls)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::ls -> if k = ki then vi else assoc (d, k, ls)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (7, 9) else (1, 7)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> buildECosSin ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 7 -> VarX\n| 8 -> VarY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildECosSin (a,b) = ECosSin (a, b);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (7, 9) else (1, 7)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 -> VarX\n  | 8 -> VarY;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::ls -> if k = ki then vi else assoc (d, k, ls)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| ECosSin  of expr * expr\n| SinLog   of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a,b,c) ->\nif c < 0\nthen (log (x *. 100)) ** (sin (x *. 100)) -. 1.0\nelse -1.0 *. ((log (x *. 100)) ** (sin (x *. 100)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if c < 0\n      then ((log (x *. 100)) ** (sin (x *. 100))) -. 1.0\n      else (-1.0) *. (((log (x *. 100)) ** (sin (x *. 100))) -. 1.0);;\n", "out": "Characters 513-514:\n  if c < 0\n         ^\nError: This expression has type int but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a,b,c) ->\nif c < 0.0\nthen (log (x *. 100)) ** (sin (x *. 100)) -. 1.0\nelse -1.0 *. ((log (x *. 100)) ** (sin (x *. 100)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if c < 0.0\n      then ((log (x *. 100)) ** (sin (x *. 100))) -. 1.0\n      else (-1.0) *. (((log (x *. 100)) ** (sin (x *. 100))) -. 1.0);;\n", "out": "Characters 513-516:\n  if c < 0.0\n         ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a,b,c) ->\nif eval (c, x, y) < 0.0\nthen (log ((eval (a, x, y)) *. 100)) ** (sin ((eval (b, x, y)) *. 100)) -. 1.0\nelse -1.0 *. ((log ((eval (b, x, y)) *. 100)) ** (sin ((eval (a, x, y)) *. 100)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if (eval (c, x, y)) < 0.0\n      then\n        ((log ((eval (a, x, y)) *. 100)) ** (sin ((eval (b, x, y)) *. 100)))\n          -. 1.0\n      else\n        (-1.0) *.\n          (((log ((eval (b, x, y)) *. 100)) **\n              (sin ((eval (a, x, y)) *. 100)))\n             -. 1.0);;\n", "out": "Characters 561-564:\n  then (log ((eval (a, x, y)) *. 100)) ** (sin ((eval (b, x, y)) *. 100)) -. 1.0\n                                 ^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a,b,c) ->\nif eval (c, x, y) < 0.0\nthen (log ((eval (a, x, y)) *. 100.0)) ** (sin ((eval (b, x, y)) *. 100.0)) -. 1.0\nelse -1.0 *. ((log ((eval (b, x, y)) *. 100.0)) ** (sin ((eval (a, x, y)) *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if (eval (c, x, y)) < 0.0\n      then\n        ((log ((eval (a, x, y)) *. 100.0)) **\n           (sin ((eval (b, x, y)) *. 100.0)))\n          -. 1.0\n      else\n        (-1.0) *.\n          (((log ((eval (b, x, y)) *. 100.0)) **\n              (sin ((eval (a, x, y)) *. 100.0)))\n             -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (8, 10) else (1, 8)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> buildECosSin ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 7 -> buildSinLog ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 8 -> VarX\n| 9 -> VarY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildECosSin (a,b) = ECosSin (a, b);;\n\nlet buildSinLog (a,b,c) = SinLog (a, b, c);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (8, 10) else (1, 8)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildSinLog\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))))\n  | 8 -> VarX\n  | 9 -> VarY;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs (eval (a', x, y))\nin let b = abs (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs (eval (a', x, y)) in\n      let b = abs (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin (b *. 100.0))) -. 1.0\n      else (-1.0) *. (((log (b *. 100.0)) ** (sin (a *. 100.0))) -. 1.0);;\n", "out": "Characters 520-537:\n  let a = abs (eval (a', x, y))\n              ^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = absf (eval (a', x, y))\nin let b = abs (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = absf (eval (a', x, y)) in\n      let b = abs (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin (b *. 100.0))) -. 1.0\n      else (-1.0) *. (((log (b *. 100.0)) ** (sin (a *. 100.0))) -. 1.0);;\n", "out": "Characters 516-520:\n  let a = absf (eval (a', x, y))\n          ^^^^\nError: Unbound value absf\nHint: Did you mean abs?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin (b *. 100.0))) -. 1.0\n      else (-1.0) *. (((log (b *. 100.0)) ** (sin (a *. 100.0))) -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin (b *. 100.0))) -. 1.0\n      else (-1.0) *. (((log (b *. 100.0)) ** (sin (a *. 100.0))) -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *. (((log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max 0.1 l' in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": "Characters 617-620:\n  in let my_log = fun l' -> let l = max 0.1 l' in (log l) / (log 10.0)\n                                    ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": "Characters 618-621:\n  in let my_log = fun l' -> let l = (max 0.1 l') in (log l) / (log 10.0)\n                                     ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = min 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": "Characters 633-640:\n  in let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)\n                                                    ^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = min 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": "Characters 618-621:\n  in let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\n                                     ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let max' = fun a b -> if a > b then a else b\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let max' a b = if a > b then a else b in\n      let my_log l' = let l = max 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": "Characters 666-669:\n  in let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\n                                     ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let max' = fun a b -> if a > b then a else b\nin let my_log = fun l' -> let l = (max' 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let max' a b = if a > b then a else b in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let max' = fun a b -> if a > b then a else b\nin let my_log = fun l' -> let l = (max' 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let max' a b = if a > b then a else b in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::ls -> if k = ki then vi else assoc (d, k, ls)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 1.0 (*2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0 *)\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) -> 1.0\n  | SinLog (a',b',c) -> 1.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0)\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      min 1.0\n        ((2.71 **\n            (((sin (pi *. (eval (a, x, y)))) +.\n                (cos (pi *. (eval (b, x, y)))))\n               -. 1.0))\n           -. 1.0)\n  | SinLog (a',b',c) -> 1.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> max -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      max -\n        (1.0\n           (min 1.0\n              ((2.71 **\n                  (((sin (pi *. (eval (a, x, y)))) +.\n                      (cos (pi *. (eval (b, x, y)))))\n                     -. 1.0))\n                 -. 1.0)))\n  | SinLog (a',b',c) -> 1.0;;\n", "out": "Characters 402-405:\n  | ECosSin (a,b) -> max -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n                     ^^^\nError: This expression has type int ref\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      max 1.0\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "out": "Characters 402-405:\n  | ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n                     ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' 1.0\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' -\n        (1.0\n           (min 1.0\n              ((2.71 **\n                  (((sin (pi *. (eval (a, x, y)))) +.\n                      (cos (pi *. (eval (b, x, y)))))\n                     -. 1.0))\n                 -. 1.0)))\n  | SinLog (a',b',c) -> 1.0;;\n", "out": "Characters 450-454:\n  in max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n     ^^^^\nError: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0-1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 - 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "out": "Characters 456-459:\n  in max' (0.0-1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n           ^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": "Characters 759-766:\n  in let my_log = fun l' -> let l = max' 0.1 l' in (log l) / (log 10.0)\n                                                   ^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nmax' (0.0 -. 1.0) (min 1.0 (\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           (if (eval (c, x, y)) < 0.0\n            then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n            else\n              (-1.0) *.\n                (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           (if (eval (c, x, y)) < 0.0\n            then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n            else\n              (-1.0) *.\n                (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildECosSin (a,b) = ECosSin (a, b);;\n\nlet buildSinLog (a,b,c) = SinLog (a, b, c);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (8, 10) else (1, 8)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildSinLog\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))))\n  | 8 -> VarX\n  | 9 -> VarY;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | ECosSin (a,b) ->\n      \"ecossin(\" ^ ((exprToString a) ^ (\",\" ^ ((exprToString b) ^ \")\")))\n  | SinLog (a,b,c) ->\n      \"sinlog(\" ^\n        ((exprToString a) ^\n           (\",\" ^ ((exprToString b) ^ (\",\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> Printf.sprintf \"sin(pi*%s)\" (exprToString e)\n| Cosine e -> \"cos(pi*\" ^ (exprToString e) ^ \")\"\n| Average (a, b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a, b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a, b, c, d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| ECosSin (a, b) -> \"ecossin(\" ^ (exprToString a) ^ \",\" ^ (exprToString b) ^ \")\"\n| SinLog (a, b, c) -> \"sinlog(\" ^ (exprToString a) ^ \",\" ^ (exprToString b) ^ \",\" ^ (exprToString c) ^ \")\"", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> Printf.sprintf \"sin(pi*%s)\" (exprToString e)\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | ECosSin (a,b) ->\n      \"ecossin(\" ^ ((exprToString a) ^ (\",\" ^ ((exprToString b) ^ \")\")))\n  | SinLog (a,b,c) ->\n      \"sinlog(\" ^\n        ((exprToString a) ^\n           (\",\" ^ ((exprToString b) ^ (\",\" ^ ((exprToString c) ^ \")\")))));;\n", "out": "Characters 38-42:\n  VarX -> \"x\"\n  ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildX()                       = VarX", "min": "\nlet buildX () = VarX;;\n", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildY()                       = VarY", "min": "\nlet buildY () = VarY;;\n", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n"}, {"type": "scope", "in": "let buildSine(e)                   = Sine(e)", "min": "\nlet buildSine e = Sine e;;\n", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n"}, {"type": "scope", "in": "let buildCosine(e)                 = Cosine(e)", "min": "\nlet buildCosine e = Cosine e;;\n", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n"}, {"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let buildECosSin(a,b)\t\t   = ECosSin(a,b)", "min": "\nlet buildECosSin (a,b) = ECosSin (a, b);;\n", "out": "Characters 28-35:\n  let buildECosSin(a,b)\t\t   = ECosSin(a,b);;\n                              ^^^^^^^\nError: Unbound constructor ECosSin\n"}, {"type": "scope", "in": "let buildSinLog(a,b,c)\t\t   = SinLog(a,b,c)", "min": "\nlet buildSinLog (a,b,c) = SinLog (a, b, c);;\n", "out": "Characters 29-35:\n  let buildSinLog(a,b,c)\t\t   = SinLog(a,b,c);;\n                               ^^^^^^\nError: Unbound constructor SinLog\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nmax' (0.0 -. 1.0) (min 1.0 (\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           (if (eval (c, x, y)) < 0.0\n            then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n            else\n              (-1.0) *.\n                (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0)));;\n", "out": "Characters 36-40:\n  VarX -> x\n  ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}, {"type": "scope", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (8, 10) else (1, 8)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> buildECosSin ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 7 -> buildSinLog ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 8 -> VarX\n| 9 -> VarY", "min": "\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (8, 10) else (1, 8)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildSinLog\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))))\n  | 8 -> VarX\n  | 9 -> VarY;;\n", "out": "Characters 105-114:\n  1 -> buildSine (build (rand, depth - 1))\n       ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> Printf.sprintf \"sin(pi*%s)\" (exprToString e)\n| Cosine e -> Printf.sprintf \"cos(pi*%s)\" (exprToString e)\n| Average (a, b) -> Printf.sprintf \"((%s+%s)/2)\" (exprToString a) (exprToString b)\n| Times (a, b) -> Printf.sprintf \"%s*%s\" (exprToString a) (exprToString b)\n| Thresh (a, b, c, d) -> Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString a) (exprToString b) (exprToString c) (exprToString d)\n| ECosSin (a, b) -> Printf.sprintf \"ecossin(%s,%s)\" (exprToString a) (exprToString b)\n| SinLog (a, b, c) -> Printf.sprintf \"sinlog(%s,%s,%s)\" (exprToString a) (exprToString b) (exprToString c)", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> Printf.sprintf \"sin(pi*%s)\" (exprToString e)\n  | Cosine e -> Printf.sprintf \"cos(pi*%s)\" (exprToString e)\n  | Average (a,b) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString a) (exprToString b)\n  | Times (a,b) -> Printf.sprintf \"%s*%s\" (exprToString a) (exprToString b)\n  | Thresh (a,b,c,d) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | ECosSin (a,b) ->\n      Printf.sprintf \"ecossin(%s,%s)\" (exprToString a) (exprToString b)\n  | SinLog (a,b,c) ->\n      Printf.sprintf \"sinlog(%s,%s,%s)\" (exprToString a) (exprToString b)\n        (exprToString c);;\n", "out": "Characters 38-42:\n  VarX -> \"x\"\n  ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildX()                       = VarX", "min": "\nlet buildX () = VarX;;\n", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildY()                       = VarY", "min": "\nlet buildY () = VarY;;\n", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n"}, {"type": "scope", "in": "let buildSine(e)                   = Sine(e)", "min": "\nlet buildSine e = Sine e;;\n", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n"}, {"type": "scope", "in": "let buildCosine(e)                 = Cosine(e)", "min": "\nlet buildCosine e = Cosine e;;\n", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n"}, {"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let buildECosSin(a,b)\t\t   = ECosSin(a,b)", "min": "\nlet buildECosSin (a,b) = ECosSin (a, b);;\n", "out": "Characters 28-35:\n  let buildECosSin(a,b)\t\t   = ECosSin(a,b);;\n                              ^^^^^^^\nError: Unbound constructor ECosSin\n"}, {"type": "scope", "in": "let buildSinLog(a,b,c)\t\t   = SinLog(a,b,c)", "min": "\nlet buildSinLog (a,b,c) = SinLog (a, b, c);;\n", "out": "Characters 29-35:\n  let buildSinLog(a,b,c)\t\t   = SinLog(a,b,c);;\n                               ^^^^^^\nError: Unbound constructor SinLog\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nmax' (0.0 -. 1.0) (min 1.0 (\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           (if (eval (c, x, y)) < 0.0\n            then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n            else\n              (-1.0) *.\n                (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0)));;\n", "out": "Characters 36-40:\n  VarX -> x\n  ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}, {"type": "scope", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (8, 10) else (1, 8)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> buildECosSin ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 7 -> buildSinLog ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 8 -> VarX\n| 9 -> VarY", "min": "\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (8, 10) else (1, 8)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildSinLog\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))))\n  | 8 -> VarX\n  | 9 -> VarY;;\n", "out": "Characters 105-114:\n  1 -> buildSine (build (rand, depth - 1))\n       ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let buildX()                       = VarX", "min": "\nlet buildX () = VarX;;\n", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildY()                       = VarY", "min": "\nlet buildY () = VarY;;\n", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n"}, {"type": "scope", "in": "let buildSine(e)                   = Sine(e)", "min": "\nlet buildSine e = Sine e;;\n", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n"}, {"type": "scope", "in": "let buildCosine(e)                 = Cosine(e)", "min": "\nlet buildCosine e = Cosine e;;\n", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n"}, {"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let buildECosSin(a,b)\t\t   = ECosSin(a,b)", "min": "\nlet buildECosSin (a,b) = ECosSin (a, b);;\n", "out": "Characters 28-35:\n  let buildECosSin(a,b)\t\t   = ECosSin(a,b);;\n                              ^^^^^^^\nError: Unbound constructor ECosSin\n"}, {"type": "scope", "in": "let buildSinLog(a,b,c)\t\t   = SinLog(a,b,c)", "min": "\nlet buildSinLog (a,b,c) = SinLog (a, b, c);;\n", "out": "Characters 29-35:\n  let buildSinLog(a,b,c)\t\t   = SinLog(a,b,c);;\n                               ^^^^^^\nError: Unbound constructor SinLog\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nmax' (0.0 -. 1.0) (min 1.0 (\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           (if (eval (c, x, y)) < 0.0\n            then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n            else\n              (-1.0) *.\n                (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0)));;\n", "out": "Characters 36-40:\n  VarX -> x\n  ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}, {"type": "scope", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (8, 10) else (1, 8)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> buildECosSin ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 7 -> buildSinLog ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 8 -> VarX\n| 9 -> VarY", "min": "\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (8, 10) else (1, 8)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildSinLog\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))))\n  | 8 -> VarX\n  | 9 -> VarY;;\n", "out": "Characters 105-114:\n  1 -> buildSine (build (rand, depth - 1))\n       ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
