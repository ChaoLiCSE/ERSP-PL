{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h :: seen in\nlet rest' = if List.mem h seen then rest else h :: rest in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if M.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b\nin if c'\nthen wwhile (f, b')\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile ((f, f b != b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-42:\n  wwhile ((f, f b != b),b);;\n          ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((f, (f b) != b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-44:\n  wwhile ((f, (f b) != b),b);;\n          ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((f, f b = b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-41:\n  wwhile ((f, f b = b),b);;\n          ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((f, true),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-38:\n  wwhile ((f, true),b);;\n          ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, true), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", true),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-51:\n  wwhile ((failwith \"asd\", true),b);;\n          ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), true), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", failwith \"asd\"),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-61:\n  wwhile ((failwith \"asd\", failwith \"asd\"),b);;\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), (failwith \"asd\")), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", undefined),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-56:\n  wwhile ((failwith \"asd\", undefined),b);;\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), undefined), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((failwith \"Asd\"),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-74:\n  wwhile (if f b = b then (f b, false) else (f b, true),b);;\n                                            ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), false) else (((f b), true), b));;\n", "in": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else failwith \"asd\" ,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-80:\n  wwhile (if f b = b then (f b, false) else failwith \"asd\" ,b);;\n                                                            ^\nError: This expression has type bool -> bool * bool\n       but an expression was expected of type bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), false) else ((failwith \"asd\"), b));;\n", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (f b, false) else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-58:\n  wwhile ((if f b = b then (f b, false) else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then ((f b), false) else failwith \"asd\"), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then failwith \"asd\" else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\") else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\", true) else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-68:\n  wwhile ((if f b = b then (failwith \"asd\", true) else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then ((failwith \"asd\"), true) else failwith \"asd\"), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (true, failwith \"asd\") else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-68:\n  wwhile ((if f b = b then (true, failwith \"asd\") else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then (true, (failwith \"asd\")) else failwith \"asd\"), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (b, failwith \"asd\") else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-65:\n  wwhile ((if f b = b then (b, failwith \"asd\") else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (b, (failwith \"asd\")) else failwith \"asd\"), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"Asd\", failwith \"asd\") else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-78:\n  wwhile ((if f b = b then (failwith \"Asd\", failwith \"asd\") else failwith \"asd\") ,b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then ((failwith \"Asd\"), (failwith \"asd\"))\n      else failwith \"asd\"), b);;\n", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (failwith \"Asd\", failwith \"asd\")) else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (f b, false)) else failwith \"asd\") ,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b''\n-> (f b, false)) \nelse (fun b'' -> (f b, true)) ,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b'' -> (f b, false)) \nelse (fun b'' -> (f b, true))), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile ((fun b' -> if f b' = b' \nthen (f b, false)\nelse (f b, true)), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  wwhile ((fun b' -> if f b' = b' \n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((fun b'  -> if (f b') = b' then ((f b), false) else ((f b), true)), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nwwhile ((fun b' -> if f b' = b' \nthen (f b', false)\nelse (f b', true)), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi*\" ^ (exprToString e) ^ \")\"\n| Cosine e -> \"cos(pi*\" ^ (exprToString e) ^ \")\"\n| Average (a, b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a, b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a, b, c, d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi * eval (i, x, y))\n| Cosine i -> cos (pi * eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-77:\n  | Sine i -> sin (pi * eval (i, x, y))\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi * (eval (i, x, y)))\n  | Cosine i -> cos (pi * (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi * eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 116-118:\n  | Cosine i -> cos (pi * eval (i, x, y))\n                     ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi * (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 162-179:\n  | Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0);;\n                          ^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 161-201:\n  | Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0);;\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) <. (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 320-322:\n  if (eval (i1, x, y)) <. (eval (i2, x, y)) \n                       ^^\nError: Unbound value <.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) <. (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage (build (rand, depth - 1)) (build (rand, depth - 1))\n| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))\n| 6 -> VarX\n| 7 -> VarY"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 192-204:\n  | 3 -> buildAverage (build (rand, depth - 1)) (build (rand, depth - 1))\n         ^^^^^^^^^^^^\nError: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 -> buildAverage (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 4 -> buildTimes (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 5 ->\n      buildThresh (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n        (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))\n| 6 -> VarX\n| 7 -> VarY"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 267-277:\n  | 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n         ^^^^^^^^^^\nError: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 -> buildTimes (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 5 ->\n      buildThresh (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n        (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> VarX\n| 7 -> VarY"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 8) else (1, 6)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> VarX\n| 7 -> VarY"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 402-478:\n  | ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) - 1.0;;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        - 1.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (7, 9) else (1, 7)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> buildECosSin ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 7 -> VarX\n| 8 -> VarY"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| ECosSin  of expr * expr\n| SinLog   of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 513-514:\n  if c < 0\n         ^\nError: This expression has type int but an expression was expected of type\n         expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if c < 0\n      then ((log (x *. 100)) ** (sin (x *. 100))) -. 1.0\n      else (-1.0) *. (((log (x *. 100)) ** (sin (x *. 100))) -. 1.0);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a,b,c) ->\nif c < 0.0\nthen (log (x *. 100)) ** (sin (x *. 100)) -. 1.0\nelse -1.0 *. ((log (x *. 100)) ** (sin (x *. 100)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 513-516:\n  if c < 0.0\n         ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if c < 0.0\n      then ((log (x *. 100)) ** (sin (x *. 100))) -. 1.0\n      else (-1.0) *. (((log (x *. 100)) ** (sin (x *. 100))) -. 1.0);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a,b,c) ->\nif eval (c, x, y) < 0.0\nthen (log ((eval (a, x, y)) *. 100)) ** (sin ((eval (b, x, y)) *. 100)) -. 1.0\nelse -1.0 *. ((log ((eval (b, x, y)) *. 100)) ** (sin ((eval (a, x, y)) *. 100)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 561-564:\n  then (log ((eval (a, x, y)) *. 100)) ** (sin ((eval (b, x, y)) *. 100)) -. 1.0\n                                 ^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if (eval (c, x, y)) < 0.0\n      then\n        ((log ((eval (a, x, y)) *. 100)) ** (sin ((eval (b, x, y)) *. 100)))\n          -. 1.0\n      else\n        (-1.0) *.\n          (((log ((eval (b, x, y)) *. 100)) **\n              (sin ((eval (a, x, y)) *. 100)))\n             -. 1.0);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a,b,c) ->\nif eval (c, x, y) < 0.0\nthen (log ((eval (a, x, y)) *. 100.0)) ** (sin ((eval (b, x, y)) *. 100.0)) -. 1.0\nelse -1.0 *. ((log ((eval (b, x, y)) *. 100.0)) ** (sin ((eval (a, x, y)) *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (8, 10) else (1, 8)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> buildECosSin ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 7 -> buildSinLog ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 8 -> VarX\n| 9 -> VarY"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs (eval (a', x, y))\nin let b = abs (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 520-537:\n  let a = abs (eval (a', x, y))\n              ^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs (eval (a', x, y)) in\n      let b = abs (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin (b *. 100.0))) -. 1.0\n      else (-1.0) *. (((log (b *. 100.0)) ** (sin (a *. 100.0))) -. 1.0);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = absf (eval (a', x, y))\nin let b = abs (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-4:\n  fabs;;\n  ^^^^\nError: Unbound value fabs\nHint: Did you mean abs?\n", "min": "\nlet _ = fabs;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max 0.1 l' in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 618-621:\n  in let my_log = fun l' -> let l = (max 0.1 l') in (log l) / (log 10.0)\n                                     ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 633-640:\n  in let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)\n                                                    ^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = min 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 618-621:\n  in let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\n                                     ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let max' = fun a b -> if a > b then a else b\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 666-669:\n  in let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\n                                     ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let max' a b = if a > b then a else b in\n      let my_log l' = let l = max 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let max' = fun a b -> if a > b then a else b\nin let my_log = fun l' -> let l = (max' 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let max' = fun a b -> if a > b then a else b\nin let my_log = fun l' -> let l = (max' 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d, k, l) = match l with\n(ki, vi):: ls -> if k = ki\nthen vi\nelse assoc (d, k, ls)\n| _       -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0)\n| SinLog (a',b',c) -> 1.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> max -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 402-405:\n  | ECosSin (a,b) -> max -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n                     ^^^\nError: This expression has type int ref\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      max -\n        (1.0\n           (min 1.0\n              ((2.71 **\n                  (((sin (pi *. (eval (a, x, y)))) +.\n                      (cos (pi *. (eval (b, x, y)))))\n                     -. 1.0))\n                 -. 1.0)))\n  | SinLog (a',b',c) -> 1.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 402-405:\n  | ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n                     ^^^\nError: This expression has type int ref\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      max 1.0\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 450-454:\n  in max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n     ^^^^\nError: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' -\n        (1.0\n           (min 1.0\n              ((2.71 **\n                  (((sin (pi *. (eval (a, x, y)))) +.\n                      (cos (pi *. (eval (b, x, y)))))\n                     -. 1.0))\n                 -. 1.0)))\n  | SinLog (a',b',c) -> 1.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0-1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 456-459:\n  in max' (0.0-1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n           ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 - 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nmax' (0.0 -. 1.0) (min 1.0 (\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> Printf.sprintf \"sin(pi*%s)\" (exprToString e)\n| Cosine e -> \"cos(pi*\" ^ (exprToString e) ^ \")\"\n| Average (a, b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a, b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a, b, c, d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| ECosSin (a, b) -> \"ecossin(\" ^ (exprToString a) ^ \",\" ^ (exprToString b) ^ \")\"\n| SinLog (a, b, c) -> \"sinlog(\" ^ (exprToString a) ^ \",\" ^ (exprToString b) ^ \",\" ^ (exprToString c) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> Printf.sprintf \"sin(pi*%s)\" (exprToString e)\n| Cosine e -> Printf.sprintf \"cos(pi*%s)\" (exprToString e)\n| Average (a, b) -> Printf.sprintf \"((%s+%s)/2)\" (exprToString a) (exprToString b)\n| Times (a, b) -> Printf.sprintf \"%s*%s\" (exprToString a) (exprToString b)\n| Thresh (a, b, c, d) -> Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString a) (exprToString b) (exprToString c) (exprToString d)\n| ECosSin (a, b) -> Printf.sprintf \"ecossin(%s,%s)\" (exprToString a) (exprToString b)\n| SinLog (a, b, c) -> Printf.sprintf \"sinlog(%s,%s,%s)\" (exprToString a) (exprToString b) (exprToString c)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-20:\n  let _ = exprToString sampleExpr1;;\n          ^^^^^^^^^^^^\nError: Unbound value exprToString\n", "min": "\nlet _ = exprToString sampleExpr1;;\n", "in": "let buildX()                       = VarX"}, {"type": "scope", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY"}, {"type": "scope", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n", "min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)"}, {"type": "scope", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n", "min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n", "min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}, {"type": "scope", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)"}, {"type": "scope", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildECosSin(a,b)\t\t   = ECosSin(a,b)"}, {"type": "scope", "out": "Characters 28-35:\n  let buildECosSin(a,b)\t\t   = ECosSin(a,b);;\n                              ^^^^^^^\nError: Unbound constructor ECosSin\n", "min": "\nlet buildECosSin (a,b) = ECosSin (a, b);;\n", "in": "let buildSinLog(a,b,c)\t\t   = SinLog(a,b,c)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> \nlet a = abs_float (eval (a', x, y))\nin let max' = fun a b -> if a < b then b else a\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = max' 0.1 l' in (log l) /. (log 10.0)\nin\nmax' (0.0 -. 1.0) (min 1.0 (\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)))"}]}
