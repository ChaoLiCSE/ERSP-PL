{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\ny\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then y else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "(removeDuplicates [1,6,2,4,12,2,13,6,9])", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [(1, 6, 2, 4, 12, 2, 13, 6, 9)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem seen h) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "Characters 144-145:\n  h::seen\n  ^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "removeDuplicates [1,6,2,4,12,2,13,6,9]", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [(1, 6, 2, 4, 12, 2, 13, 6, 9)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "removeDuplicates [1,6,2,13,2,6,9]", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [(1, 6, 2, 13, 2, 6, 9)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev helper ([],l)", "out": "Characters 197-205:\n  List.rev helper ([],l);;\n  ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev helper ([], l);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "removeDuplicates [1,6,2,13,2,6,9]", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [(1, 6, 2, 13, 2, 6, 9)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nseen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "removeDuplicates [1,6,2,13,2,6,9]", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [(1, 6, 2, 13, 2, 6, 9)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\n[5]\nelse\n[6]\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [5] else [6] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile f a", "out": "Characters 74-75:\n  wwhile f a;;\n         ^\nError: This expression has type 'a -> ('b -> 'c) * bool\n       but an expression was expected of type ('a -> ('b -> 'c) * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile f a;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g y x=y b in\ng y b\n,b)", "out": "Characters 48-49:\n  g y b\n    ^\nError: Unbound value y\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g y x = y b in ((g y b), b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g y x=y b in\ng f b\n,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g y x = y b in ((g f b), b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "out": "Characters 115-120:\n  g f b\n  ^^^^^\nError: This expression has type ('a -> 'a) -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g y x =\n       let sec s fi m = if s = fi then (s, (s = (m s))) else (s, false) in\n       sec (y x) x in\n     ((g f b), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g y x= y x\n\nin\ng f b\n\n,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g y x = y x in ((g f b), b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "out": "Characters 115-120:\n  g f b\n  ^^^^^\nError: This expression has type ('a -> 'a) -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g y x =\n       let sec s fi m = if s = fi then (s, (s = (m s))) else (s, false) in\n       sec (y x) x in\n     ((g f b), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g y x=\n((y x),false)\nin\ng f b\n\n,b)", "out": "Characters 57-62:\n  g f b\n  ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g y x = ((y x), false) in ((g f b), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x=\n(x,false)\nin\ng f b\n\n,b)", "out": "Characters 51-52:\n  g f b\n  ^\nError: This function has type 'a -> 'a * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = (x, false) in ((g f b), b));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x=\n(x,false)\nin\ng (f b)\n\n,b)", "out": "Characters 51-58:\n  g (f b)\n  ^^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = (x, false) in ((g (f b)), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x=\nx,false\nin\ng (f b)\n\n,b)", "out": "Characters 49-56:\n  g (f b)\n  ^^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = (x, false) in ((g (f b)), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x=\nx\nin\ng (f b)\n\n,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = x in ((g (f b)), b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x=x\n\nin\n(g (f b),false)\n\n,b)", "out": "Characters 43-58:\n  (g (f b),false)\n  ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = x in (((g (f b)), false), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x=x\n\nin\n((g (f b)),false)\n\n,b)", "out": "Characters 43-60:\n  ((g (f b)),false)\n  ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = x in (((g (f b)), false), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f\n\n,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x y= ((x y),false)\nin g (f) b\n,b)", "out": "Characters 57-64:\n  in g (f) b\n     ^^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x y = ((x y), false) in ((g f b), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x y= ((y x),false)\nin g b f\n,b)", "out": "Characters 57-62:\n  in g b f\n     ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x y = ((y x), false) in ((g b f), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (g b f\n,b)", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile (g b f\n                               ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet g x y = ((y x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (g b f\n,b)", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile (g b f\n                               ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet g x y = ((y (y x)), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (b\n,b)", "out": "Characters 32-33:\n  ,b);;\n   ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((b,false)\n,b)", "out": "Characters 29-38:\n  let fixpoint (f,b) = wwhile ((b,false)\n                               ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((b, false), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g z=(z,false)\nin g b\n,b)", "out": "Characters 50-53:\n  in g b\n     ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g z = (z, false) in ((g b), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f\n,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (g b f\n,b)", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile (g b f\n                               ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (h  g (f) b\n,b)", "out": "Characters 29-39:\n  let fixpoint (f,b) = wwhile (h  g (f) b\n                               ^^^^^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet h q x y = q x y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h g f b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (h b f,b)", "out": "", "min": "\nlet h x b = b x;;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x y = ((y x),false) in\nh b f\n,b)", "out": "Characters 58-63:\n  h b f\n  ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x y = ((y x), false) in ((h b f), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x y = ((y x),x=x) in\nh b f\n,b)", "out": "Characters 56-61:\n  h b f\n  ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x y = ((y x), (x = x)) in ((h b f), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x y = ((y x),x<100) in\nh b f\n,b)", "out": "Characters 58-63:\n  h b f\n  ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x y = ((y x), (x < 100)) in ((h b f), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (h b f\n,b)", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile (h b f\n                               ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet h x y = ((y x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((h b f)\n,b)", "out": "Characters 29-36:\n  let fixpoint (f,b) = wwhile ((h b f)\n                               ^^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet h x y = ((y x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (h b f,b)", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile (h b f,b);;\n                               ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet h x b = ((b x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (h b f,b)", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile (h b f,b);;\n                               ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet h x b = ((b x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (h b f,b)", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile (h b f,b);;\n                               ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet h x b = ((b x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (h,b)", "out": "", "min": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h= f\nin h,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h = f in (h, b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h= f\nin (h,false),b)", "out": "Characters 41-50:\n  in (h,false),b);;\n     ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h = f in ((h, false), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h = f\nin (h,false),b)", "out": "Characters 42-51:\n  in (h,false),b);;\n     ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h = f in ((h, false), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h a= f\nin h a,b)", "out": "Characters 45-46:\n  in h a,b);;\n       ^\nError: Unbound value a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h a = f in ((h a), b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h a= f\nin h b,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h a = f in ((h b), b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h a= f a\nin h b,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h a = f a in ((h b), b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let h a= f a\nin h b),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((let h a = f a in h b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let h a= (f a,false)\nin h b),b)", "out": "Characters 54-57:\n  in h b),b);;\n     ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((let h a = ((f a), false) in h b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x= (f x,false) in\nh,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x = ((f x), false) in (h, b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in\nh,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x = ((f x), ((f x) = x)) in (h, b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (g,0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = f x in\n       let second = f first in\n       let third = f second in\n       (second,\n         (not ((first = second) && ((second = third) && (third = first))))) in\n     (h, b));;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "-\nfixpoint (collatz, 3)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = f x in\n       let second = f first in\n       let third = f second in\n       (second,\n         (not ((first = second) && ((second = third) && (third = first))))) in\n     (h, b));;\n\nlet _ = - (fixpoint (collatz, 3));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (collatz, 1)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = f x in\n       let second = f first in\n       let third = f second in\n       (second,\n         (not ((first = second) && ((second = third) && (third = first))))) in\n     (h, b));;\n\nlet _ = fixpoint (collatz, 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (collatz, 3)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = f x in\n       let second = f first in\n       let third = f second in\n       (second,\n         (not ((first = second) && ((second = third) && (third = first))))) in\n     (h, b));;\n\nlet _ = fixpoint (collatz, 3);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x= let first =x in\nlet second =f first in \nlet third = f second \nin  (second,not ((first=second)\n&&(third=first)))\nin\nh,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = x in\n       let second = f first in\n       let third = f second in\n       (second, (not ((first = second) && (third = first)))) in\n     (h, b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (g,0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = x in\n       let second = f first in\n       let third = f second in\n       (second, (not ((first = second) && (third = first)))) in\n     (h, b));;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (collatz, 1)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = x in\n       let second = f first in\n       let third = f second in\n       (second, (not ((first = second) && (third = first)))) in\n     (h, b));;\n\nlet _ = fixpoint (collatz, 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval expr x y))\n| Cosine expr-> cos(pi*.(eval expr x y))\n| Average (expr,expr1)->((eval expr x y) +. (eval expr1 x y))/.2\n| Times   (expr,expr1)->((eval expr x y)*. (eval expr1 x y))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval expr x y)<(eval expr1 x y)\nthen\neval expr2 x y\nelse\neval expr3 x y", "out": "Characters 87-91:\n  | Sine  expr -> sin(pi*.(eval expr x y))\n                                ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval expr x y))\n  | Cosine expr -> cos (pi *. (eval expr x y))\n  | Average (expr,expr1) -> ((eval expr x y) +. (eval expr1 x y)) /. 2\n  | Times (expr,expr1) -> (eval expr x y) *. (eval expr1 x y)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval expr x y) < (eval expr1 x y)\n      then eval expr2 x y\n      else eval expr3 x y;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "Characters 218-219:\n  | Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2\n                                                                         ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> (eval (expr, x, y)) +. (eval (expr1, x, y))\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "Characters 219-220:\n  | Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2\n                                                                          ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "Characters 171-216:\n  | Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/2\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> ((eval (expr, x, y)) +. (eval (expr1, x, y))) / 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (collatz, 1)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = x in\n       let second = f first in\n       let third = f second in\n       (second, (not ((first = second) && (third = first)))) in\n     (h, b));;\n\nlet _ = fixpoint (collatz, 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n| Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand),nd)", "out": "Characters 372-388:\n  |4->buildCosine(build(rand),nd);;\n                 ^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 4) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine ((build rand), nd));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 4) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|_->buildX()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 4) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | _ -> buildX ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Nom      of expr * expr * expr \n| Squa     of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\n\"abs(\"^res^\")/(abs\"^res^\"+\"^res^\"^2)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs\" ^ (res ^ (\"+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs\" ^ (res ^ (\"+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs\" ^ (res ^ (\"+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs\" ^ (res ^ (\"+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\n\"abs(\"^res^\")/(abs(\"^res^\")+\"^res^\"^2)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs(\" ^ (res ^ (\")+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs(\" ^ (res ^ (\")+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs(\" ^ (res ^ (\")+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\nres^\"/(abs(\"^res^\")+\"1\")\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)", "out": "Characters 568-572:\n  res^\"/(abs(\"^res^\")+\"1\")\"\n                   ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ (\")+\" 1 \")\")))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n", "type": "type"}, {"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs(\" ^ (res ^ (\")+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\nres^\"/(abs(\"^res^\")+1)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Nom      of expr * expr * expr \n| Squa     of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 18) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\nres^\"/(abs(\"^res^\")+1)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr2 = Squa (Nom (VarX, VarY, VarX));;\n\nlet _ = exprToString sampleExpr2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let_=eval (Sine(Average(VarX,VarY)),0.3,0.3)", "out": "Characters 0-4:\n  let_=eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n  ^^^^\nError: Unbound value let_\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet _ = let_ = (eval ((Sine (Average (VarX, VarY))), 0.3, 0.3));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=(rand(0,69) mod 7) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "removeDuplicates [1;6;2;4;12;2;13;6;9;99;99;-99;0]", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9; 99; 99; (-99); 0];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x= let first =x in\nlet second =f first\nin  (second,not ((first=second)))\nin\nh,b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (let h x= let first =x in\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = x in\n       let second = f first in (second, (not (first = second))) in\n     (h, b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (g,0)", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x= let first =x in\nlet second =f first \nin  (second,not ((first=second)))\nin\nh,b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (let h x= let first =x in\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = x in\n       let second = f first in (second, (not (first = second))) in\n     (h, b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (g,0)", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (collatz, 1)", "out": "Characters 0-8:\n  fixpoint (collatz, 1);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "type": "scope"}, {"in": "fixpoint (collatz, 3)", "out": "Characters 0-8:\n  fixpoint (collatz, 3);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "type": "scope"}, {"in": "fixpoint (collatz, 48)", "out": "Characters 0-8:\n  fixpoint (collatz, 48);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n", "type": "scope"}, {"in": "fixpoint (collatz, 107)", "out": "Characters 0-8:\n  fixpoint (collatz, 107);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "type": "scope"}, {"in": "fixpoint (collatz, 9001)", "out": "Characters 0-8:\n  fixpoint (collatz, 9001);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let h x= let first =x in\nlet second =f first \nin  (second,not ((first=second)))\nin\nh,b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (let h x= let first =x in\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    (let h x =\n       let first = x in\n       let second = f first in (second, (not (first = second))) in\n     (h, b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (g,0)", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (collatz, 1)", "out": "Characters 0-8:\n  fixpoint (collatz, 1);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "type": "scope"}, {"in": "fixpoint (collatz, 3)", "out": "Characters 0-8:\n  fixpoint (collatz, 3);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "type": "scope"}, {"in": "fixpoint (collatz, 48)", "out": "Characters 0-8:\n  fixpoint (collatz, 48);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n", "type": "scope"}, {"in": "fixpoint (collatz, 107)", "out": "Characters 0-8:\n  fixpoint (collatz, 107);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "type": "scope"}, {"in": "fixpoint (collatz, 9001)", "out": "Characters 0-8:\n  fixpoint (collatz, 9001);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Nom      of expr * expr * expr \n| Squa     of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\nres^\"/(abs(\"^res^\")+1)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr2 = Nom (VarX, (Cosine VarY), (Sine VarX));;\n\nlet _ = exprToString sampleExpr2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr2 = Nom (VarX, (Cosine VarY), (Sine VarX));;\n\nlet _ = exprToString sampleExpr2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr2 = Nom (VarX, (Cosine VarY), (Sine VarX));;\n\nlet _ = exprToString sampleExpr2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,7) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 7) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 7) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 7) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,6) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,6) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,8) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 8) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,8) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 8) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,6) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "buildNom(e,e1,e2)", "out": "Characters 9-10:\n  buildNom(e,e1,e2);;\n           ^\nError: Unbound value e\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet _ = buildNom (e, e1, e2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildSqua(e)                   = Squa(e)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildSqua e = Squa e;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr2", "out": "", "min": "\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n\nlet _ = exprToString sampleExpr2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,6) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n(*|4->buildCosine(build(rand,nd))*)\n(*|5->buildSqua(build(rand,nd))*)\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,6) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n(*\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))*)\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,6) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n(*\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))*)\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\")+1)\"\n\n|Squa expr -> let res=exprToString expr in\nres^\"/(abs(\"^res^\")+1)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3)+.1.)\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3)+.1.)\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3)+.1.)\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,6) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,6) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 6) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=rand(0,10) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 10) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr2", "out": "", "min": "\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n\nlet _ = exprToString sampleExpr2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr2", "out": "", "min": "\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n\nlet _ = exprToString sampleExpr2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr1", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "exprToString sampleExpr2", "out": "", "min": "\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^\n                                (res2 ^ (\")+abs(\" ^ (res3 ^ \")+1)\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n\nlet _ = exprToString sampleExpr2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=(rand(0,69)mod 7) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let res=(rand(0,69)mod 7) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|5->buildSqua(build(rand,nd))\n|_->buildNom(build(rand,nd),build(rand,nd),build(rand,nd))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqua e = Squa e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = (rand (0, 69)) mod 7 in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd))\n       | 5 -> buildSqua (build (rand, nd))\n       | _ ->\n           buildNom\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (x,y,[]) -> x\n  | (x,y,(a,b)::t) -> if a = y then b else assoc (x, y, t);;\n", "type": ""}]}
