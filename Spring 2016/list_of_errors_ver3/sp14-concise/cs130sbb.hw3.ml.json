{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 42-55:\n  let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\";;\n                                            ^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" [List.map (f l)]) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 27-40:\n  let stringOfList f l = \"[\"^sepConcat \";\"^[List.map(f l)]^\"]\";;\n                             ^^^^^^^^^^^^^\nError: This expression has type string list -> string\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\") ^ ([List.map (f l)] ^ \"]\"));;\n", "in": "let stringOfList f l = \"[\"^sepConcat \";\"^[List.map(f l)]^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 42-55:\n  let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\";;\n                                            ^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" [List.map (f l)]) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 42-55:\n  let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\";;\n                                            ^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" [List.map (f l)]) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 27-36:\n  let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\";;\n                             ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 27-36:\n  let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\";;\n                             ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-40:\n  let stringOfList f l = \"[\"^sepConcat(\";\" List.map(f l))^\"]\";;\n                                       ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\";\" List.map (f l))) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\"^sepConcat(\";\" List.map(f l))^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n = 0 then []\nelse x::clone x(n-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse x::clone x(n-1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 7-12:\n  let y =clone List.hd l1 (List.length l1 - List.length l2)\n         ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet y = ((clone List.hd l1 ((List.length l1) - (List.length l2)) y), l2);;\n", "in": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 7-12:\n  let y =clone List.hd l1 (List.length l1 - List.length l2)\n         ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet y = ((clone List.hd l1 ((List.length l1) - (List.length l2)) y), l2);;\n", "in": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 7-12:\n  let y =clone List.hd l1 (List.length l1 - List.length l2)\n         ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet y = ((clone List.hd l1 ((List.length l1) - (List.length l2)) y), l2);;\n", "in": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 173-174:\n  (y, l2)\n   ^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (let y = clone l1 ((List.length l1) - (List.length l2)) in (y, l2))\n    else (let z = clone l2 ((List.length l2) - (List.length l1)) in (z, l1));;\n", "in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone l2 (List.length l2 - List.length l1) in\n(z, l1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 126-131:\n  then let y =clone List.hd l1 (List.length l1 - List.length l2) in\n              ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = clone List.hd l1 ((List.length l1) - (List.length l2)) in\n       (y, l2))\n    else\n      (let z = clone List.hd l2 ((List.length l2) - (List.length l1)) in\n       (z, l1));;\n", "in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 127-132:\n  then let y = clone List.hd l1 (List.length l1 - List.length l2) in\n               ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = clone List.hd l1 ((List.length l1) - (List.length l2)) in\n       (y, l2))\n    else\n      (let z = clone List.hd l2 ((List.length l2) - (List.length l1)) in\n       (z, l1));;\n", "in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone 0 (List.length l1 - List.length l2) @ l2 in\n(l1, y)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) @ l1 in\n(z,l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone 0 (List.length l1 - List.length l2) @ l2 in\n(l1, y)\nelse let z = clone 0 (List.length l2 - List.length l1) @ l1 in\n(z,l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = \nmatch l with \nx::xs ->\nmatch x with\n| 0 -> removeZero xs\n| _ -> xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-86:\n  | [] -> xs;;\n          ^^\nError: Unbound value xs\n", "min": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs | [] -> xs;;\n", "in": "let rec removeZero l = \nmatch l with \nx::xs -> if x = 0 then removeZero(xs)\n| [] -> xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = \nmatch l with \n| x::xs -> if x = 0 then removeZero(xs) else l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = \nmatch l with \n| x::xs -> if x = 0 then removeZero(xs) else l\n| [] -> []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 146-172:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"tba\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  failwith \"tba\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 251-259:\n  let args = List.combine(List.rev l1 List.rev l2) in\n                          ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1 List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 250-276:\n  let args = List.combine(List.rev l1, List.rev l2) in\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1), (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 248-249:\n  let args = 0@List.combine(List.rev l1)(List.rev l2) in\n             ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = 0 @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = 0@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 251-289:\n  let args = 0::List.combine(List.rev l1)(List.rev l2) in\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = 0 :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = 0::List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 252-290:\n  let args = [0]@List.combine(List.rev l1)(List.rev l2) in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 253-291:\n  let args = [0]@[List.combine(List.rev l1)(List.rev l2)] in\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ [List.combine (List.rev l1) (List.rev l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@[List.combine(List.rev l1)(List.rev l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 252-290:\n  let args = [0]@List.combine(List.rev l1)(List.rev l2) in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 289-294:\n  let args = List.combine(List.rev l1)(List.rev l2)::[(0,0)] in\n                                                      ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [List.combine (List.rev l1) (List.rev l2); (0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2)::[(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 291-296:\n  let args = (List.combine(List.rev l1)(List.rev l2))::[(0,0)] in\n                                                        ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [List.combine (List.rev l1) (List.rev l2); (0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = (List.combine(List.rev l1)(List.rev l2))::[(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = (List.combine(List.rev l1)(List.rev l2))@[(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| _ -> bigAdd l (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 91-101:\n  (numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in\n                       ^^^^^^^^^^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit * l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 91-106:\n  (numzero + 1, bigAdd(mulByDigit l1 x :: clone 0 numzero) result) in\n                       ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit l1 x) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit l1 x :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 91-106:\n  (numzero + 1, bigAdd(mulByDigit x l1 :: clone 0 numzero) result) in\n                       ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit x l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 91-108:\n  (numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\n                       ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value l1\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 135-137:\n  (numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\n                                     ^^\nError: Unbound value l1\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ =\n  let bigMul l1 l2 = match l2 with | x::xs -> xs in\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs in\nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value t\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 45-46:\n  | x::xs -> t in\n             ^\nError: Unbound value t\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ =\n  let bigMul l1 l2 = match l2 with | x::xs -> t in\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> t in\nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-107:\n  (numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\n                       ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 91-108:\n  (numzero + 1, (bigAdd((mulByDigit x l1) :: clone 0 numzero)) result) in\n                        ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          ((bigAdd ((mulByDigit x l1) :: (clone 0 numzero))) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) :: clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\""}]}
