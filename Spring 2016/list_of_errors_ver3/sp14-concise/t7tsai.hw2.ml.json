{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in\nlet rest' = rest in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (number,boolean) = f b in\nif boolean then wwhile(f,b+1)\nelse number"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (number,boolean) = f b in\nif boolean then wwhile(f,number)\nelse number"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 18-25:\n  let _ = fixpoint (collatz, 9001);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile (f b,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile (y b,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-30:\n  let fixpoint (f,b) = wwhile (y b,b);;\n                               ^\nError: Unbound value y\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((y b), b);;\n", "in": "let fixpoint (f,b) = wwhile (failwiaht \"to be written\",b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-38:\n  let fixpoint (f,b) = wwhile (failwiaht \"to be written\",b);;\n                               ^^^^^^^^^\nError: Unbound value failwiaht\nHint: Did you mean failwith?\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((failwiaht \"to be written\"), b);;\n", "in": "let fixpoint (f,b) = wwhile (failwith \"to be written\",b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString  s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"sine(pi*\" ^ exprToString d ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-73:\n  | Sine -> \"sine(pi*\" ^ exprToString d ^ \")\";;\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sine(pi*\" ^ ((exprToString d) ^ \")\");;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"sine(pi*\" ^ exprToString e ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-73:\n  | Sine -> \"sine(pi*\" ^ exprToString e ^ \")\";;\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sine(pi*\" ^ ((exprToString e) ^ \")\");;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" exprToString e4 ^ \")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 209-212:\n  | Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" exprToString e4 ^ \")/2)\";;\n                                                ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ ((\"+\" exprToString e4) ^ \")/2)\"));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"\n| Times (e5,e6) -> exprToString e5 ^ \"*\" ^ exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\" ^ exprToString e7 ^ \"<\" ^ exprToString e8 ^ \"?\" ^ exprToString e9 ^ \":\" ^ exprToString e10 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-80:\n  | Sine(e) -> sin(pi*eval(e,x,y))\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * (eval (e, x, y)))\n  | Cosine e -> cos (pi * (eval (e, x, y)));;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 151-181:\n  | Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2;;\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> float_of_int x\n| VarY -> float_of_int y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 178-190:\n  | Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/2;;\n                       ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> float_of_int x\n| VarY -> float_of_int y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 191-203:\n  | Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2;;\n                                    ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      (float_of_int ((eval (e1, x, y)) + (eval (e2, x, y)))) / 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 152-164:\n  | Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2;;\n                       ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 152-164:\n  | Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2;;\n                       ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 183-184:\n  | Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2;;\n                                                      ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 183-184:\n  | Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2;;\n                                                      ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2."}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e1,x,y)\nelse eval(e2,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (fun y b-> \nif f b = b then (b,true)\nelse y b,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-76:\n  ............................(fun y b-> \n  if f b = b then (b,true)\n  else y b,b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (fun y  -> fun b  -> if (f b) = b then (b, true) else ((y b), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y b -> (f b, true),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-54:\n  let fixpoint (f,b) = wwhile (fun y b -> (f b, true),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), true), b));;\n", "in": "let fixpoint (f,b) = wwhile ((fun y b -> (f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-53:\n  let fixpoint (f,b) = wwhile ((fun y b -> (f b, true)),b);;\n                               ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This function expects too many arguments, it should have type\n'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> fun b  -> ((f b), true)), b);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-58:\n  let fixpoint (f,b) = wwhile (fun y b ->  (f b, f b = b),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((f b, f b = b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-43:\n  let fixpoint (f,b) = wwhile ((f b, f b = b),b);;\n                               ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fun y = (f b, f b = b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-55:\n  let fixpoint (f,b) = wwhile (fun y -> (f b, f b = b),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-56:\n  let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-57:\n  let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y -> \nlet x = f b in\nif x = b then (x, true)\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-81:\n  ............................(fun y -> \n  let x = f b in\n  if x = b then (x, true)\n  ,b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (fun y  -> let x = f b in if x = b then ((x, true), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y b-> \nlet x = f b in\nif x = b then (x, true)\nelse y x \n,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-92:\n  ............................(fun y b-> \n  let x = f b in\n  if x = b then (x, true)\n  else y x \n  ,b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (fun y  ->\n       fun b  -> let x = f b in if x = b then (x, true) else ((y x), b));;\n", "in": "let fixpoint (f,b) = wwhile (let y x = \nlet z = f x in\nif z = b then (x, true)\nelse y z,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-92:\n  ............................(fun y x -> \n  let z = f x in\n  if z = b then (x, true)\n  else y z\n  ,b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (fun y  ->\n       fun x  -> let z = f x in if z = b then (x, true) else ((y z), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, x)\n,b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-88:\n  wwhile (f, 2),b);;\n  ^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 100)) in\n     ((wwhile (f, 2)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-88:\n  wwhile (f, 2),b);;\n  ^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 100)) in\n     ((wwhile (f, 2)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-58:\n  let fixpoint (f,b) = wwhile (fun y x-> (f x, f x != b), b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun x  -> (((f x), ((f x) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((fun y x-> (f x, f x != b)), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-56:\n  let fixpoint (f,b) = wwhile ((fun y x-> (f x, f x != b)), b);;\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This function expects too many arguments, it should have type\n'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> fun x  -> ((f x), ((f x) != b))), b);;\n", "in": "let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-57:\n  let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b), b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y -> ((f b), (f b) != b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-61:\n  let fixpoint (f,b) = wwhile (fun y -> ((f b), (f b) != b), b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-58:\n  let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b), b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let y b =\nlet xx = f b in\n(xx, xx != b), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y xx, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y x, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = rand (1,2);;\n          ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\nlet _ = rand (1, 2);;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\nmakeRand(1,2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n  ^^^^^^^^^^^\nError: This function has type expr * expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ()))) makeRand (1, 2);;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\n\n\nmakeRand(1,2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n  ^^^^^^^^^^^\nError: This function has type expr * expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ()))) makeRand (1, 2);;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}, {"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let x = rand(1,7);;\n          ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\nlet x = rand (1, 7);;\n", "in": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet x = rand"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value buildAverge\nHint: Did you mean buildAverage?\nError: Unbound value buildAverge\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 227-238:\n  else buildAverge(build(rand,depth-1),build(rand,depth-1));;\n       ^^^^^^^^^^^\nError: Unbound value buildAverge\nHint: Did you mean buildAverage?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let x = rand (1, 7) in\n  match x with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      if depth = 0\n      then build (rand, depth)\n      else buildSine (build (rand, (depth - 1)))\n  | 4 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAverge\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = \nlet x = rand(1,7) in \nmatch x with \n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr * expr\n| AddThree of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 572-575:\n  | AddThree (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" exprToString e3 ^ \")\";;\n                                                                           ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"**\" ^ ((exprToString e2) ^ \")\")))\n  | AddThree (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ ((\"+\" exprToString e3) ^ \")\"))));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"\n| Times (e5,e6) -> exprToString e5 ^ \"*\" ^ exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\" ^ exprToString e7 ^ \"<\" ^ exprToString e8 ^ \"?\" ^ exprToString e9 ^ \":\" ^ exprToString e10 ^ \")\"\n| Power (e1,e2) -> \"(\" ^ exprToString e1 ^ \"**\" ^ exprToString e2 ^ \")\"\n| AddThree (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString s"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 358-361:\n  | Power(e1,e2) -> eval(e1,x,y) **. eval(e2,x,y);;\n                                 ^^^\nError: Unbound value **.\nHint: Did you mean *. or **?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) **. (eval (e2, x, y));;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildPower(e1,e2)              = Power(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let s = Averge(VarX,VarY);;\n          ^^^^^^\nError: Unbound constructor Averge\n", "min": "\nlet s = Averge (VarX, VarY);;\n", "in": "exprToString s"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-15:\n  let s = Average(VarX,VarY);;\n          ^^^^^^^\nError: Unbound constructor Average\n", "min": "\nlet s = Average (VarX, VarY);;\n", "in": "exprToString s"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-20:\n  let _ = exprToString sampleExpr1;;\n          ^^^^^^^^^^^^\nError: Unbound value exprToString\n", "min": "\nlet _ = exprToString sampleExpr1;;\n", "in": "let buildX()                       = VarX"}, {"type": "scope", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY"}, {"type": "scope", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n", "min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)"}, {"type": "scope", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n", "min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n", "min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}, {"type": "scope", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)"}, {"type": "scope", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildPower(e1,e2)              = Power(e1,e2)"}, {"type": "scope", "out": "Characters 37-42:\n  let buildPower(e1,e2)              = Power(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Power\n", "min": "\nlet buildPower (e1,e2) = Power (e1, e2);;\n", "in": "let buildAddThree(e1,e2,e3)        = AddThree(e1,e2,e3)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> ((eval(e1,x,y) +. eval(e2,x,y)) /. 2.)\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = eval (AddThree(VarX,VarY,VarX),2.,5.);;\n          ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval ((AddThree (VarX, VarY, VarX)), 2., 5.);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "scope", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}, {"type": "scope", "out": "Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}, {"type": "scope", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "in": "let rec build (rand, depth) = \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 74-80:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n", "min": "\nlet rec build (rand,depth) =\n  let x = rand (0, 7) in\n  match x with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 ->\n      if depth = 0\n      then build (rand, depth)\n      else buildSine (build (rand, (depth - 1)))\n  | 3 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildPower ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAddThree\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"}, {"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,5) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
