{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif xs::1 = 1 then 0", "out": "Characters 29-30:\n  if xs::1 = 1 then 0;;\n         ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec sumList xs = if (xs :: 1) = 1 then 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif xs::1 = 1 then 0", "out": "Characters 29-30:\n  if xs::1 = 1 then 0;;\n         ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec sumList xs = if (xs :: 1) = 1 then 0;;\n", "type": "type"}, {"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif length xs = 0 then 0", "out": "Characters 44-45:\n  if length xs = 0 then 0;;\n                        ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec length = function | [] -> 0 | _::l -> 1 + (length l);;\n\nlet rec sumList xs = if (length xs) = 0 then 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif length xs = 0 then xs = 0", "out": "Characters 49-50:\n  if length xs = 0 then xs = 0;;\n                             ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec length = function | [] -> 0 | _::l -> 1 + (length l);;\n\nlet rec sumList xs = if (length xs) = 0 then xs = 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match list with\n| [] -> 0\n| head::tail -> head + sumList tail", "out": "Characters 27-31:\n  let rec sumList xs = match list with\n                             ^^^^\nError: Unbound value list\n", "min": "\nlet rec sumList xs =\n  match list with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| [] -> 0\n| head::tail -> head + sumList tail", "out": "Characters 42-44:\n  | [] -> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| [ ] -> 0\n| head::tail -> head + sumList tail", "out": "Characters 42-45:\n  | [ ] -> 0\n    ^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| [ ] -> 0\n| head::tail -> head + sumList tail", "out": "Characters 42-45:\n  | [ ] -> 0\n    ^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| [] -> 0\n| head::tail -> head + sumList tail", "out": "Characters 42-44:\n  | [] -> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| [] -> 0\n| head::tail -> head + sumList tail", "out": "Characters 42-44:\n  | [] -> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| head::tail -> head + sumList tail", "out": "Characters 42-52:\n  | head::tail -> head + sumList tail;;\n    ^^^^^^^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs = match sumList with | head::tail -> head + (sumList tail);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| head::tail -> head + sumList tail", "out": "Characters 42-52:\n  | head::tail -> head + sumList tail;;\n    ^^^^^^^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs = match sumList with | head::tail -> head + (sumList tail);;\n", "type": "other"}, {"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = sum xs", "out": "", "min": "\nlet rec sum list = match list with | [] -> 0 | head::tail -> head;;\n\nlet rec sumList xs = sum xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = sum xs", "out": "", "min": "\nlet rec sum list = match list with | [] -> 0 | head::tail -> head;;\n\nlet rec sumList xs = sum xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = h::t", "out": "Characters 21-22:\n  let rec sumList xs = h::t;;\n                       ^\nError: Unbound value h\n", "min": "\nlet rec sumList xs = h :: t;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match int with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "Characters 27-30:\n  let rec sumList xs = match int with\n                             ^^^\nError: Unbound value int\n", "min": "\nlet rec sumList xs = match int with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "Characters 42-44:\n  | [] -> 0 \n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n| h::t -> h + sumList t", "out": "Characters 42-46:\n  | h::t -> h + sumList t;;\n    ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs = match sumList with | h::t -> h + (sumList t);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n[] -> 0 \n| h::t -> h + sumList t", "out": "Characters 40-42:\n  [] -> 0 \n  ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match sumList with\n[] -> 0 \n| h::t -> h + sumList t", "out": "Characters 40-42:\n  [] -> 0 \n  ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "min": "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n[] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = failwith \"TBD\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []", "out": "Characters 39-41:\n  if n < 0 then [];;\n                ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []", "out": "Characters 38-40:\n  if n < 0 then [];;\n                ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \ndigits n", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = digits n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \ndigits n", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = digits n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet digits n = x in\nsumList x", "out": "Characters 44-45:\n  let digits n = x in\n                 ^\nError: Unbound value x\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = let digits n = x in sumList x;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \ndigits n\nsumList n", "out": "Characters 29-35:\n  digits n\n  ^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = digits n sumList n;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \ndigits n", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = digits n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \ndigits n = n", "out": "Characters 40-41:\n  digits n = n;;\n             ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = (digits n) = n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nsumList (digits n)", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = sumList (digits n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nif sumList (digits n) > 9 then 0", "out": "Characters 60-61:\n  if sumList (digits n) > 9 then 0;;\n                                 ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = if (sumList (digits n)) > 9 then 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nif sumList (digits n) > 9\nthen additivePersistence (sumList (digits n))", "out": "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 60-100:\n  then additivePersistence (sumList (digits n));;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet additivePersistence n = sumList (digits n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  if (sumList (digits n)) > 9 then additivePersistence (sumList (digits n));;\n", "type": "scope"}, {"in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = failwith \"TBD\"", "out": "", "min": "\nlet additivePersistence n = failwith \"TBD\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "out": "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-108:\n  else sumList (digits n);;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList digits n", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-97:\n  else sumList digits n;;\n       ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList digits n;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits (n))", "out": "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-110:\n  else sumList (digits (n));;\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "out": "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-108:\n  else sumList (digits n);;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "type": "scope"}, {"in": "let listReverse l = failwith \"TBD\"", "out": "", "min": "\nlet listReverse l = failwith \"TBD\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x", "out": "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 92-93:\n  else sumList x;;\n               ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x", "out": "Characters 96-97:\n  else sumList x;;\n               ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] list", "out": "Characters 95-99:\n  aux [] list;;\n         ^^^^\nError: Unbound value list\n", "min": "\nlet listReverse l =\n  let rec aux acc = function | [] -> acc | h::t -> aux (h :: acc) t in\n  aux [] list;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "out": "", "min": "\nlet listReverse l =\n  let rec aux acc = function | [] -> acc | h::t -> aux (h :: acc) t in\n  aux [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif listReverse (explode w) = explode w\nthen true\nelse false", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec aux acc = function | [] -> acc | h::t -> aux (h :: acc) t in\n  aux [] l;;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper n = function\n| [] -> n\n| hd::tl -> helper (hd::n) tl in\nhelper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper n = function | [] -> n | hd::tl -> helper (hd :: n) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper n = function\n| [] -> n\n| hd::tl -> helper (hd::n) tl in\nhelper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper n = function | [] -> n | hd::tl -> helper (hd :: n) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec helper n count = \ndigitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0", "out": "Error: This expression has type bool but an expression was expected of type\n         int\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 55-150:\n  digitalRoot n =\n  if sumList (digits n) > 9\n  then helper (sumList (digits n)) (count+1)\n  else count\nError: This expression has type bool but an expression was expected of type\n         int\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let rec helper n count =\n    (digitalRoot n) =\n      (if (sumList (digits n)) > 9\n       then helper (sumList (digits n)) (count + 1)\n       else count) in\n  helper n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let rec helper n count =\n    let rec digitalRoot n =\n      if (sumList (digits n)) > 9\n      then helper (sumList (digits n)) (count + 1)\n      else count in\n    digitalRoot n in\n  helper n 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 1", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let rec helper n count =\n    let rec digitalRoot n =\n      if (sumList (digits n)) > 9\n      then helper (sumList (digits n)) (count + 1)\n      else count in\n    digitalRoot n in\n  helper n 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 1", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let rec helper n count =\n    let rec digitalRoot n =\n      if (sumList (digits n)) > 9\n      then helper (sumList (digits n)) (count + 1)\n      else count in\n    digitalRoot n in\n  helper n 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = match xs with\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "out": "Characters 78-84:\n  | hd::tl -> helper (hd::xs) tl\n              ^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet listReverse l =\n  let rec helper xs =\n    match xs with | [] -> [] | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> [] | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> [] | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) \nin helper [] l", "out": "Characters 73-88:\n  | hd::tl -> helper (hd::xs) \n              ^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper []", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper []", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs n  = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "out": "Characters 76-94:\n  | hd::tl -> helper (hd::xs) tl\n              ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n", "min": "\nlet listReverse l =\n  let rec helper xs n = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs l  = match n with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "out": "Characters 50-51:\n  let rec helper xs l  = match n with\n                               ^\nError: Unbound value n\n", "min": "\nlet listReverse l =\n  let rec helper xs l =\n    match n with | [] -> [] | hd::tl -> helper (hd :: xs) l in\n  helper [] l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs l  = match l with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs l =\n    match l with | [] -> [] | hd::tl -> helper (hd :: xs) l in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs l  = match l with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs l =\n    match l with | [] -> [] | hd::tl -> helper (hd :: xs) l in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper xs list  = match list with\n| [] -> []\n| hd::tl -> helper (hd::xs) list\nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper xs list =\n    match list with | [] -> [] | hd::tl -> helper (hd :: xs) list in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = reverse [] list", "out": "Characters 20-27:\n  let listReverse l = reverse [] list;;\n                      ^^^^^^^\nError: Unbound value reverse\n", "min": "\nlet listReverse l = reverse [] list;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = reverse [] list", "out": "Characters 20-27:\n  let listReverse l = reverse [] list;;\n                      ^^^^^^^\nError: Unbound value reverse\n", "min": "\nlet listReverse l = reverse [] list;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = reverse [] list", "out": "Characters 31-35:\n  let listReverse l = reverse [] list;;\n                                 ^^^^\nError: Unbound value list\n", "min": "\nlet rec reverse res list =\n  match list with | [] -> [] | hd::tl -> reverse (hd :: res) list;;\n\nlet listReverse l = reverse [] list;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = reverse [] l", "out": "", "min": "\nlet rec reverse res list =\n  match list with | [] -> [] | hd::tl -> reverse (hd :: res) list;;\n\nlet listReverse l = reverse [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = reverse [] l", "out": "", "min": "\nlet rec reverse res list =\n  match list with | [] -> res | hd::tl -> reverse (hd :: res) list;;\n\nlet listReverse l = reverse [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper n = function\n| [] -> n\n| hd::tl -> helper (hd::n) tl \nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper n = function | [] -> n | hd::tl -> helper (hd :: n) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits n x list =\nif n < 10 then n :: list\nelse digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\nin digits n (mylength n) []", "out": "Characters 111-112:\n  else digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\n                                          ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec mylength xs = match xs with | [] -> 0 | hd::tl -> 1 + (mylength tl);;\n\nlet digitsOfInt n =\n  let rec digits n x list =\n    if n < 10\n    then n :: list\n    else\n      digits ((n / 10) + (n mod 10)) (((mylength n) / 10) + (n mod 10)) list in\n  digits n (mylength n) [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits n x list =\nif n < 10 then n :: list\nelse digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\nin digits n (mylength n) []", "out": "Characters 111-112:\n  else digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\n                                          ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec mylength xs = match xs with | [] -> 0 | hd::tl -> 1 + (mylength tl);;\n\nlet digitsOfInt n =\n  let rec digits n x list =\n    if n < 10\n    then n :: list\n    else\n      digits ((n / 10) + (n mod 10)) (((mylength n) / 10) + (n mod 10)) list in\n  digits n (mylength n) [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(10** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "out": "Characters 95-97:\n  then x/(10** numdig -1) mod 10 :: l\n          ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((10 ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(int_of_float 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "out": "Characters 108-110:\n  then x/(int_of_float 10 ** numdig -1) mod 10 :: l\n                       ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((int_of_float 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "out": "Characters 114-120:\n  then x/(float_of_int 10 ** numdig -1) mod 10 :: l\n                             ^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((float_of_int 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []", "out": "Characters 94-139:\n  then x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((float_of_int 10) ** (float_of_int (numdig - 1)))) mod 10) ::\n      l\n    else numdig :: 1 in\n  digits n [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []", "out": "Characters 179-180:\n  else numdig :: 1\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: l\n    else numdig :: 1 in\n  digits n [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: l\nin digits n []", "out": "", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: l\n    else numdig :: l in\n  digits n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits x/10 l)\nelse numdig :: l\nin digits n []", "out": "Characters 164-172:\n  (digits x/10 l)\n   ^^^^^^^^\nError: This expression has type 'a -> int list\n       but an expression was expected of type int\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: ((digits x) / (10 l))\n    else numdig :: l in\n  digits n [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) l)\nelse numdig :: l\nin digits n []", "out": "", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: (digits (x / 10) l)\n    else numdig :: l in\n  digits n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen match l with\n| [] -> []\n| hd::tl -> \nx/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) tl)\nelse numdig :: l\nin digits n []", "out": "", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | [] -> []\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen match l with\n| hd::tl -> \nx/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) tl)\nelse numdig :: l\nin digits n []", "out": "", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "out": "Characters 49-62:\n  (digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10];;\n   ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [(digitsOfInt n) / 10;\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "out": "Characters 48-68:\n  (digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10];;\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [digitsOfInt (n / 10);\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "out": "Characters 120-126:\n  (digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10];;\n                                                                          ^^^^^^\nError: Unbound value numdig\n", "min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10]", "out": "Error: Unbound value x\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 134-135:\n  (digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10];;\n                                                                                        ^\nError: Unbound value x\n", "min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits x) - 1)))))\n         mod 10];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits n -1)) mod 10]", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int ((num_of_digits n) -1)) mod 10]", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n mod 10]", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n mod 10]", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 48-68:\n  (digitsOfInt (n/10)) :: [n mod 10];;\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n = if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse match n with\n| hd::tl -> hd\n(digitsOfInt (n/10)) :: [n mod 10]", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-69:\n  | hd::tl -> hd\n    ^^^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else (match n with | hd::tl -> [hd (digitsOfInt (n / 10)); n mod 10]);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n mod 10]", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 48-68:\n  (digitsOfInt (n/10)) :: [n mod 10];;\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n = if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) [n mod 10]\nin recurse n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec recurse x l =\n    if x < 10 then x :: l else recurse (x / 10) [n mod 10] in\n  recurse n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) [x mod 10]\nin recurse n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec recurse x l =\n    if x < 10 then x :: l else recurse (x / 10) [x mod 10] in\n  recurse n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec recurse x l =\n    if x < 10 then x :: l else recurse (x / 10) ((x mod 10) :: l) in\n  recurse n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec recurse x l =\n    if x < 10 then x :: l else recurse (x / 10) ((x mod 10) :: l) in\n  recurse n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec recurse x l =\n       if x < 10 then x :: l else recurse (x / 10) ((x mod 10) :: l) in\n     recurse n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec recurse x l =\n       if x < 10 then x :: l else recurse (x / 10) ((x mod 10) :: l) in\n     recurse n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper n = fun x-> match n with\n| [] -> n\n| hd::tl -> helper (hd::n) tl \nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper n x = match n with | [] -> n | hd::tl -> helper (hd :: n) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec helper n = fun x-> match n with\n| [] -> n\n| hd::tl -> helper (hd::n) tl \nin helper [] l", "out": "", "min": "\nlet listReverse l =\n  let rec helper n x = match n with | [] -> n | hd::tl -> helper (hd :: n) tl in\n  helper [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec recurse x l =\n       if x < 10 then x :: l else recurse (x / 10) ((x mod 10) :: l) in\n     recurse n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> []\n| hd::tl -> recurse tl hd::xs\nin recurse l []", "out": "Characters 80-93:\n  | hd::tl -> recurse tl hd::xs\n              ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet listReverse l =\n  let rec recurse x xs =\n    match x with | [] -> [] | hd::tl -> (recurse tl hd) :: xs in\n  recurse l [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> []\n| hd::tl -> recurse tl (hd::xs)\nin recurse l []", "out": "", "min": "\nlet listReverse l =\n  let rec recurse x xs =\n    match x with | [] -> [] | hd::tl -> recurse tl (hd :: xs) in\n  recurse l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> xs\n| hd::tl -> recurse tl (hd::xs)\nin recurse l []", "out": "", "min": "\nlet listReverse l =\n  let rec recurse x xs =\n    match x with | [] -> xs | hd::tl -> recurse tl (hd :: xs) in\n  recurse l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 1", "out": "", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec recurse x l =\n       if x < 10 then x :: l else recurse (x / 10) ((x mod 10) :: l) in\n     recurse n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let rec helper n count =\n    let rec digitalRoot n =\n      if (sumList (digits n)) > 9\n      then helper (sumList (digits n)) (count + 1)\n      else count in\n    digitalRoot n in\n  helper n 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
