{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun a -> a) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "out": "Characters 45-49:\n  let base = base in\n             ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs b = \nlet f a x = x(a) in\nlet base = b in\nList.fold_left f base fs", "min": "\nlet pipe fs b = let f a x = x a in let base = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 46-47:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs b = \nlet f a x = x(a) in\nlet base = b in\nList.fold_left f base fs", "min": "\nlet pipe fs b = let f a x = x a in let base = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 3 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = \"\" in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = \"\" in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 46-47:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x + x) in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in let base x = x + x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = int in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = int in List.fold_left f base fs;;\n", "out": "Characters 45-48:\n  let base = int in\n             ^^^\nError: Unbound value int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = function | a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in let base = function | a -> a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = int a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = int a in List.fold_left f base fs;;\n", "out": "Characters 45-48:\n  let base = int a in\n             ^^^\nError: Unbound value int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = fun x' ->\nlet f a x = x a in\nlet base = x' in\nList.fold_left f base fs", "min": "\nlet pipe fs x' = let f a x = x a in let base = x' in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = fun x' ->\nlet f a x = x a in\nlet base = x' in\nList.fold_left f base fs", "min": "\nlet pipe fs x' = let f a x = x a in let base = x' in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> [x] @ (clone x n-1)", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> [x] @ ((clone x n) - 1);;\n", "out": "Characters 70-79:\n  | true  -> [x] @ (clone x n-1);;\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: (clone (x n-1))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone ((x n) - 1));;\n", "out": "Characters 75-82:\n  | true  -> x :: (clone (x n-1));;\n                         ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x n-1", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: ((clone x n) - 1);;\n", "out": "Characters 68-77:\n  | true  -> x :: clone x n-1;;\n                  ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x (n-1)", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 -lendiff) @ l1, l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> ((((clone 0) - lendiff) @ l1), l2));;\n", "out": "Characters 219-226:\n  | false -> ((clone 0 -lendiff) @ l1, l2);;\n               ^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 (-lendiff)) @ l1, l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 (-lendiff)) @ l1, l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = \nmatch l with\n| []      -> []\n| 0 :: t  -> removeZero t\n| _       -> l", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 140-166:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nList.fold_left f base args\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 167-188:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 140-166:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 142-168:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) % 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) % 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 65-66:\n  let f a (x,y) = ((x + y) % 10) :: a in\n                           ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) mod 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) mod 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) % 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) % 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 65-66:\n  let f a (x,y) = ((x + y) % 10) :: a in\n                           ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.rev List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let res = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 107-115:\n  let args = List.rev List.combine l1 l2 in\n             ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.rev List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nList.rev removeZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  List.rev removeZero (add (padZero l1 l2));;\n", "out": "Characters 107-115:\n  let args = List.rev List.combine l1 l2 in\n             ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> ((x + y) / 10) :: a \n| h :: t -> ((x + y + h) / 10) :: a\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> ((x + y) / 10) :: a\n      | h::t -> (((x + y) + h) / 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h % 10] @ t\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h % 10] @ t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "out": "Characters 121-122:\n  | h :: t -> [x + y + h/10; h % 10] @ t\n                               ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZeros (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZeros (add (padZero l1 l2));;\n", "out": "Error: Unbound value removeZeros\nHint: Did you mean removeZero?\nError: Unbound value removeZeros\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 255-266:\n  removeZeros (add (padZero l1 l2));;\n  ^^^^^^^^^^^\nError: Unbound value removeZeros\nHint: Did you mean removeZero?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [x * y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nList.fold_left f base args", "min": "\nlet y f g x = f (g x);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(x * y) + (h / 10); h mod 10] @ t in\n  let base = [] in let args = List.rev (0 :: l) in List.fold_left f base args;;\n", "out": "Characters 91-92:\n  | h :: t -> [x * y + h/10; h mod 10] @ t\n                   ^\nError: This expression has type ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nList.fold_left f base args", "min": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in let args = List.rev (0 :: l) in List.fold_left f base args;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nremoveZero List.fold_left f base args", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero List.fold_left f base args;;\n", "out": "Characters 166-176:\n  removeZero List.fold_left f base args;;\n  ^^^^^^^^^^\nError: This function has type int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nremoveZero (List.fold_left f base args)", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 220-246:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []      -> (mulByDigit x l2) :: a\n| h :: t  -> [bigAdd (mulByDigit x l2) h/10; h mod 10] @ t \nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [(bigAdd (mulByDigit x l2) h) / 10; h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 96-122:\n  | h :: t  -> [bigAdd (mulByDigit x l2) h/10; h mod 10] @ t \n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []      -> (mulByDigit x l2) :: a\n| h :: t  -> [bigAdd (mulByDigit x l2) [h/10]; h mod 10] @ t \nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [bigAdd (mulByDigit x l2) [h / 10]; h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 122-123:\n  | h :: t  -> [bigAdd (mulByDigit x l2) [h/10]; h mod 10] @ t \n                                          ^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 170-196:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd List.rev(0 :: (List.rev a)) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd List.rev (0 :: (List.rev a)) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n", "out": "Characters 82-88:\n  | _   -> bigAdd List.rev(0 :: (List.rev a)) (mulByDigit x l2)\n           ^^^^^^\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (List.rev (0 :: (List.rev a))) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (List.rev (0 :: (List.rev a))) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev (0 :: l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (List.rev (0 :: (List.rev a))) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev (0 :: l1) in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = 0 :: List.rev (l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (List.rev (0 :: (List.rev a))) (mulByDigit x l2) in\n  let base = [] in\n  let args = 0 :: (List.rev l1) in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nremoveZero (List.fold_left f base args)", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev (l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (List.rev (0 :: (List.rev a))) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev (0 :: l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (List.rev (0 :: (List.rev a))) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev (0 :: l1) in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\n(List.fold_left f base args)", "min": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in let args = List.rev (0 :: l) in List.fold_left f base args;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nremoveZero (List.fold_left f base args)", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (List.rev(0 :: (List.rev (mulByDigit x l2))))\nin\nlet base = [] in\nlet args = List.rev (l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd a (List.rev (0 :: (List.rev (mulByDigit x l2)))) in\n  let base = [] in\n  let args = List.rev l1 in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (List.rev(0 :: (List.rev (mulByDigit x l2))))\nin\nlet base = [] in\nlet args = List.rev (l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd a (List.rev (0 :: (List.rev (mulByDigit x l2)))) in\n  let base = [] in\n  let args = List.rev l1 in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (List.rev(0 :: (List.rev (mulByDigit x l2))))\nin\nlet base = [] in\nlet args = (l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd a (List.rev (0 :: (List.rev (mulByDigit x l2)))) in\n  let base = [] in\n  let args = l1 in let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nremoveZero (List.fold_left f base args)", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let test = mulByDigit 1 [1;0]", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test = mulByDigit 1 [1; 0];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let test = mulByDigit 1 [1;0]\nList.rev test", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test = mulByDigit 1 [1; 0];;\n\nlet test = mulByDigit 1 [1; 0] List.rev test;;\n", "out": "Characters 11-21:\n  let test = mulByDigit 1 [1;0]\n             ^^^^^^^^^^\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let test = mulByDigit 1 [1;0]\nList.rev test", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test = mulByDigit 1 [1; 0];;\n\nlet test = mulByDigit 1 [1; 0] List.rev test;;\n", "out": "Characters 11-21:\n  let test = mulByDigit 1 [1;0]\n             ^^^^^^^^^^\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let test = mulByDigit 1 [1;0]", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test = mulByDigit 1 [1; 0];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let test3 = mulByDigit 0 [1;0]", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test3 = mulByDigit 0 [1; 0];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "bigAdd test3 test2", "min": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test = mulByDigit 1 [1; 0];;\n\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet test2 = List.rev (0 :: (List.rev test));;\n\nlet test3 = mulByDigit 0 [1; 0];;\n\nlet _ = bigAdd test3 test2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "removeZero(bigAdd test3 test2)", "min": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test = mulByDigit 1 [1; 0];;\n\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet test2 = List.rev (0 :: (List.rev test));;\n\nlet test3 = mulByDigit 0 [1; 0];;\n\nlet _ = removeZero (bigAdd test3 test2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (List.rev(0 :: (List.rev (mulByDigit x l2))))\nin\nlet base = [] in\nlet args = List.rev(l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd a (List.rev (0 :: (List.rev (mulByDigit x l2)))) in\n  let base = [] in\n  let args = List.rev l1 in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev (mulByDigit x l2)))) a\nin\nlet base = [] in\nlet args = List.rev(l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (List.rev (0 :: (List.rev (mulByDigit x l2)))) a in\n  let base = [] in\n  let args = List.rev l1 in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (mulByDigit x l2) (List.rev(0 :: (List.rev a)))\nin\nlet base = [] in\nlet args = List.rev(l1) in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (mulByDigit x l2) (List.rev (0 :: (List.rev a))) in\n  let base = [] in\n  let args = List.rev l1 in\n  let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (mulByDigit x l2) (List.rev(0 :: (List.rev a)))\nin\nlet base = [] in\nlet args = l1 in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (mulByDigit x l2) (List.rev (0 :: (List.rev a))) in\n  let base = [] in\n  let args = l1 in let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 (-lendiff)) @ l1, l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (mulByDigit x l2) (a @ [0])\nin\nlet base = [] in\nlet args = l1 in\nlet (res) = List.fold_left f base args in\nremoveZero res", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (mulByDigit x l2) (a @ [0]) in\n  let base = [] in\n  let args = l1 in let res = List.fold_left f base args in removeZero res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 (-lendiff)) @ l1, l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n", "out": ""}]}
