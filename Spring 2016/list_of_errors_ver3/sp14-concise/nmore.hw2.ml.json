{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (k', v) :: rest -> if k = k' then v else assoc (d,k,rest)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',v)::rest -> if k = k' then v else assoc (d, k, rest);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint f x'", "min": "\nlet rec fixpoint (f,x) = let x' = f x in if x' = x then x else fixpoint f x';;\n", "out": "Characters 73-74:\n  if x' = x then x else fixpoint f x';;\n                                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type\n         (('a -> 'b) -> 'a -> 'b) * ('a -> 'b)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint (f, x')", "min": "\nlet rec fixpoint (f,x) =\n  let x' = f x in if x' = x then x else fixpoint (f, x');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec fixpoint (f,x) =\n  let x' = f x in if x' = x then x else fixpoint (f, x');;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec fixpoint (f,x) = \nlet x' = f x in\nlet g x = (f, x' = x) in \nwwhile (g,x)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) =\n  let x' = f x in let g x = (f, (x' = x)) in wwhile (g, x);;\n", "out": "Characters 76-77:\n  wwhile (g,x);;\n          ^\nError: This expression has type 'a -> ('b -> 'a) * bool\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'b -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,x) = \nlet x' = f x in\nlet g x = (x', x' = x) in \nwwhile (g,x)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) =\n  let x' = f x in let g x = (x', (x' = x)) in wwhile (g, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) =\n  let x' = f x in let g x = (x', (x' = x)) in wwhile (g, x);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,x) = \nlet g x = (f x, f x = x) in \nwwhile (g,x)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) = let g x = ((f x), ((f x) = x)) in wwhile (g, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) = let g x = ((f x), ((f x) = x)) in wwhile (g, x);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,x) = \nlet g x = ((f x), (f x) = x) in \nwwhile (g,x)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) = let g x = ((f x), ((f x) = x)) in wwhile (g, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 2)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) = let g x = ((f x), ((f x) = x)) in wwhile (g, x);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,x) = \nlet g x = ((f x), (f x) = x) in\nwwhile (g,x)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) = let g x = ((f x), ((f x) = x)) in wwhile (g, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,x) = \nlet g x = ((f x), (f x) = x) in\nwwhile (g,x)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet fixpoint (f,x) = let g x = ((f x), ((f x) = x)) in wwhile (g, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet fixpoint (f,x) = let g x = ((f x), ((f x) = x)) in wwhile (g, x);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,x) = \nlet g x = ((f x), (f x) != x) in\nwwhile (g,x)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet fixpoint (f,x) = let g x = ((f x), ((f x) != x)) in wwhile (g, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet fixpoint (f,x) = let g x = ((f x), ((f x) != x)) in wwhile (g, x);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (k', v) :: rest -> if k = k' then v else assoc (d,k,rest)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',v)::rest -> if k = k' then v else assoc (d, k, rest);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (k', v) :: rest -> if k = k' then v else assoc (d,k,rest)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',v)::rest -> if k = k' then v else assoc (d, k, rest);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"x\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \"?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"x\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \"?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let test = exprToString sampleExpr1", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet test = exprToString sampleExpr1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (exprToString e1))\n| Cosine   (e1) -> cos(pi *. (exprToString e1))\n| Average  (e1, e2) -> ((exprToString e1) +. (exprToString e2))/.2.\n| Times    (e1, e2) -> (exprToString e1) *. (exprToString e2)\n| Thresh   (e1, e2, e3, e4) \n-> if (exprToString e1) < (exprToString e2) then\n(exprToString e3) else\n(exprToString e4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (exprToString e1))\n  | Cosine e1 -> cos (pi *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) /. 2.\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "out": "Characters 89-106:\n  | Sine     (e1) -> sin(pi *. (exprToString e1))\n                               ^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval e1))\n| Cosine   (e1) -> cos(pi *. (eval e1))\n| Average  (e1, e2) -> ((eeval e1) +. (eval e2))/.2.\n| Times    (e1, e2) -> (eval e1) *. (eval e2)\n| Thresh   (e1, e2, e3, e4) \n-> if (eval e1) < (eval e2) then\n(eval e3) else\n(eval e4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1))\n  | Cosine e1 -> cos (pi *. (eval e1))\n  | Average (e1,e2) -> ((eeval e1) +. (eval e2)) /. 2.\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "out": "Characters 95-97:\n  | Sine     (e1) -> sin(pi *. (eval e1))\n                                     ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "min": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (k', v) :: rest -> if k = k' then v else assoc (d,k,rest)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',v)::rest -> if k = k' then v else assoc (d, k, rest);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \"?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"\n| AbsThresh (e1, e2, e3) -> let s = exprToString e3 in\n\"(abs(\" ^ (exprToString e1) ^ \")<abs(\"\n^ (exprToString e2) ^ \"?\"\n^ s ^ \":abs(\"\n^ (exprToString e4) ^ \"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ (s ^ (\":abs(\" ^ ((exprToString e4) ^ \"))\")))))));;\n", "out": "Characters 615-617:\n  ^ (exprToString e4) ^ \"))\";;\n                  ^^\nError: Unbound value e4\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \"?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"\n| AbsThresh (e1, e2, e3) -> let s = exprToString e3 in\n\"(abs(\" ^ (exprToString e1) ^ \")<abs(\"\n^ (exprToString e2) ^ \"?\"\n^ s ^ \":abs(\"\n^ s ^ \"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\"?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \")?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"\n| AbsThresh (e1, e2, e3) -> let s = exprToString e3 in\n\"(abs(\" ^ (exprToString e1) ^ \")<abs(\"\n^ (exprToString e2) ^ \"?\"\n^ s ^ \":abs(\"\n^ s ^ \"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\")?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\"?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \"?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"\n| AbsThresh (e1, e2, e3) -> let s = exprToString e3 in\n\"(abs(\" ^ (exprToString e1) ^ \")<abs(\"\n^ (exprToString e2) ^ \")?\"\n^ s ^ \":abs(\"\n^ s ^ \"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \"?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"\n| AbsThresh (e1, e2, e3) -> let s = exprToString e3 in\n\"(abs(\" ^ (exprToString e1) ^ \")<abs(\"\n^ (exprToString e2) ^ \")?\"\n^ s ^ \":abs(\"\n^ s ^ \"))\"\n| ModThresh (e1, e2, e3) -> \n\"((truncate 1000*\" ^ (exprToString e1) ^ \") mod 5 = 0?\"\n^ (exprToString e2) ^ \":\"\n^ (exprToString e3) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 1000*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \"?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"\n| AbsThresh (e1, e2, e3) -> let s = exprToString e3 in\n\"(abs(\" ^ (exprToString e1) ^ \")<abs(\"\n^ (exprToString e2) ^ \")?\"\n^ s ^ \":abs(\"\n^ s ^ \"))\"\n| ModThresh (e1, e2, e3) -> \n\"((truncate 100*\" ^ (exprToString e1) ^ \") mod 5 = 0?\"\n^ (exprToString e2) ^ \":\"\n^ (exprToString e3) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100 *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100 *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n", "out": "Characters 588-591:\n  if (truncate (100 *. (eval (e1, x, y)))) mod 5 = 0 then\n                ^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100. *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildAbsThresh(e1,e2,e3)       = AbsThresh(e1,e2,e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX\nelse\nbuildY\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX else buildY)\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "out": "Characters 129-137:\n  buildX()\n  ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "out": "Characters 738-828:\n  buildModThresh (build (rand, depth - 1), build (rand, depth - 1),\n  build (rand, depth - 1))..\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX() :: expr\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "min": "\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then (buildX ()) :: expr else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "out": "Error: Unbound value expr\nHint: Did you mean exp?\nError: Unbound constructor AbsThresh\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 101-105:\n  buildX() :: expr\n              ^^^^\nError: Unbound value expr\nHint: Did you mean exp?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nbuildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0 then (if r < 50 then buildX () else buildY ()) else buildY ();;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\n\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (k', v) :: rest -> if k = k' then v else assoc (d,k,rest)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',v)::rest -> if k = k' then v else assoc (d, k, rest);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (k', v) :: rest -> if k = k' then v else assoc (d,k,rest)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',v)::rest -> if k = k' then v else assoc (d, k, rest);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (k', v) :: rest -> if k = k' then v else assoc (d,k,rest)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',v)::rest -> if k = k' then v else assoc (d, k, rest);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (1000. *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (1000. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (10. *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (10. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100. *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100. *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildModThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\")?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))))\n  | ModThresh (e1,e2,e3) ->\n      \"((truncate 100*\" ^\n        ((exprToString e1) ^\n           (\") mod 5 = 0?\" ^\n              ((exprToString e2) ^ (\":\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (k', v) :: rest -> if k = k' then v else assoc (d,k,rest)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',v)::rest -> if k = k' then v else assoc (d, k, rest);;\n", "out": ""}]}
