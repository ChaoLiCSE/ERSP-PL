{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper li =\n    match li with | [] -> d | (ki,vi)::t -> if ki = k then vi else helper t in\n  helper l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(wwhile(f, f b)),b", "out": "Characters 38-41:\n  let fixpoint (f,b) = wwhile(wwhile(f, f b)),b;;\n                                        ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = ((wwhile (wwhile (f, (f b)))), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(f, f b)", "out": "Characters 31-34:\n  let fixpoint (f,b) = wwhile(f, f b);;\n                                 ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(f, f (b))", "out": "Characters 31-36:\n  let fixpoint (f,b) = wwhile(f, f (b));;\n                                 ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(f (f b), b)", "out": "Characters 37-38:\n  let fixpoint (f,b) = wwhile(f (f b), b);;\n                                       ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(f,f b)", "out": "Characters 30-33:\n  let fixpoint (f,b) = wwhile(f,f b);;\n                                ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(f, b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(f, b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then helper (seen,t)\nelse h::seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then helper (seen, t) else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile(ffixpoint(f, f b), b)", "out": "Characters 32-41:\n  let rec fixpoint (f,b) = wwhile(ffixpoint(f, f b), b);;\n                                  ^^^^^^^^^\nError: Unbound value ffixpoint\nHint: Did you mean fixpoint?\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((ffixpoint (f, (f b))), b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b)", "out": "Characters 25-52:\n  let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b)*f b = b, b)", "out": "Characters 32-56:\n  let rec fixpoint (f,b) = wwhile(fixpoint(f, f b)*f b = b, b);;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((((fixpoint (f, (f b))) * (f b)) = b), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b = b), b)", "out": "Characters 32-58:\n  let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b = b), b);;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), ((f b) = b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b), b)", "out": "Characters 32-54:\n  let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b), b);;\n                                  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), (f b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),(f b) = b), b)", "out": "Characters 32-60:\n  let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),(f b) = b), b);;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), ((f b) = b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b)", "out": "Characters 25-52:\n  let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile(f, b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile(f, (f b = b), b)", "out": "Characters 31-48:\n  let rec fixpoint (f,b) = wwhile(f, (f b = b), b);;\n                                 ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile(f (f b = b), b)", "out": "Characters 32-43:\n  let rec fixpoint (f,b) = wwhile(f (f b = b), b);;\n                                  ^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile(f * (f b = b), b)", "out": "Characters 37-38:\n  let rec fixpoint (f,b) = wwhile(f * (f b = b), b);;\n                                       ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((f * ((f b) = b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(f (f b = b), b)", "out": "Characters 28-39:\n  let fixpoint (f,b) = wwhile(f (f b = b), b);;\n                              ^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(f, (f b = b), b)", "out": "Characters 27-44:\n  let fixpoint (f,b) = wwhile(f, (f b = b), b);;\n                             ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((f (f b = b)), b)", "out": "Characters 28-41:\n  let fixpoint (f,b) = wwhile((f (f b = b)), b);;\n                              ^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((f::(f b = b)), b)", "out": "Characters 28-42:\n  let fixpoint (f,b) = wwhile((f::(f b = b)), b);;\n                              ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f :: ((f b) = b)), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(if f b = b then f, b)", "out": "Characters 44-48:\n  let fixpoint (f,b) = wwhile(if f b = b then f, b);;\n                                              ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (f, b));;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(if f b = b then f b, b)", "out": "Characters 44-50:\n  let fixpoint (f,b) = wwhile(if f b = b then f b, b);;\n                                              ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then ((f b), b));;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(if f b != b then fixpoint(f, f b), b)", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 45-64:\n  let fixpoint (f,b) = wwhile(if f b != b then fixpoint(f, f b), b);;\n                                               ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) != b then ((fixpoint (f, (f b))), b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f, b)", "out": "Characters 99-100:\n  in helper (f, b);;\n             ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f, b);;\n", "type": "type"}, {"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((f, f b), b)", "out": "Characters 28-36:\n  let fixpoint (f,b) = wwhile((f, f b), b);;\n                              ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, (f b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((f f b), b)", "out": "Characters 31-32:\n  let fixpoint (f,b) = wwhile((f f b), b);;\n                                 ^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((f b, b), b)", "out": "Characters 28-36:\n  let fixpoint (f,b) = wwhile((f b, b), b);;\n                              ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (((f b), b), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((f, f b = b), b)", "out": "Characters 28-40:\n  let fixpoint (f,b) = wwhile((f, f b = b), b);;\n                              ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((f, (f b) = b), b)", "out": "Characters 28-42:\n  let fixpoint (f,b) = wwhile((f, (f b) = b), b);;\n                              ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "type": "type"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(fun x -> (f b, (f b) = b), b)", "out": "Characters 27-57:\n  let fixpoint (f,b) = wwhile(fun x -> (f b, (f b) = b), b);;\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b), ((f b) = b)), b));;\n", "type": "other"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) = b)), b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((fun x ->  (f b, (f b) != b)), b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((fun x ->  (f b, (f b) != b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), ((f b) != b))), b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun b  -> (f, ((f b) != b))), b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (fun b  -> ((f b), ((f b) != b), b));;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, b != f b)), b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), (b != (f b)))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, b != f b)) , b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), (b != (f b)))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> sprintf\"%s\" e", "out": "Characters 48-55:\n  | VarX -> sprintf\"%s\" e;;\n            ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" e;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> sprintf(\"%s\") e", "out": "Characters 48-55:\n  | VarX -> sprintf(\"%s\") e;;\n            ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" e;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> Output.sprintf(\"%s\") e", "out": "Characters 48-62:\n  | VarX -> Output.sprintf(\"%s\") e;;\n            ^^^^^^^^^^^^^^\nError: Unbound module Output\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Output.sprintf \"%s\" e;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> Module.sprintf(\"%s\") e", "out": "Characters 48-62:\n  | VarX -> Module.sprintf(\"%s\") e;;\n            ^^^^^^^^^^^^^^\nError: Unbound module Module\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Module.sprintf \"%s\" e;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s\" e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "out": "Characters 82-86:\n  | Sine     -> \"%s\" e\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "out": "Characters 82-86:\n  | Sine     -> \"%s %s\" e e\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e \n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "out": "Characters 82-86:\n  | Sine     -> \"%s %s\" e \n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e)          -> \"%s\" e \n| Cosine (e)        -> \"%s\" e\n| Average (e,e)     -> \"%s\" e\n| Times (e,e)       -> \"%s\" e\n| Thresh (e,e,e,e)  -> \"%s\" e", "out": "Characters 172-173:\n  | Average (e,e)     -> \"%s\" e\n               ^\nError: Variable e is bound several times in this matching\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e -> \"%s\" e\n  | Cosine e -> \"%s\" e\n  | Average (e,e) -> \"%s\" e\n  | Times (e,e) -> \"%s\" e\n  | Thresh (e,e,e,e) -> \"%s\" e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 61-65:\n  | VarX              -> \"%s\" e\n                         ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 61-68:\n  | VarX              -> sprintf\"%s\" e\n                         ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 80-81:\n  | VarX              -> Printf.sprintf\"%s\" e\n                                            ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 103-107:\n  | VarY              -> \"%s\" e\n                         ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 166-168:\n  | Sine (e1)          -> Printf.sprintf\"%s\" e1 \n                                             ^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 147-165:\n  | Sine (e1)          -> Printf.sprintf\"e1\"\n                          ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         string -> string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.printf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 147-164:\n  | Sine (e1)          -> Printf.printf\"e1\"\n                          ^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         string -> string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.printf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%d\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 166-168:\n  | Sine (e1)          -> Printf.sprintf\"%d\" e1\n                                             ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%d\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%x\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 166-168:\n  | Sine (e1)          -> Printf.sprintf\"%x\" e1\n                                             ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%x\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 147-165:\n  | Sine (e1)          -> Printf.sprintf\"e1\" \n                          ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         string -> string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 147-165:\n  | Sine (e1)          -> Printf.sprintf\"e1\" \n                          ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         string -> string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0", "out": "Characters 166-183:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "out": "Characters 166-183:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX x             -> x\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "out": "Characters 40-46:\n  | VarX x             -> x\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> x\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "out": "Characters 65-71:\n  | VarY y             -> y\n    ^^^^^^\nError: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "out": "Characters 65-71:\n  | VarY y             -> e\n    ^^^^^^\nError: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "out": "Characters 131-148:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "out": "Characters 131-148:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "out": "Characters 80-81:\n  | VarX              -> Printf.sprintf\"%s\" e\n                                            ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "out": "Characters 40-46:\n  | VarX e          -> e\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "out": "Characters 40-46:\n  | VarX e          -> e\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX           -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "out": "Characters 128-145:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX           -> \"\"::e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "out": "Characters 62-63:\n  | VarX           -> \"\"::e\n                          ^\nError: This expression has type expr but an expression was expected of type\n         string list\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\" :: e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "out": "Characters 49-53:\n  \"%d\" e\n  ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \nPrintf.sprintf\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "out": "Characters 68-69:\n  Printf.sprintf\"%d\" e\n                     ^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"(%s + %s)/2\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"(%s + %s)/2\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s<%s?%s:%s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"(sin(%s))\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"(cos(%s))\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"(%s*%s)\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s<%s?%s:%s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(pi*%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(pi*%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s<%s?%s:%s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"(sin(pi*%s))\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"(cos(pi*%s))\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"(%s*%s)\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s<%s?%s:%s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(pi*%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(pi*%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"(sin(pi*%s))\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"(cos(pi*%s))\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"(%s*%s)\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"sin(pi*%s)\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"cos(pi*%s)\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"(%s*%s)\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"sin(pi*%s)\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"cos(pi*%s)\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s*%s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "out": "Characters 82-84:\n  sin(eval e0)\n           ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (eval e0)\n  | Cosine e1 -> cos (eval e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "out": "Characters 77-79:\n  sin(pi*eval e0)\n      ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi * (eval e0))\n  | Cosine e1 -> cos (eval e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*(eval e0))\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "out": "Characters 77-79:\n  sin(pi*(eval e0))\n      ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi * (eval e0))\n  | Cosine e1 -> cos (eval e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*.(eval e0))\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "out": "Characters 87-89:\n  sin(pi*.(eval e0))\n                ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval e0))\n  | Cosine e1 -> cos (eval e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. e0)\n| Cosine e1 ->\ncos(pi *. e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "out": "Characters 83-85:\n  sin(pi *. e0)\n            ^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. e0)\n  | Cosine e1 -> cos (pi *. e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "out": "Characters 122-124:\n  cos(pi *. e1)\n            ^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "out": "Characters 163-165:\n  ((eval e2)+(eval e3))/2\n         ^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+(eval (e3,x,y)))/2\n| Times (e4,e5) ->\n(eval (e4,x,y))*(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "out": "Characters 157-172:\n  ((eval (e2,x,y))+(eval (e3,x,y)))/2\n   ^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) + (eval (e3, x, y))) / 2\n  | Times (e4,e5) -> (eval (e4, x, y)) * (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/2\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "out": "Characters 156-190:\n  ((eval (e2,x,y))+.(eval (e3,x,y)))/2\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) / 2\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "out": "Characters 192-193:\n  ((eval (e2,x,y))+.(eval (e3,x,y)))/.2\n                                      ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| _ -> \"ya dun f*cked up\"", "out": "Characters 361-379:\n  | _ -> \"ya dun f*cked up\";;\n         ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | _ -> \"ya dun f*cked up\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> \nif (rand mod 2) = 0 then buildX()\nelse buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> if (rand mod 2) = 0 then buildX () else buildY ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then buildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then buildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then buildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 3 then buildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then buildThresh(build(rand, depth -1))", "out": "Characters 269-293:\n  else if (rand mod 5) = 2 then buildAverage(build(rand, depth - 1))\n                                            ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then buildAverage (build (rand, (depth - 1)))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))", "out": "Characters 363-387:\n  buildAverage(build(rand, depth - 1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))", "out": "Characters 440-543:\n  buildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1));;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then\n            buildTimes\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if (rand mod 5) = 4\n            then\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nfailwith \"ugh\"", "out": "", "min": "\nlet rec build (rand,depth) = failwith \"ugh\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"ugh\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCos(build(rand, depth - 1))", "out": "Error: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\nError: Unbound value buildCos\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 131-139:\n  buildCos(build(rand, depth - 1));;\n  ^^^^^^^^\nError: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else if (rand > 0) & (rand < 20) then buildCos (build (rand, (depth - 1)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCosine(build(rand, depth - 1))", "out": "Characters 131-166:\n  buildCosine(build(rand, depth - 1));;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCosine(build(rand, depth - 1))", "out": "Characters 131-166:\n  buildCosine(build(rand, depth - 1));;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()", "out": "Characters 73-81:\n  buildX();;\n  ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand mod 2) = 0 then buildX ());;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper li =\n    match li with | [] -> d | (ki,vi)::t -> if ki = k then vi else helper t in\n  helper l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 then buildX()\nelse match rand with \n| 0 -> buildSine(build(makeRand(0,6), depth - 1))", "out": "Characters 103-116:\n  | 0 -> buildSine(build(makeRand(0,6), depth - 1));;\n                         ^^^^^^^^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((makeRand (0, 6)), (depth - 1))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 then buildX()\nelse match rand with \n| 0 -> buildSine(build(rand(0,6), depth - 1))\n| 1 -> buildCosine(build(rand(0,6), depth - 1))", "out": "Characters 103-107:\n  | 0 -> buildSine(build(rand(0,6), depth - 1))\n                         ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((rand (0, 6)), (depth - 1)))\n     | 1 -> buildCosine (build ((rand (0, 6)), (depth - 1))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 2))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 2))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 2))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 2))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (buildY ()))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,6) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 6) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 2))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 2))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 2))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 2))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 2))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 2))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 2))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 2))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 2))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 2))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 2))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildX ())\n     | 6 -> buildCosine (buildY ())\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (build (rand, (depth - 4))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), buildY())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), buildX())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (build (rand, (depth - 2))), (buildX ()))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), buildSine(build(rand, depth-1)), buildCosine(build(rand,depth - 1)))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildSine(build(rand, depth-1)), buildCosine(build(rand,depth - 1)))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (build (rand, (depth - 1))))\n     | 6 -> buildCosine (buildSine (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildX ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 8) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| POS      of expr * expr * expr * expr\n| SOP      of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))\n| SOP (f, g, h) ->\n(eval(f,x,y) + (eval(g,x,y) *. eval(h,x,y)))", "out": "Characters 457-468:\n  (eval(f,x,y) + (eval(g,x,y) *. eval(h,x,y)));;\n   ^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) + ((eval (g, x, y)) *. (eval (h, x, y)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))\n| SOP (f, g, h) ->\n(eval(f,x,y) +. (eval(g,x,y) *. eval(h,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper li =\n    match li with | [] -> d | (ki,vi)::t -> if ki = k then vi else helper t in\n  helper l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper li =\n    match li with | [] -> d | (ki,vi)::t -> if ki = k then vi else helper t in\n  helper l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper li =\n    match li with | [] -> d | (ki,vi)::t -> if ki = k then vi else helper t in\n  helper l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildCosine (buildX ()))\n     | 6 -> buildCosine (buildSine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | POS (a,b,c,d) ->\n      Printf.sprintf \"(%s+%s)(%s+%s)\" (exprToString a) (exprToString b)\n        (exprToString c) (exprToString d)\n  | SOP (f,g,h) ->\n      Printf.sprintf \"%s+%s*%s\" (exprToString f) (exprToString g)\n        (exprToString h);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildSine(buildX()))\n| 6 -> \nbuildCosine(buildCosine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildSine (buildX ()))\n     | 6 -> buildCosine (buildCosine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildSine(buildX()))\n| 6 -> \nbuildCosine(buildCosine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPOS (a1,b1,c1,d1) = POS (a1, b1, c1, d1);;\n\nlet buildSOP (f1,g1,h1) = SOP (f1, g1, h1);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 10) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))),\n             (buildX ()), (buildY ()))\n     | 5 -> buildSine (buildSine (buildX ()))\n     | 6 -> buildCosine (buildCosine (buildX ()))\n     | 7 ->\n         buildPOS\n           ((build (rand, (depth - 2))), (buildX ()),\n             (build (rand, (depth - 2))), (buildY ()))\n     | 8 -> buildSOP ((build (rand, (depth - 1))), (buildX ()), (buildY ()))\n     | _ -> buildY ());;\n", "type": ""}]}
