{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 38-41:\n  let fixpoint (f,b) = wwhile(wwhile(f, f b)),b;;\n                                        ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = ((wwhile (wwhile (f, (f b)))), b);;\n", "in": "let fixpoint (f,b) = wwhile(wwhile(f, f b)),b"}, {"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-34:\n  let fixpoint (f,b) = wwhile(f, f b);;\n                                 ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = wwhile(f, f b)"}, {"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-36:\n  let fixpoint (f,b) = wwhile(f, f (b));;\n                                 ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = wwhile(f, f (b))"}, {"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-38:\n  let fixpoint (f,b) = wwhile(f (f b), b);;\n                                       ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "in": "let fixpoint (f,b) = wwhile(f (f b), b)"}, {"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-33:\n  let fixpoint (f,b) = wwhile(f,f b);;\n                                ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = wwhile(f,f b)"}, {"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile(f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile(f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then helper (seen,t)\nelse h::seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 32-41:\n  let rec fixpoint (f,b) = wwhile(ffixpoint(f, f b), b);;\n                                  ^^^^^^^^^\nError: Unbound value ffixpoint\nHint: Did you mean fixpoint?\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((ffixpoint (f, (f b))), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(ffixpoint(f, f b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 25-52:\n  let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 32-56:\n  let rec fixpoint (f,b) = wwhile(fixpoint(f, f b)*f b = b, b);;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((((fixpoint (f, (f b))) * (f b)) = b), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b)*f b = b, b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 32-58:\n  let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b = b), b);;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), ((f b) = b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 32-54:\n  let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b), b);;\n                                  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), (f b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 32-60:\n  let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),(f b) = b), b);;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), ((f b) = b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),(f b) = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 25-52:\n  let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b);;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec fixpoint (f,b) = wwhile(f, b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-48:\n  let rec fixpoint (f,b) = wwhile(f, (f b = b), b);;\n                                 ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(f, (f b = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 32-43:\n  let rec fixpoint (f,b) = wwhile(f (f b = b), b);;\n                                  ^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(f (f b = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-38:\n  let rec fixpoint (f,b) = wwhile(f * (f b = b), b);;\n                                       ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((f * ((f b) = b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(f * (f b = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-39:\n  let fixpoint (f,b) = wwhile(f (f b = b), b);;\n                              ^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile(f (f b = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 27-44:\n  let fixpoint (f,b) = wwhile(f, (f b = b), b);;\n                             ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "in": "let fixpoint (f,b) = wwhile(f, (f b = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-41:\n  let fixpoint (f,b) = wwhile((f (f b = b)), b);;\n                              ^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f (f b = b)), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-42:\n  let fixpoint (f,b) = wwhile((f::(f b = b)), b);;\n                              ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f :: ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f::(f b = b)), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 44-48:\n  let fixpoint (f,b) = wwhile(if f b = b then f, b);;\n                                              ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (f, b));;\n", "in": "let fixpoint (f,b) = wwhile(if f b = b then f, b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 44-50:\n  let fixpoint (f,b) = wwhile(if f b = b then f b, b);;\n                                              ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile(if f b = b then f b, b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 45-64:\n  let fixpoint (f,b) = wwhile(if f b != b then fixpoint(f, f b), b);;\n                                               ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) != b then ((fixpoint (f, (f b))), b));;\n", "in": "let fixpoint (f,b) = wwhile(if f b != b then fixpoint(f, f b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 99-100:\n  in helper (f, b);;\n             ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f, b);;\n", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f, b)"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-36:\n  let fixpoint (f,b) = wwhile((f, f b), b);;\n                              ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, (f b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f, f b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-32:\n  let fixpoint (f,b) = wwhile((f f b), b);;\n                                 ^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "in": "let fixpoint (f,b) = wwhile((f f b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-36:\n  let fixpoint (f,b) = wwhile((f b, b), b);;\n                              ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (((f b), b), b);;\n", "in": "let fixpoint (f,b) = wwhile((f b, b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-40:\n  let fixpoint (f,b) = wwhile((f, f b = b), b);;\n                              ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f, f b = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-42:\n  let fixpoint (f,b) = wwhile((f, (f b) = b), b);;\n                              ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f, (f b) = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 27-57:\n  let fixpoint (f,b) = wwhile(fun x -> (f b, (f b) = b), b);;\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b), ((f b) = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile(fun x -> (f b, (f b) = b), b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) = b)), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 1);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = wwhile((fun x ->  (f b, (f b) != b)), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((fun x ->  (f b, (f b) != b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), ((f b) != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 107);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun b  -> (f, ((f b) != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 3);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 3);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "in": "let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (fun b  -> ((f b), ((f b) != b), b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-24:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n          ^^^^^^^^^^^^^^^^\nError: Unbound value removeDuplicates\n", "min": "\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 48);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, b != f b)), b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, b != f b)) , b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-52:\n  | VarX -> \"%s\" e;;\n            ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> sprintf\"%s\" e"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-55:\n  | VarX -> sprintf\"%s\" e;;\n            ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> sprintf(%s) e"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-55:\n  | VarX -> sprintf(\"%s\") e;;\n            ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Output.sprintf(\"%s\") e"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-62:\n  | VarX -> Output.sprintf(\"%s\") e;;\n            ^^^^^^^^^^^^^^\nError: Unbound module Output\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Output.sprintf \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Module.sprintf(\"%s\") e"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-62:\n  | VarX -> Module.sprintf(\"%s\") e;;\n            ^^^^^^^^^^^^^^\nError: Unbound module Module\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Module.sprintf \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"\"\n| Sine  \n| Cosine   \n| Average  \n| Times    \n| Thresh"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-86:\n  | Sine     -> \"%s\" e\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-86:\n  | Sine     -> \"%s %s\" e e\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e \n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-86:\n  | Sine     -> \"%s %s\" e \n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e)          -> \"%s\" e \n| Cosine (e)        -> \"%s\" e\n| Average (e,e)     -> \"%s\" e\n| Times (e,e)       -> \"%s\" e\n| Thresh (e,e,e,e)  -> \"%s\" e"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 172-173:\n  | Average (e,e)     -> \"%s\" e\n               ^\nError: Variable e is bound several times in this matching\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e -> \"%s\" e\n  | Cosine e -> \"%s\" e\n  | Average (e,e) -> \"%s\" e\n  | Times (e,e) -> \"%s\" e\n  | Thresh (e,e,e,e) -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-65:\n  | VarX              -> \"%s\" e\n                         ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 61-68:\n  | VarX              -> sprintf\"%s\" e\n                         ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-81:\n  | VarX              -> Printf.sprintf\"%s\" e\n                                            ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 103-107:\n  | VarY              -> \"%s\" e\n                         ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 166-168:\n  | Sine (e1)          -> Printf.sprintf\"%s\" e1 \n                                             ^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 147-165:\n  | Sine (e1)          -> Printf.sprintf\"e1\"\n                          ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         string -> string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.printf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 147-164:\n  | Sine (e1)          -> Printf.printf\"e1\"\n                          ^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         string -> string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.printf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%d\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 166-168:\n  | Sine (e1)          -> Printf.sprintf\"%d\" e1\n                                             ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%d\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%x\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 166-168:\n  | Sine (e1)          -> Printf.sprintf\"%x\" e1\n                                             ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%x\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 147-165:\n  | Sine (e1)          -> Printf.sprintf\"e1\" \n                          ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         string -> string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 147-165:\n  | Sine (e1)          -> Printf.sprintf\"e1\" \n                          ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         string -> string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 166-183:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 166-183:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX x             -> x\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-46:\n  | VarX x             -> x\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> x\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-71:\n  | VarY y             -> y\n    ^^^^^^\nError: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-71:\n  | VarY y             -> e\n    ^^^^^^\nError: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 131-148:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 131-148:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-81:\n  | VarX              -> Printf.sprintf\"%s\" e\n                                            ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-46:\n  | VarX e          -> e\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-46:\n  | VarX e          -> e\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX           -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 128-145:\n  | Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n                                             ^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX           -> \"\"::e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-63:\n  | VarX           -> \"\"::e\n                          ^\nError: This expression has type expr but an expression was expected of type\n         string list\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\" :: e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> \n\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-53:\n  \"%d\" e\n  ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> \nPrintf.sprintf\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-69:\n  Printf.sprintf\"%d\" e\n                     ^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"(%s + %s)/2\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s<%s?%s:%s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(pi*%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(pi*%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s<%s?%s:%s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(pi*%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(pi*%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"sin(pi*%s)\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"cos(pi*%s)\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"sin(pi*%s)\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"cos(pi*%s)\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s*%s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nSine(eval e0)\n| Cosine e1 ->\nCosine(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\n(eval e6)<(eval e7)?(eval e8):(eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\n(eval e6)<(eval e7)?(eval e8):(eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*(eval e0))\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*.(eval e0))\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. e0)\n| Cosine e1 ->\ncos(pi *. e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+(eval (e3,x,y)))/2\n| Times (e4,e5) ->\n(eval (e4,x,y))*(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/2\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| _ -> \"ya dun f*cked up\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with \n| 0 -> \nif (rand mod 2) = 0 then buildX()\nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then buildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then buildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then buildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 3 then buildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then buildThresh(build(rand, depth -1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 269-293:\n  else if (rand mod 5) = 2 then buildAverage(build(rand, depth - 1))\n                                            ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then buildAverage (build (rand, (depth - 1)))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 363-387:\n  buildAverage(build(rand, depth - 1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 440-543:\n  buildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1));;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then\n            buildTimes\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if (rand mod 5) = 4\n            then\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nfailwith \"ugh\""}, {"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCos(build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\nError: Unbound value buildCos\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 131-139:\n  buildCos(build(rand, depth - 1));;\n  ^^^^^^^^\nError: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else if (rand > 0) & (rand < 20) then buildCos (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCosine(build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 131-166:\n  buildCosine(build(rand, depth - 1));;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCosine(build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 131-166:\n  buildCosine(build(rand, depth - 1));;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 64-65:\n  if rand % 2 = 0 then buildX() \n          ^\nError: Unbound value %\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand % 2) = 0 then buildX () else buildY ()\n  | 1 ->\n      if (rand % 2) = 0\n      then buildSin (build (rand, (depth - 1)))\n      else buildCos (build (rand, (depth - 1)));;\n", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then buildX()\nelse match rand with \n| 0 -> buildSine(build(makeRand(0,6), depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 103-116:\n  | 0 -> buildSine(build(makeRand(0,6), depth - 1));;\n                         ^^^^^^^^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((makeRand (0, 6)), (depth - 1))));;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then buildX()\nelse match rand with \n| 0 -> buildSine(build(rand(0,6), depth - 1))\n| 1 -> buildCosine(build(rand(0,6), depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 105-109:\n  buildSine(build(rand(0,5), depth - 1))\n                  ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((rand (0, 5)), (depth - 1)))\n     | 1 -> buildCosine (build ((rand (0, 5)), (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build ((rand (0, 5)), (depth - 2))),\n             (build ((rand (0, 5)), (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build ((rand (0, 5)), (depth - 2))),\n             (build ((rand (0, 5)), (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4)))));;\n", "in": "let rand = \n\nlet rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand depth - 2), build(rand,depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth -4))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,6) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 2))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), buildY())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), buildX())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), buildSine(build(rand, depth-1)), buildCosine(build(rand,depth - 1)))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildSine(build(rand, depth-1)), buildCosine(build(rand,depth - 1)))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| POS      of expr * expr * expr * expr\n| SOP      of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))\n| SOP (f, g, h) ->\n(eval(f,x,y) + (eval(g,x,y) *. eval(h,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 457-468:\n  (eval(f,x,y) + (eval(g,x,y) *. eval(h,x,y)));;\n   ^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) + ((eval (g, x, y)) *. (eval (h, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))\n| SOP (f, g, h) ->\n(eval(f,x,y) +. (eval(g,x,y) *. eval(h,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildSine(buildX()))\n| 6 -> \nbuildCosine(buildCosine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildSine(buildX()))\n| 6 -> \nbuildCosine(buildCosine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()"}]}
