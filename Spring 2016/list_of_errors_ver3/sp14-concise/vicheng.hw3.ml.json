{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with \n| [] -> 0\n| h::t -> f (-1) h in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | h::t -> f (-1) h in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "Characters 139-141:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type (('a -> 'b) * ('b -> 'a)) list\n       but an expression was expected of type ('b -> 'b) list\n       Type ('a -> 'b) * ('b -> 'a) is not compatible with type 'b -> 'b \n", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h t\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "Characters 87-88:\n  | h::t -> f h t\n                ^\nError: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'c -> 'a\n", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h t | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f (fun x  -> x) h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = match fs with \n| h::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = x (a g) in\n  let base = match fs with | h::t -> f (fun x  -> x) h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = match fs with \n| h::t -> f (fun x -> 0) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = x (a g) in\n  let base = match fs with | h::t -> f (fun x  -> 0) h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f (fun x  -> x) h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> 1) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f (fun x  -> 1) h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> 0) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f (fun x  -> 0) h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f  h\n| [] -> fun x -> x in \nList.fold_left f base fs", "out": "Characters 133-135:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type ('a -> 'a) list\n       but an expression was expected of type (('b -> 'a) -> 'b -> 'a) list\n       The type variable 'a occurs inside 'b -> 'a\n", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = h in\nList.fold_left f base l", "out": "Characters 138-139:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = h in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x \n| h::t -> f h t in\nList.fold_left f base fs", "out": "Characters 107-108:\n  | h::t -> f h t in\n                ^\nError: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'c -> 'a\n", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f h t in\n  List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x \n| h::t -> f t h in\nList.fold_left f base fs", "out": "Characters 105-106:\n  | h::t -> f t h in\n              ^\nError: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f t h in\n  List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x \n| h::t -> f (fun x -> x) h in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x\n| h::t -> f (fun x -> x) h in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> 0\n| h::t -> f (fun x -> x) h in\nList.fold_left f base fs", "out": "Characters 93-109:\n  | h::t -> f (fun x -> x) h in\n            ^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> 0 | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x * 1\n| h::t -> f (fun x -> x * 1) h in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base =\n    match fs with | [] -> (fun x  -> x * 1) | h::t -> f (fun x  -> x * 1) h in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x/x\n| h::t -> f (fun x -> x/x) h in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base =\n    match fs with | [] -> (fun x  -> x / x) | h::t -> f (fun x  -> x / x) h in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> 1\n| h::t -> f (fun x -> 1) h in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> 1) | h::t -> f (fun x  -> 1) h in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> 1\n| h::t -> f h (fun x -> 1) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> 1) | h::t -> f h (fun x  -> 1) in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> 1\n| h::t -> f (fun x -> 1) h in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> 1) | h::t -> f (fun x  -> 1) h in\n  List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = f t in\nList.fold_left g base x", "out": "Characters 116-117:\n  let x = f t in\n            ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\";\" ^ x) in\n      let base = f h in let x = f t in List.fold_left g base x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = t in\nList.fold_left g base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\";\" ^ x) in\n      let base = f h in let x = t in List.fold_left g base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nList.fold_left g base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\";\" ^ x) in let base = f h in List.fold_left g base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nList.fold_left g base t", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\";\" ^ x) in let base = f h in List.fold_left g base t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with \n| [] -> 0\n| h::t -> f (-1) h in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | h::t -> f (-1) h in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left g base t", "out": "Characters 149-150:\n  List.fold_left g base t;;\n                 ^\nError: Unbound value g\n", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m b = \"[\" ^ (b ^ \"]\") in\n      let n a x = a ^ (\" ;\" ^ x) in let base = f h in List.fold_left g base t;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left n base t", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m b = \"[\" ^ (b ^ \"]\") in\n      let n a x = a ^ (\" ;\" ^ x) in let base = f h in List.fold_left n base t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "out": "Characters 82-85:\n  let m a b = \"[\" ^ a ^ \";\" b ^ \"]\" in\n                        ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ ((\";\" b) ^ \"]\")) in\n      let base = f h in List.fold_left m base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ (\";\" ^ (b ^ \"]\"))) in\n      let base = f h in List.fold_left m base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base h", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ (\";\" ^ (b ^ \"]\"))) in\n      let base = f h in List.fold_left m base h;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ (\";\" ^ (b ^ \"]\"))) in\n      let base = f h in List.fold_left m base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base t", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ (\";\" ^ (b ^ \"]\"))) in\n      let base = f h in List.fold_left m base t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"]\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base t", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"]\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ (\";\" ^ (b ^ \"]\"))) in\n      let base = f h in List.fold_left m base t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with \n| [] -> 0\n| h::t -> f (-1) h in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | h::t -> f (-1) h in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x\n| h::t -> f (fun x -> x) h in\nList.fold_left f base t", "out": "Characters 144-145:\n  List.fold_left f base t;;\n                        ^\nError: Unbound value t\n", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f (fun x  -> x) h in\n  List.fold_left f base t;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = a (x g) in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = x (a g) in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left top helper", "out": "Characters 137-140:\n  List.fold_left top helper;;\n                 ^^^\nError: Unbound value top\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left top helper;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with \n| [] -> 0\n| h::t -> f (-1) h in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | h::t -> f (-1) h in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = x (a g) in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t -> \nlet g a x = a ^ \"; \" ^ x in\nlet base = f h in\nlet l = t in\nList.fold_left g base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\"; \" ^ x) in\n      let base = f h in let l = t in List.fold_left g base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" l) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" f l) ^ \"]\"", "out": "Characters 30-39:\n  let stringOfList f l = \"[\" ^ (sepConcat \"; \" f l) ^ \"]\";;\n                                ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" f l) ^ \"]\");;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0 then []\nelse [x]::clone x (n-1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0 then []\nelse x::clone x (n-1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif l1 < l2 then 0", "out": "Characters 37-38:\n  if l1 < l2 then 0;;\n                  ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet padZero l1 l2 = if l1 < l2 then 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 < List.length l2 then\n(clone 0 (List.length l2 - List.length l1)::l1),l2\nelse if List.length l2 > List.length l2 then\nl1, (clone 0 (List.length l1 - List.length l2)::l2)\nelse \nl1, l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2)\n  else\n    if (List.length l2) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1) < (List.length l2) then\n(clone 0 (List.length l2 - List.length l1)::l1),l2\nelse if List.length l2 > List.length l2 then\nl1, (clone 0 (List.length l1 - List.length l2)::l2)\nelse \nl1, l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2)\n  else\n    if (List.length l2) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1) < (List.length l2) then\n(clone 0 ((List.length l2) - (List.length l1))::l1),l2\nelse if (List.length l2) > (List.length l2) then\nl1, (clone 0 ((List.length l1) - (List.length l2))::l2)\nelse \nl1, l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2)\n  else\n    if (List.length l2) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\n((clone 0 (sec - first))::l1),l2\nelse if first > sec then\nl1, ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then (((clone 0 (sec - first)) :: l1), l2)\n  else\n    if first > sec then (l1, ((clone 0 (first - sec)) :: l2)) else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\n((clone 0 (sec - first))::l1)\nelse if first > sec then\nl1, ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "out": "Characters 154-187:\n  l1, ((clone 0 (first - sec))::l2)\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then (clone 0 (sec - first)) :: l1\n  else\n    if first > sec then (l1, ((clone 0 (first - sec)) :: l2)) else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nList.append l1 ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "out": "Characters 183-206:\n  List.append l1 ((clone 0 (first - sec))::l2)\n                  ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then List.append l1 ((clone 0 (first - sec)) :: l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nl1, List.append (clone 0 (first - sec)) l2\nelse \nl1, l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| 0 -> removeZero t\n| _ -> l", "out": "Characters 54-55:\n  | 0 -> removeZero t\n                    ^\nError: Unbound value t\n", "min": "\nlet rec removeZero l = match l with | 0 -> removeZero t | _ -> l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse t", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = List.combine (List.rev l1) (List.rev l2) in\nlet args = \nList.split base in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 179-183:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.combine (List.rev l1) (List.rev l2) in\n    let args = List.split base in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x g = x (a g) in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = \nlet combo = List.combine (List.rev l1) (List.rev l2) in\nmatch combo with \n| (i,j) -> if (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> (0,0) in \nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 169-174:\n  | (i,j) -> if (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n    ^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type ('c * 'd) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = \nlet combo = List.combine (List.rev l1) (List.rev l2) in\nmatch combo with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 288-292:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = \nlet combo = List.combine (List.rev l1) (List.rev l2) in\nmatch combo with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 289-293:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = 0 in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 259-263:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int but an expression was expected of type\n         int * int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = 0 in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 268-272:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 268-272:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> a in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 262-266:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> a in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 262-266:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> a in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 254-258:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)-> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| _ -> a in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 249-253:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (i,j)-> \nif (i + j) > 9 then a::(1, (i + j - 10)) else a::(0 , i + j)\n| _ -> a in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 99-116:\n  if (i + j) > 9 then a::(1, (i + j - 10)) else a::(0 , i + j)\n                         ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          if (i + j) > 9 then a :: (1, ((i + j) - 10)) else a :: (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (i,j)-> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> a in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 133-135:\n  | [] -> a in\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j) in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 233-237:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 135-146:\n  else if (i + j) <= 9 then (0 , i + j) in\n                            ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 135-146:\n  else if (i + j) <= 9 then (0 , i + j) in\n                            ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 135-146:\n  else if (i + j) <= 9 then (0 , i + j) in\n                            ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 135-146:\n  else if (i + j) <= 9 then (0 , i + j) in\n                            ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 135-146:\n  else if (i + j) <= 9 then (0 , i + j) in\n                            ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\n((i+j+a)/10, (i+j+a)%10) in \nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 90-91:\n  ((i+j+a)/10, (i+j+a)%10) in \n                      ^\nError: Unbound value %\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in ((((i + j) + a) / 10), (((i + j) + a) % 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\n((i+j+a)/10, (i+j+a) mod 10) in \nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 210-211:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int * int -> int * int\n       but an expression was expected of type int -> int * int -> int\n       Type int * int is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in ((((i + j) + a) / 10), (((i + j) + a) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \na::((i+j)/10, (i+j) mod 10) in\n\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 74-98:\n  a::((i+j)/10, (i+j) mod 10) in\n     ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in a :: (((i + j) / 10), ((i + j) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\na::((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 91-123:\n  a::((i+j+s+t)/10, (i+j+s+t) mod 10) in\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in a ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\n((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 233-237:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\n((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 233-237:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\na::((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 91-123:\n  a::((i+j+s+t)/10, (i+j+s+t) mod 10) in\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in a ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\n(s,t)::((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 95-127:\n  (s,t)::((i+j+s+t)/10, (i+j+s+t) mod 10) in\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (s, t) ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \na::((i+j)/10, (i+j) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 74-98:\n  a::((i+j)/10, (i+j) mod 10) in\n     ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in a :: (((i + j) / 10), ((i + j) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \n((i+j) mod 10, a::((i+j)/10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 89-99:\n  ((i+j) mod 10, a::((i+j)/10)) in\n                    ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in (((i + j) mod 10), (a :: ((i + j) / 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\n(((i+j)/10), t::(i+j) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 104-116:\n  (((i+j)/10), t::(i+j) mod 10) in\n                  ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t ) =  a in \n((i+j)/10, ((i+j) mod 10)) = a in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 232-233:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int * int -> int * int -> bool\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type bool is not compatible with type int * int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), ((i + j) mod 10)) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t ) =  a in \n((i+j)/10, t::((i+j) mod 10)) = a in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 105-119:\n  ((i+j)/10, t::((i+j) mod 10)) = a in\n                ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t ) =  a in \n((i+j+s)/10, t::((i+j+s) mod 10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 107-123:\n  ((i+j+s)/10, t::((i+j+s) mod 10)) in\n                  ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, t@((i+j+s) mod 10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 105-121:\n  ((i+j+s)/10, t@((i+j+s) mod 10)) in\n                 ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t @ (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, t::((i+j+s) mod 10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 106-122:\n  ((i+j+s)/10, t::((i+j+s) mod 10)) in\n                  ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \na = ((i+j+s)/10, t::((i+j+s) mod 10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 107-108:\n  a = ((i+j+s)/10, t::((i+j+s) mod 10)) in\n                   ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      a = ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (padZero l1)) (List.rev (padZero l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 183-195:\n  List.combine (List.rev (padZero l1)) (List.rev (padZero l2)) in\n                         ^^^^^^^^^^^^\nError: This expression has type int list -> int list * int list\n       but an expression was expected of type 'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (padZero l1)) (List.rev (padZero l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1::0) (List.rev l2::0) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 187-188:\n  List.combine (List.rev l1::0) (List.rev l2::0) in\n                             ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev l2) :: 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev 0::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 183-184:\n  List.combine (List.rev 0::l1) (List.rev 0::l2) in\n                         ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1::0) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 187-188:\n  List.combine (List.rev l1::0) (List.rev 0::l2) in\n                             ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev 0::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 183-184:\n  List.combine (List.rev 0::l1) (List.rev 0::l2) in\n                         ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev [0]::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 202-203:\n  List.combine (List.rev [0]::l1) (List.rev 0::l2) in\n                                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev [0]::l1) (List.rev [0]::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 251-255:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int list * int list) list\n       but an expression was expected of type (int * int) list\n       Type int list is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev [0]) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet mul (i1, l1) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (List.rev (clone (List.length l) i)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (mul l)", "out": "Characters 307-308:\n  removeZero (mul l);;\n                  ^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mul (i1,l1) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args =\n      List.combine (List.rev (0 :: l1)) (List.rev (clone (List.length l) i)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (List.rev (clone (List.length l) i)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (List.rev (clone (List.length l) i)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone (List.length l) i) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l1)) (clone (List.length l) i) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone i ((List.length+1) l)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 188-199:\n  List.combine (List.rev (0::l1)) (clone i ((List.length+1) l)) in\n                                             ^^^^^^^^^^^\nError: This expression has type 'a list -> int\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (clone i ((List.length + 1) l)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone i (List.length l+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 74-86:\n  ((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in\n                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), (((mulByDigit x) * ((10 ** i) l2)) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 89-91:\n  ((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in\n                                       ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), ((mulByDigit (x * (10 ** i)) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 88-110:\n  ((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in\n                                      ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), ((mulByDigit (x * ((float_of_int 10) ** i)) l2)\n      :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*int_of_float((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 204-205:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         float * int list list -> int -> int * int list list\n       but an expression was expected of type\n         float * int list list -> int -> float * int list list\n       Type int is not compatible with type float \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1),\n      ((mulByDigit (x * (int_of_float ((float_of_int 10) ** i))) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(int_of_float((float_of_int 10)**i))) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 206-207:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         float * int list list -> int -> int * int list list\n       but an expression was expected of type\n         float * int list list -> int -> float * int list list\n       Type int is not compatible with type float \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1),\n      ((mulByDigit (x * (int_of_float ((float_of_int 10) ** i))) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultipler (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 145-154:\n  multipler (float_of_int i) j in\n  ^^^^^^^^^\nError: Unbound value multipler\nHint: Did you mean multiplier?\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1), ((mulByDigit (x * (int_of_float (m ** i))) l2)\n        :: n)) in\n    multipler (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 170-171:\n  multiplier (float_of_int i) j in\n                           ^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1), ((mulByDigit (x * (int_of_float (m ** i))) l2)\n        :: n)) in\n    multiplier (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 129-131:\n  ((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in\n                                                         ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1),\n        ((mulByDigit (x * (int_of_float (m ** 10))) l2) :: n)) in\n    multiplier (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1),\n        ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1),\n        ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int (List.length l1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int (List.length l1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1) - 1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1) - 1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 111-112:\n  (m - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\n                                       ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m - 1), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m-1.0, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 77-80:\n  (m-1.0, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\n     ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m - 1.0), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 81-98:\n  (i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in\n         ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), (((mulByDigit x l2) * (int_of_float (10 ** m))) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 129-164:\n  multiplier (float_of_int ((List.length l1)-1)) j in\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n = ((i - 1), ((mulByDigit x l2) :: (clone 0 m) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n = ((i - 1), ((mulByDigit x l2) :: (clone 0 m) :: n)) in\n    multiplier ((List.length l1) - 1) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, bigAdd ((mulByDigit x l2)::(clone 0 m)) n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 88-105:\n  (i-1, bigAdd ((mulByDigit x l2)::(clone 0 m)) n) in\n                ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), (bigAdd ((mulByDigit x l2) :: (clone 0 m)) n)) in\n    multiplier ((List.length l1) - 1) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier ((List.length l1) - 1) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m-1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m - 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier ((List.length l1) - 1) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = (List.length - 1 , []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type 'a list -> int\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 155-166:\n  let base = (List.length - 1 , []) in\n              ^^^^^^^^^^^\nError: This expression has type 'a list -> int\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = ((List.length - 1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1 , []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = (((List.length l1) - 1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1), []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = ((List.length l1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = match i with \n| 0 -> []\n| _ ->\nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 105-138:\n  ((i*j+s)/10, ((i*j+s) mod 10)::t) in\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> []\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = match i with \n| 0 -> (0,[])\n| _ ->\nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet f a x = match i with \n| 0 -> (0,[0])\n| _ ->\nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1, [0]) in\nlet args = 0::l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = (((List.length l1) - 1), [0]) in\n  let args = 0 :: l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1, [0]) in\nlet args = l1@[0] in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = (((List.length l1) - 1), [0]) in\n  let args = l1 @ [0] in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = (((List.length l1) - 1), [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = (((List.length l1) - 1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier i j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier i j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier i j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier i j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier i j in\nlet base = (List.length l1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier i j in\n  let base = ((List.length l1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 (List.length l1))) n) in\nmultiplier i j in\nlet base = (List.length l1 - 1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 (List.length l1))) n)) in\n    multiplier i j in\n  let base = (((List.length l1) - 1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 (List.length l1 - 1))) n) in\nmultiplier i j in\nlet base = (List.length l1 - 1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1),\n        (bigAdd ((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))) n)) in\n    multiplier i j in\n  let base = (((List.length l1) - 1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m-1, bigAdd ((mulByDigit x l2)@(clone 0 (List.length l1 - 1))) n) in\nmultiplier i j in\nlet base = (List.length l1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [0])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m - 1),\n        (bigAdd ((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))) n)) in\n    multiplier i j in\n  let base = ((List.length l1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
