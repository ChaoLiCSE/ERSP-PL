{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n0", "out": "Characters 38-58:\n  (digitsOfInt (n/10)) :: n mod 10\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n[]", "out": "Characters 38-58:\n  (digitsOfInt (n/10)) :: n mod 10\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = if n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n| [] -> l\n| (h::t) -> listReverse (h::l)", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse (h :: l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l)", "out": "Characters 55-73:\n  | (h::t) -> listReverse (h::l);;\n              ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n", "min": "\nlet rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t", "out": "", "min": "\nlet rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t", "out": "", "min": "\nlet rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nl [] list", "out": "Characters 79-80:\n  l [] list;;\n  ^\nError: Unbound value l\n", "min": "\nlet _ =\n  let rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t in\n  l [] list;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nlistReverse [] l", "out": "Characters 94-95:\n  listReverse [] l;;\n                 ^\nError: Unbound value l\n", "min": "\nlet _ =\n  let rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t in\n  listReverse [] l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n| [] -> l\n| [_::tail::[]] -> l", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | (_::tail::[])::[] -> l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n| [] -> l\n| [other::tail::[]] -> tail :: other", "out": "Characters 70-74:\n  | [other::tail::[]] -> tail :: other;;\n                         ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | (other::tail::[])::[] -> tail :: other;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlistReverseHelper l []", "out": "Characters 24-41:\n  listReverseHelper l [];;\n  ^^^^^^^^^^^^^^^^^\nError: Unbound value listReverseHelper\n", "min": "\nlet rec listReverse l = listReverseHelper l [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverseHelper l ans = match l with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "out": "", "min": "\nlet rec listReverseHelper l ans =\n  match l with | [] -> [] | h::t -> ans :: (listReverseHelper t ans);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans) in \n\nlistReverseHelper l []", "out": "", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper l ans =\n    match ans with | [] -> [] | h::t -> listReverseHelper t (h :: ans) in\n  listReverseHelper l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec listReverseHelper l ans = match l with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans) in \n\nlistReverseHelper l []", "out": "", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper l ans =\n    match l with | [] -> [] | h::t -> listReverseHelper t (h :: ans) in\n  listReverseHelper l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec listReverseHelper dec acc = match dec with\n| [] -> acc\n| h::t -> listReverseHelper t (h::acc) in \n\nlistReverseHelper l []", "out": "", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = if n > 0\nthen\nlistReverse (n mod 10) :: (digitsOfInt (n/10))\nelse\n[]", "out": "Characters 50-60:\n  listReverse (n mod 10) :: (digitsOfInt (n/10))\n              ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = if n > 0\nthen\nlistReverse ((n mod 10) :: (digitsOfInt (n/10)))\nelse\n[]", "out": "", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  if n > 0 then listReverse ((n mod 10) :: (digitsOfInt (n / 10))) else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet digitsOfIntHelper n1 = \nif n > 0\nthen\nlistReverse ((n mod 10) :: (digitsOfInt (n/10)))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)", "out": "", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digitsOfIntHelper n1 =\n    if n > 0 then listReverse ((n mod 10) :: (digitsOfInt (n / 10))) else [] in\n  listReverse (digitsOfIntHelper n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet digitsOfIntHelper n1 = \nif n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)", "out": "", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digitsOfIntHelper n1 =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (digitsOfIntHelper n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet rec digitsOfIntHelper n1 = \nif n > 0\nthen\n(n mod 10) :: (digitsOfIntHelper (n/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)", "out": "", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n1 =\n    if n > 0 then (n mod 10) :: (digitsOfIntHelper (n / 10)) else [] in\n  listReverse (digitsOfIntHelper n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet rec digitsOfIntHelper n1 = \nif n1 > 0\nthen\n(n1 mod 10) :: (digitsOfIntHelper (n1/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)", "out": "", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n1 =\n    if n1 > 0 then (n1 mod 10) :: (digitsOfIntHelper (n1 / 10)) else [] in\n  listReverse (digitsOfIntHelper n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = failwith \"TBD\"", "out": "", "min": "\nlet rec additivePersistence n = failwith \"TBD\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \nn mod 10 + digitalRoot n\nelse\nn", "out": "", "min": "\nlet rec digitalRoot n = if n > 10 then (n mod 10) + (digitalRoot n) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \n( n mod 10 )+ digitalRoot n/10\nelse\nn", "out": "", "min": "\nlet rec digitalRoot n =\n  if n > 10 then (n mod 10) + ((digitalRoot n) / 10) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \n( n mod 10 )+ digitalRoot (n/10)\nelse\nn", "out": "", "min": "\nlet rec digitalRoot n =\n  if n > 10 then (n mod 10) + (digitalRoot (n / 10)) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot( n mod 10 )+ (n/10)\nelse\nn", "out": "", "min": "\nlet rec digitalRoot n =\n  if n > 10 then (digitalRoot (n mod 10)) + (n / 10) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot (n mod 10 + n/10)\nelse\nn", "out": "", "min": "\nlet rec digitalRoot n =\n  if n > 10 then digitalRoot ((n mod 10) + (n / 10)) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n < 10 then \nn \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "out": "", "min": "\nlet rec additivePersistence n =\n  let rec sumDigits n1 =\n    if n < 10 then n else (n1 mod 10) + (sumDigits (n1 / 10)) in\n  if n < 10 then 0 else 1 + (additivePersistence (sumDigits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n1 < 10 then \nn1 \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "out": "", "min": "\nlet rec additivePersistence n =\n  let rec sumDigits n1 =\n    if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10)) in\n  if n < 10 then 0 else 1 + (additivePersistence (sumDigits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n1 < 10 then \nn1 \nelse\nn1 mod 10 + sumDigits (n1 / 10)\nin \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "out": "", "min": "\nlet rec additivePersistence n =\n  let rec sumDigits n1 =\n    if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10)) in\n  if n < 10 then 0 else 1 + (additivePersistence (sumDigits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "out": "", "min": "\nlet rec sumDigits n1 =\n  if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10));;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumDigits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot (sumDigits n)\nelse\nn", "out": "", "min": "\nlet rec sumDigits n1 =\n  if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10));;\n\nlet rec digitalRoot n = if n > 10 then digitalRoot (sumDigits n) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "out": "", "min": "\nlet rec sumDigits n1 =\n  if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10));;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumDigits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = (explode w) = (explode (listReverse w))", "out": "Characters 55-56:\n  let palindrome w = (explode w) = (explode (listReverse w));;\n                                                         ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (explode (listReverse w));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = (explode w) = (listReverse (explode w))", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = (explode w) = (listReverse (explode w))", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = (explode w) = (listReverse (explode w))", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) % 9\nelse\nn", "out": "Characters 55-56:\n  1 + (n - 1) % 9\n              ^\nError: Unbound value %\n", "min": "\nlet rec digitalRoot n = if n > 10 then 1 + ((n - 1) % 9) else n;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) mod 9\nelse\nn", "out": "", "min": "\nlet rec digitalRoot n = if n > 10 then 1 + ((n - 1) mod 9) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) mod 9\nelse\nn", "out": "", "min": "\nlet rec digitalRoot n = if n > 10 then 1 + ((n - 1) mod 9) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = 1 + (n - 1) mod 9", "out": "", "min": "\nlet rec digitalRoot n = 1 + ((n - 1) mod 9);;\n", "type": ""}]}
