{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 38-58:\n  (digitsOfInt (n/10)) :: n mod 10\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else 0;;\n", "in": "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 38-58:\n  (digitsOfInt (n/10)) :: n mod 10\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> l\n| (h::t) -> listReverse (h::l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n          ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nl [] list"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 79-80:\n  l [] list;;\n  ^\nError: Unbound value l\n", "min": "\nlet _ =\n  let rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t in\n  l [] list;;\n", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nlistReverse [] l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 94-95:\n  listReverse [] l;;\n                 ^\nError: Unbound value l\n", "min": "\nlet _ =\n  let rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t in\n  listReverse [] l;;\n", "in": "let rec listReverse l = match l with\n| [] -> l\n| [_::tail::[]] -> l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> l\n| [other::tail::[]] -> tail :: other"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-74:\n  | [other::tail::[]] -> tail :: other;;\n                         ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | (other::tail::[])::[] -> tail :: other;;\n", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-74:\n  | [other::tail::[]] -> tail :: other;;\n                         ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | (other::tail::[])::[] -> tail :: other;;\n", "in": "let rec listReverseHelper l ans = \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 24-41:\n  listReverseHelper l [];;\n  ^^^^^^^^^^^^^^^^^\nError: Unbound value listReverseHelper\n", "min": "\nlet rec listReverse l = listReverseHelper l [];;\n", "in": "let rec listReverseHelper l ans = \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans)\n\nlistReverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec listReverseHelper l ans = match l with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans) in \n\nlistReverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec listReverseHelper dec acc = match dec with\n| [] -> acc\n| h::t -> listReverseHelper t (h::acc) in \n\nlistReverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n > 0\nthen\nlistReverse (n mod 10) :: (digitsOfInt (n/10))\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 50-60:\n  listReverse (n mod 10) :: (digitsOfInt (n/10))\n              ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n", "in": "let rec digitsOfInt n = if n > 0\nthen\nlistReverse ((n mod 10) :: (digitsOfInt (n/10)))\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet digitsOfIntHelper n1 = \nif n > 0\nthen\nlistReverse ((n mod 10) :: (digitsOfInt (n/10)))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet digitsOfIntHelper n1 = \nif n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet rec digitsOfIntHelper n1 = \nif n > 0\nthen\n(n mod 10) :: (digitsOfIntHelper (n/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet rec digitsOfIntHelper n1 = \nif n1 > 0\nthen\n(n1 mod 10) :: (digitsOfIntHelper (n1/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n\n(* uncomment and run AFTER you have implemented additivePersistence  \n\nlet _ = additivePersistence 9876\n\n*)\n\n(* NOTE: assume that digitalRoot is only called with positive numbers *)\n\nlet rec digitalRoot n = \nif (n > 10) then \nn mod 10 + digitalRoot n\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n\n(* uncomment and run AFTER you have implemented additivePersistence  \n\nlet _ = additivePersistence 9876\n\n*)\n\n(* NOTE: assume that digitalRoot is only called with positive numbers *)\n\nlet rec digitalRoot n = \nif (n > 10) then \nn mod 10 + digitalRoot n\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \nn mod 10 + digitalRoot n\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n( n mod 10 )+ digitalRoot n/10\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n( n mod 10 )+ digitalRoot (n/10)\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot( n mod 10 )+ (n/10)\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot (n mod 10 + n/10)\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-85:\n  n1 % 10 + sumDigits (n1 / 10) in \n     ^\nError: Unbound value %\n", "min": "\nlet rec additivePersistence n =\n  let rec sumDigits n1 =\n    if n < 10 then n else (n1 % 10) + (sumDigits (n1 / 10)) in\n  if n < 10 then 0 else 1 + (additivePersistence (sumDigits n));;\n", "in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n < 10 then \nn \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n1 < 10 then \nn1 \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n1 < 10 then \nn1 \nelse\nn1 mod 10 + sumDigits (n1 / 10)\nin \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 55-64:\n  digitalRoot sumDigits n\n              ^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet rec sumDigits n1 =\n  if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10));;\n\nlet rec digitalRoot n = if n > 10 then digitalRoot sumDigits n else n;;\n", "in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot (sumDigits n)\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = (explode w) = (explode (listReverse w))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 55-56:\n  let palindrome w = (explode w) = (explode (listReverse w));;\n                                                         ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (explode (listReverse w));;\n", "in": "let palindrome w = (explode w) = (listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = (explode w) = (listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = (explode w) = (listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) % 9\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) mod 9\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) mod 9\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = 1 + (n - 1) mod 9"}]}
