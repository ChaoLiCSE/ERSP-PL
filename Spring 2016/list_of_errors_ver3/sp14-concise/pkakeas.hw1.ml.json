{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let palindrome w = failwith \"TBD\"", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let palindrome w = failwith \"TBD\"", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs = failwith \"TBD:sumList failed\"", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 61-64:\n  | x::xs' ->x + sum xs';;\n                 ^^^\nError: Unbound value sum\n", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sum xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sum xs');;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 39-40:\n  if n < 0 then 4;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "in": "let rec digitsOfInt n = \nif n < 0 then 4", "min": "\nlet rec digitsOfInt n = if n < 0 then 4;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 39-41:\n  if n < 0 then [];;\n                ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "in": "let rec digitsOfInt n = \nif n < 0 then []", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 39-40:\n  if n < 0 then 0;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "in": "let rec digitsOfInt n = \nif n < 0 then 0", "min": "\nlet rec digitsOfInt n = if n < 0 then 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 39-40:\n  if n < 0 then n;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "in": "let rec digitsOfInt n = \nif n < 0 then n", "min": "\nlet rec digitsOfInt n = if n < 0 then n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 47-48:\n  else n;;\n       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse [1;2;3]", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [1;2;3;4;5;6;7;8;9]\nelse [1;2;3]", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 130-131:\n  List.iter innerFunc n;;\n                      ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet innerFunc elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter innerFunc n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let innerFunc elem = Printf.printf \"Element is %d\\n\" elem in\n     List.iter innerFunc n);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 114-115:\n  List.iter f n;;\n              ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let f elem = Printf.printf \"Element is %d\\n\" elem in List.iter f n);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 114-115:\n  List.iter f n;;\n              ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let f elem = Printf.printf \"Element is %d\\n\" elem in List.iter f n);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> loop n []", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 179-188:\n  match listElem1 with\n        ^^^^^^^^^\nError: Unbound value listElem1\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop listElem1 listElem2 =\nif listElem1 = 0 then listElem2\nelse loop (listElem1/10) (listElem1 mod 10::listElem2) in\nmatch listElem1 with\n| _ -> loop listElem1 []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop listElem1 listElem2 =\n       if listElem1 = 0\n       then listElem2\n       else loop (listElem1 / 10) ((listElem1 mod 10) :: listElem2) in\n     match listElem1 with | _ -> loop listElem1 []);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> loop n []", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let digits n = digitsOfInt (abs n)", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let digits n = digitsOfInt (abs n)", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n =\nsumList (digitsOfInt (abs n) )", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n =\nif (n mod 10 ) != 0 then sumList (digitsOfInt (abs n) )\nelse sumList (digitsOfInt (abs n) )", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n =\nif (n mod 10 ) <> 0 then sumList (digitsOfInt (abs n) )\nelse sumList (digitsOfInt (abs n) )", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 57-58:\n  x = x + 1;;\n  ^\nError: Unbound value x\n", "in": "let rec additivePersistence n = \nif n mod 10  != 0 then \nx = x + 1", "min": "\nlet rec additivePersistence n = if (n mod 10) != 0 then x = (x + 1);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"out": "Characters 88-92:\n  else loop sumList(digitsOfInt retVal ) in match n with \n       ^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "in": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) in match n with \n| 0 -> 0\n| _ -> loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let rec loop retVal =\n    if retVal < 10 then retVal else loop sumList (digitsOfInt retVal) in\n  match n with | 0 -> 0 | _ -> loop n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet rec recursive_loop retVal = \nif retVal < 10 then retVal\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with \n| addP -> addP + 1\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 131-132:\n  addP = addP + 1\n                ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let rec addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP = (addP + (1 recursive_loop (sumList (digitsOfInt retVal)))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 127-128:\n  addP = addP + 1\n                ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP = (addP + (1 recursive_loop (sumList (digitsOfInt retVal)))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 113-117:\n  incr addP\n  ^^^^\nError: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nincr addP\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else incr addP recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then 8\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then n\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \n\nlet rec recursive_loop retVal = \nlet addP = 0 in\nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 113-128:\n  addP = addP + 1 in\n  ^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         int\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    let addP = 0 in\n    let rec recursive_loop retVal =\n      if retVal < 10 then addP else addP = (addP + 1) in\n    recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 161-167:\n  recursive_loop (sumList(digitsOfInt retVal )) in match n with\n                                      ^^^^^^\nError: Unbound value retVal\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    let addP = 0 in\n    let rec recursive_loop retVal = if retVal < 10 then addP else addP + 1 in\n    recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"out": "Characters 120-121:\n  addP + 1\n         ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP + (1 recursive_loop (sumList (digitsOfInt retVal))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 141-186:\n  recursive_loop (sumList(digitsOfInt retVal )) in match n with\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal addP =\n    if retVal < 10\n    then addP\n    else\n      (let addP = addP + 1 in recursive_loop (sumList (digitsOfInt retVal))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 224-240:\n  | _ -> recursive_loop n;;\n         ^^^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal addP =\n    if retVal < 10\n    then addP\n    else\n      (let addP = addP + 1 in\n       recursive_loop (sumList (digitsOfInt retVal)) addP) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n addP", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitalRoot n = \nlet rec recursive_loop retVal = \nif retVal < 10 then retVal\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec listReverse l = \nlet rec rev acc = function\n| [] -> acc\n| h::t -> rev (h::acc) t in\nrev[] l", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec listReverse l = \nlet rec rev element = function\n| [] -> element\n| h::t -> rev (h::element) t in\nrev[] l", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 23-39:\n  w = List.listReverse w;;\n      ^^^^^^^^^^^^^^^^\nError: Unbound value List.listReverse\n", "in": "let palindrome w =\nw = List.listReverse w", "min": "\nlet palindrome w = w = (List.listReverse w);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let palindrome w =\nw = listReverse w", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let palindrome w =\nlet reverse = listReverse w in\nif reverse = w then true\nelse false", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "Characters 41-56:\n  let reverse = explode (listReverse w) in\n                        ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n", "in": "let palindrome w =\nlet reverse = explode (listReverse w) in\nif reverse = w then true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = explode (listReverse w) in\n  if reverse = w then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 73-74:\n  if reverse = w then true\n               ^\nError: This expression has type string but an expression was expected of type\n         char list\n", "in": "let palindrome w =\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "Characters 95-96:\n  if reverse = w then true\n               ^\nError: This expression has type string but an expression was expected of type\n         char list\n", "in": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let pk = explode w in\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = pk then true\nelse false", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let palindrome w =\nlet convertedString = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = convertedString then true\nelse false", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec listReverse l = \nlet rec rev element = function\n| [] -> element\n| head::tail -> rev (head::element) tail in\nrev[] l", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let palindrome w =\nlet reverse = listReverse (explode w) in\nif reverse = explode w then true\nelse false", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let palindrome w =\nif listReverse (explode w) = explode w then true\nelse false", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop_rec n counter =\nif n = 0 then counter\nelse loop_rec (n/10) (n mod 10::counter) in\nmatch n with\n| _ -> loop_rec n []", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let digits n = digitsOfInt (abs n)", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitalRoot n = \nlet rec recursive_loop retVal = \nif retVal < 10 then retVal\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> recursive_loop n", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec listReverse l = \n(* define helper function to add elements in opposite order to list *)\nlet rec reverseList element = function\n| [] -> element\n| head::tail -> reverseList (head::element) tail in\nreverseList[] l", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec listReverse l = \n(* define helper function to add elements in opposite order to list *)\nlet rec reverseList element = function\n(* IF the empty list, return that, else recurse with head and tail*)\n| [] -> element\n| head::tail -> reverseList (head::element) tail in\nreverseList[] l", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs =\nmatch xs with\n(* If the empty list, return 0 *)\n| []  -> 0\n| x::xs' ->x + sumList xs'", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse\ndigitalRoot (sumList (digits n))", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse\ndigitalRoot (sumList (digits n))", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec additivePersistence n = \n(* If your number is less than 10 then just return 0 *)\nif n < 10 then 0\nelse\n(* recursively call AP on the sum of your int list and keep adding\non 1 to keep track of how many times you've added/recursed*)\n1 + additivePersistence (sumList (digits n ))", "min": "", "type": ""}]}
{"event": "eval", "ocaml": [{"out": "", "in": "let rec sumList xs =\nmatch xs with\n(* If the empty list, return 0 *)\n| []  -> 0\n| x::xs' ->x + sumList xs'", "min": "", "type": ""}]}
