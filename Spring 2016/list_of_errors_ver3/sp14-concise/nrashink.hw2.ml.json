{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (2)\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then 0 else 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (h :: seen) in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 113-116:\n  let seen' = if (mem h l) then (h :: seen) in\n                  ^^^\nError: Unbound value mem\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if mem h l then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (mem h l) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 113-116:\n  let seen' = if (not l.mem h ) then (h :: seen) in\n                  ^^^\nError: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not l.mem h then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 119-122:\n  let seen' = if not (l.mem h ) then (h :: seen) in\n                        ^^^\nError: Unbound record field mem\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (l.mem h) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if not (l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 116-119:\n  let seen' = if !(l.mem h ) then (h :: seen) in\n                     ^^^\nError: Unbound record field mem\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(l.mem h) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 113-130:\n  let seen' = if !(List.mem h seen) then (h :: seen) in\n                  ^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a ref\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 114-122:\n  let seen' = if (!List.mem h seen) then (h :: seen) in\n                   ^^^^^^^^\nError: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 114-131:\n  let seen' = if (!(List.mem h seen)) then (h :: seen) in\n                   ^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a ref\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!(List.mem h seen)) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 138-140:\n  let seen' = if (List.mem h seen) then (h :: seen) in\n                                           ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 137-139:\n  let seen' = if (List.mem h seen) then (h::seen) in\n                                          ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 137-139:\n  let seen' = if (List.mem h seen) then (h::[]) in\n                                          ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::[]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 135-141:\n  let seen' = if (List.mem h seen) then (seen) in\n                                        ^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 137-139:\n  let seen' = if (List.mem h seen) then (h::seen) in\n                                          ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 136-138:\n  let seen' = if (List.mem h seen) then ([]) in\n                                         ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 137-139:\n  let seen' = if (List.mem h seen) then ([2]) in\n                                          ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [2] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([2]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 138-140:\n  if (List.mem h seen) then (h::seen) in\n                              ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 113-130:\n  let seen' = if !(List.mem h seen) then (h::seen) else seen in\n                  ^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a ref\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 114-122:\n  let seen' = if (!List.mem h seen) then (h::seen) else seen in\n                   ^^^^^^^^\nError: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (int, bool) -> 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if (b) then wwhile (f, a) else a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f with\n| (a, b) -> if (b) then wwhile (f, b) else a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if (b) then wwhile (f, b) else a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if (b) then wwhile (f, a) else a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if not(b) then a else wwhile (f, a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if not(b) then a else wwhile (f, a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 47-48:\n  let fixpoint (f,b) = wwhile ((fixpoint (f, b)),b);;\n                                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fixpoint (f, b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 29-43:\n  let fixpoint (f,b) = wwhile ((fixpoint f,b),b);;\n                               ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (((fixpoint f), b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fixpoint f,b),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-32:\n  let fixpoint (f,b) = wwhile (b,b);;\n                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "in": "let fixpoint (f,b) = wwhile (b,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-32:\n  let fixpoint (f,b) = wwhile (b,b);;\n                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "in": "let fixpoint (f,b) = wwhile (b,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-34:\n  let fixpoint (f,b) = wwhile (f,f b);;\n                                 ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = wwhile (f,f b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 32-33:\n  let fixpoint (f,b) = wwhile ((f a),b);;\n                                  ^\nError: Unbound value a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f a), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f a),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f ),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 46-47:\n  let fixpoint (f,b) = wwhile ((fixpoint (f,b)),b);;\n                                                ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fixpoint (f,b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 53-54:\n  let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f b, b),b));;\n                                                       ^\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint ((f b), b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f b, b),b))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 53-54:\n  let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f,f b),b));;\n                                                       ^\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, (f b))), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f,f b),b))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 53-54:\n  let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,f b),b)));;\n                                                       ^\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, (f b))), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,f b),b)))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 53-54:\n  let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b))));;\n                                                       ^\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (not (f b)) = b then b else fixpoint (f, b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b))))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 53-54:\n  let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)));;\n                                                       ^\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 53-54:\n  let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)));;\n                                                       ^\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a ->\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 67-68:\n  let fixpoint (f,b) = wwhile (if ((f b) = b) then b else (fixpoint (f,b),b));;\n                                                                     ^\nError: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a ->\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool \n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((fixpoint (f, b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b else (fixpoint (f,b),b))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-65:\n  let fixpoint (f,b) = wwhile (if ((f b) = b) then b else wwhile (f,f b));;\n                                                                  ^\nError: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         (('a -> 'a * bool) * 'a) * bool \n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else wwhile (f, (f b)));;\n", "in": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b else wwhile (f,f b))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-53:\n  let fixpoint (f,b) = wwhile (if ((f b) = b) then b, b);;\n                                                   ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (b, b));;\n", "in": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b, b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-52:\n  let fixpoint (f,b) = wwhile ((if ((f b) = b) then b), b);;\n                               ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((if ((f b) = b) then b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-54:\n  let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b), b);;\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b);;\n                                                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-64:\n  let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), a);;\n                                                                 ^\nError: Unbound value a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), a);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), a)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b);;\n                                                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b);;\n                                                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-61:\n  let fixpoint (f,b) = wwhile (f (if ((f b) = b) then 1 else 0), b);;\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then 1 else 0)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then 1 else 0), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-59:\n  let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b));;\n                                                   ^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x = f x in ((x, (x = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-40:\n  let fixpoint (f,b) = wwhile ((fun x -> x ), b);;\n                                         ^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> x), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun x -> x ), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-55:\n  | VarX -> sprintf \"%s\" VarX;;\n            ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> sprintf \"%s\" VarX"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-55:\n  | VarX -> sprintf \"%s\";;\n            ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> sprintf \"%s\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-54:\n  | VarX -> printf \"%s\";;\n            ^^^^^^\nError: Unbound value printf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> printf \"%s\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> printf \"%s\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-46:\n  | VarX a -> sprintf \"%s\" a;;\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX a -> sprintf \"%s\" a;;\n", "in": "let rec exprToString e = match e with\n| VarX a -> sprintf \"%s\" a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-46:\n  | VarX a -> sprintf \"%s\" a;;\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX a -> sprintf \"%s\" a;;\n", "in": "let rec exprToString e = match e with\n| VarX a -> sprintf \"%s\" a"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-57:\n  | Sine s -> sprintf \"%s\" s;;\n              ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> sprintf \"%s\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> sprintf \"%s\" s"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-56:\n  | Sine s -> printf \"%s\" s;;\n              ^^^^^^\nError: Unbound value printf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> printf \"%s\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> printf \"%s\" s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-70:\n  | Sine s -> Format.printf \"%s\" s;;\n                                 ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.printf \"%s\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.printf \"%s\" s"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-71:\n  | VarX -> Format.printf \"%s\" VarX;;\n                               ^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%s\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"%s\" VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-69:\n  | VarX -> Format.printf \"%VarX\" VarX;;\n                          ^^^^^^^\nError: invalid format \"%VarX\": at character number 1, invalid conversion \"%V\"\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%VarX\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"%VarX\" VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-66:\n  | VarX -> Format.printf VarX;;\n                          ^^^^\nError: This variant expression is expected to have type\n         ('a, Format.formatter, unit) format\n       The constructor VarX does not belong to type CamlinternalFormatBasics.format6\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf VarX"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-60:\n  | VarX -> Format.print VarX;;\n            ^^^^^^^^^^^^\nError: Unbound value Format.print\nHint: Did you mean printf?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.print VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.print VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-74:\n  | VarX -> Format.printf \"%expr\" VarX;;\n                                  ^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%expr\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"%expr\" VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-75:\n  | VarX -> Format.printf \"%float\" VarX;;\n                                   ^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%float\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"%float\" VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-76:\n  | VarX -> Format.sprintf \"%float\" VarX;;\n                                    ^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.sprintf \"%float\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.sprintf \"%float\" VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-77:\n  | Sine s -> Format.sprintf \"%expr\" Sine;;\n                                     ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" Sine;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%expr\" Sine"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-74:\n  | Sine s -> Format.sprintf \"%expr\" s;;\n                                     ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%expr\" s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-74:\n  | Sine s -> Format.sprintf \"%expr\" s;;\n                                     ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%expr\" s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 76-81:\n  | Sine s -> Format.sprintf \"%d\" (sin (3.142 * e));;\n                                        ^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3.142 * e));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-81:\n  | Sine s -> Format.sprintf \"%d\" (sin (3 * e));;\n                                            ^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * e));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-82:\n  | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n                                       ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 76-79:\n  | Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0));;\n                                        ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-83:\n  | Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0));;\n                                            ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-82:\n  | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n                                       ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-82:\n  | Sine s -> Format.sprintf \"%i\" (sin (3 * 2));;\n                                       ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%i\" (sin (3 * 2));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 76-79:\n  | Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0));;\n                                        ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 90-91:\n  | Sine s -> \"sin(pi*\" ^ s ^ \")\";;\n                          ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ (s ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ s ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 113-114:\n  | Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" s ^ \")\";;\n                                                 ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%expr\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" s ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" 1.0 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 105-109:\n  | Sine s -> \"sin(pi*\" ^ Format.sprintf \"%_\" s  ^ \")\";;\n                                         ^^^^\nError: invalid format \"%_\": at character number 2, unexpected end of format\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%_\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%_\" s  ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 105-108:\n  | Sine s -> \"sin(pi*\" ^ Format.sprintf \"%\" s  ^ \")\";;\n                                         ^^^\nError: invalid format \"%\": at character number 1, unexpected end of format\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%\" s  ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 104-107:\n  | Sine s -> \"sin(pi*\" ^ Format.printf \"%\" s  ^ \")\";;\n                                        ^^^\nError: invalid format \"%\": at character number 1, unexpected end of format\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%\" s  ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-110:\n  | Sine s -> \"sin(pi*\" ^ Format.printf \"%f\" s  ^ \")\";;\n                                             ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%f\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%f\" s  ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-110:\n  | Sine s -> \"sin(pi*\" ^ Format.printf \"%i\" s  ^ \")\";;\n                                             ^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%i\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%i\" s  ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 112-113:\n  | Sine s -> \"sin(pi*\" ^ Format.printf \"%expr\" s  ^ \")\";;\n                                                ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%expr\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%expr\" s  ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-110:\n  | Sine s -> \"sin(pi*\" ^ Format.printf \"%e\" s  ^ \")\";;\n                                             ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%e\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%e\" s  ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2)\n| Thresh (h1,h2,h3,h4) -> \"(\" ^ (exprToString h1) ^ \"<\" ^ (exprToString h2) ^ \" ? \" ^ (exprToString h3) ^ \" : \" ^ (exprToString h4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2)\n| Thresh (h1,h2,h3,h4) -> \"(\" ^ (exprToString h1) ^ \"<\" ^ (exprToString h2) ^ \n\" ? \" ^ (exprToString h3) ^ \" : \" ^ (exprToString h4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2)\n| Thresh (h1,h2,h3,h4) -> \"(\" ^ (exprToString h1) ^ \"<\" ^ (exprToString h2) ^ \n\"?\" ^ (exprToString h3) ^ \":\" ^ (exprToString h4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 24-27:\n  let mine = buildAverage(2.0, 4.0);;\n                          ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (2.0, 4.0);;\n", "in": "let mine = buildAverage(2.0, 4.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let mine = buildAverage(VarX, VarY)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let mine = buildAverage(VarX, VarY)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-100:\n  | Average -> buildAverage(vx,vy);;\n    ^^^^^^^\nError: The constructor Average expects 2 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> let vx = x in vx\n  | VarY  -> let vy = y in vy\n  | Average  -> buildAverage (vx, vy);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in vx \n| VarY -> let vy = y in vy\n| Average -> buildAverage(vx,vy)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-114:\n  | Average (a1,a2) -> buildAverage(a1,a2);;\n                       ^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> buildAverage(a1,a2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-114:\n  | Average (a1,a2) -> buildAverage(a1,a2);;\n                       ^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> buildAverage(a1,a2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 107-109:\n  | Average (a1,a2) -> (eval (VarX,a1,a2));;\n                                   ^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> eval (VarX, a1, a2);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval (VarX,a1,a2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-98:\n  | Average (a1,a2) -> (a1 + a2);;\n                        ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> a1 + a2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (a1 + a2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 106-108:\n  | Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2));;\n                                  ^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, a1, a2)) + (eval (VarY, a1, a2));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-110:\n  | Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2));;\n                        ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) + (eval (VarY, a1, a2));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 124-126:\n  | Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2));;\n                                                    ^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, a1, a2));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 92-96:\n  | Sine (s1) -> sin(s1)\n                    ^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin s1\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (e,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 167-197:\n  | Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0;;\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = failwith \"to be implemented\";;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Cosine c1 -> cos (eval (c1, x, y))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) / 2.0;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 199-200:\n  | Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2;;\n                                                       ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = failwith \"to be implemented\";;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Cosine c1 -> cos (eval (c1, x, y))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval(s1,x,y))\n| Cosine (c1) -> cos (eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) -> if (eval(h1,x,y) < eval(h2,x,y)) then eval(h3,x,y) else eval(h4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = rand (1,4)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 7-11:\n  build (rand, 4);;\n         ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\nlet rec build (rand,depth) = rand (1, 4);;\n\nlet _ = build (rand, 4);;\n", "in": "build (rand, 4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "build (makeRand (10,39), 4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = rand (1,4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = rand (1,7)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> 1\n| 2 -> 2\n| 3 -> 3\n| 4 -> 4\n| 5 -> 5\n| 6 -> 6\n| 7 -> 7"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "build (makeRand (10,39), 4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> 11\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  | 2 -> 22\n         ^^\nError: This expression has type int but an expression was expected of type\n         expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> VarX\n  | 2 -> 22\n  | 3 -> 33\n  | 4 -> 44\n  | 5 -> 55\n  | 6 -> 66\n  | 7 -> 77;;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-77:\n  | 1 -> buildX(buildY())\n               ^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX (buildY ())\n  | 2 -> buildY ()\n  | 3 -> buildX ()\n  | 4 -> buildY ()\n  | 5 -> buildX ()\n  | 6 -> buildY ()\n  | 7 -> buildX ();;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildSine(buildX())\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))\n| 1 -> buildSine(buildX())\n| 2 -> buildSine(buildX())\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))\n| 1 -> buildSine(buildX())\n| 2 -> buildSine(buildX())\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine()\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 188-190:\n  | 3 -> buildSine()\n                  ^^\nError: This variant expression is expected to have type expr\n       The constructor () does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ ->\n      buildTimes\n        ((buildCosine (buildSine (buildX ()))),\n          (buildCosine (buildSine (buildX ()))))\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 -> buildSine ()\n  | 4 -> buildSine (buildX ())\n  | 5 -> buildSine (buildX ())\n  | 6 -> buildSine (buildX ())\n  | 7 -> buildSine (buildX ());;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(build(rand, depth))\n| 4 -> buildCosine(build(rand, depth))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine(build(rand, depth))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( if (depth = 0) then buildX() else build(rand, depth - 1), if (depth = 0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 282-290:\n  | 5 -> buildAverage ( if (depth = 0) then buildX() else build(rand, depth - 1), if (depth = 0) then buildY() else build(rand, depth - 1))\n                                            ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        (if depth = 0\n         then buildX ()\n         else\n           ((build (rand, (depth - 1))),\n             (if depth = 0 then buildY () else build (rand, (depth - 1)))))\n  | 6 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n  | 7 ->\n      buildThresh\n        ((build (rand, depth)), (build (rand, depth)), (build (rand, depth)),\n          (build (rand, depth)));;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), if (depth = 0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ( (if (depth = 0) then buildX() else build(rand, depth)), (if (depth = 0) then buildY() else build(rand, depth)))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> Format.printf \"%f\" rand(1,7)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-79:\n  | _ -> Format.printf \"%f\" rand(1,7)\n                       ^^^^\nError: This expression has type\n         ('a -> 'b, Format.formatter, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> Format.printf \"%f\" rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-86:\n  | 1 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildX()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildY()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine (VarX, VarY)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine(VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildSine(VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine(Average(VarX,VarY))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine(VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) -> if (eval(h1,x,y) < eval(h2,x,y)) then eval(h3,x,y) else eval(h4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildAverage(VarX,VarY)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX,VarY)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-78:\n  | _ -> buildTimes (VarX)\n                    ^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildTimes VarX\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let myexpr = Cosine (VarX)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand (1,5)) with\n| 1 -> buildX()\n| 2 -> buildX()\n| 3 -> buildX()\n| 4 -> buildX()\n| 5 -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,6)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,6)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,6)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,6)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,5)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,4)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1) * buildY())\n| 2 -> buildCosine(build(rand, depth - 1) * buildX())\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 152-174:\n  | 1 -> buildSine(build(rand, depth - 1) * buildY())\n                   ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 5) with\n     | 1 -> buildSine ((build (rand, (depth - 1))) * (buildY ()))\n     | 2 -> buildCosine ((build (rand, (depth - 1))) * (buildX ()))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}, {"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Divide3   of expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,7)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildDivide3(build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildMyOp(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f 3, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-57:\n  wwhile (f 3, 2);;\n          ^^^\nError: This expression has type int * bool\n       but an expression was expected of type 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet _ =\n  let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile ((f 3), 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-1:\n  f 2;;\n  ^\nError: Unbound value f\n", "min": "\nlet _ = f 2;;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-1:\n  f 2;;\n  ^\nError: Unbound value f\n", "min": "\nlet _ = f 2;;\n", "in": "let fixpoint (f,b) = wwhile ((f,b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile ((f,b), b);;\n                               ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f,b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile ((f,b), b);;\n                               ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-71:\n  let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b));;\n                                                                      ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, (f b)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-73:\n  let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, (f b)));;\n                                                                      ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, wwhile (f,b)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (let f x =  in f), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != 100)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != 100)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != 100)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = x*x*x in (xx, xx != 100)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != f x)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != f x)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != f x)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-69:\n  wwhile (f, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let f x = let x = b in (x, (x != (f x))) in wwhile (f, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet h x = let x = b in (x, x != f x)  in\nwwhile (h, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-69:\n  wwhile (h, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let h x = let x = b in (x, (x != (f x))) in wwhile (h, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-56:\n  wwhile (h, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let h x = (b, (b != (f b))) in wwhile (h, b);;\n", "in": "let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-56:\n  wwhile (h, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let h x = (b, (b != (f b))) in wwhile (h, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet h b = (b, b != f b)  in\nwwhile (h, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-56:\n  wwhile (h, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let h b = (b, (b != (f b))) in wwhile (h, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (h, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-56:\n  wwhile (h, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let f x = (x, (x != (f x))) in wwhile (h, b);;\n", "in": "let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-56:\n  wwhile (f, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let f x = (x, (x != (f x))) in wwhile (f, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 68-74:\n  wwhile (f, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, x)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 68-74:\n  wwhile (f, x);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, x);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 68-74:\n  wwhile (f, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 68-74:\n  wwhile (f, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (g, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 68-74:\n  wwhile (g, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 68-74:\n  wwhile (f, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let f x = let xx = f x in (xx, (xx != x)) in wwhile (f, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nlet a x = let xx = (f x) in (xx, xx != x)  in\nwwhile (a, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 68-74:\n  wwhile (a, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let a x = let xx = f x in (xx, (xx != x)) in wwhile (a, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"}]}
