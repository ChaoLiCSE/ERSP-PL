{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 121-126:\n  let seen' = if List.mem h seen' then seen' else h::seen' in\n                            ^^^^^\nError: Unbound value seen'\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen' then seen' else h :: seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h::seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f b with (num,boo)-> \nif boo then wwhile (f,num)\nelse num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true) ),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (((if ((f x)= x) then (x,false) else (f x,true))),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((if (f x) = x then (x, false) else ((f x), true)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func x),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func x),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func x = if (f x) = x then (x, false) else ((f x), true) in func x),\n      b);;\n", "in": "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func x = if (f x) = x then (x, false) else ((f x), true) in func),\n      b);;\n", "in": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average ex1 ex2 -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times ex1 ex2 -> ex1^\"*\"^ex2\n| Thresh ex1 ex2 ex3 ex4 -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 250-253:\n  | Times (ex1,ex2) -> ex1^\"*\"^ex2\n                       ^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> ex1 ^ (\"*\" ^ ex2)\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-77:\n  | Sine ex -> sin(pi* exprToString ex )\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (exprToString ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. exprToString ex )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-95:\n  | Sine ex -> sin(pi*. exprToString ex )\n                        ^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (exprToString ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. eval ex )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-87:\n  | Sine ex -> sin(pi*. eval ex )\n                             ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-87:\n  | Sine ex -> sin(pi*. eval ex x y )\n                             ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-86:\n  | Sine ex -> sin(pi*.eval ex x y )\n                            ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-86:\n  | Sine ex -> sin(pi*.eval ex x y );;\n                            ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-86:\n  | Sine ex -> sin(pi*.eval ex x y );;\n                            ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-86:\n  | Sine ex -> sin(pi*.eval ex x y );;\n                            ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex x y) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-87:\n  | Sine ex -> sin(pi*.eval (ex x y) );;\n                             ^^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex x y)));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-141:\n  | Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 158-207:\n  | Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((exprToString (ex1,x,y)+.exprToString (ex2,x,y))/.2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 173-182:\n  | Average (ex1,ex2) -> ((exprToString (ex1,x,y)+.exprToString (ex2,x,y))/.2)\n                                        ^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) ->\n      ((exprToString (ex1, x, y)) +. (exprToString (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 193-194:\n  | Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2)\n                                                            ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 159-191:\n  | Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/2)\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 218-255:\n  | Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 218-232:\n  | Times (ex1,ex2) -> eval (ex1,x,y)*eval (ex2,x,y)\n                       ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 279-367:\n  | Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\";;\n                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y) ? eval (ex3,x,y): eval (ex4,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": " rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) \nelse let case = rand(0,6)in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-139:\n  | 0 -> buildX\n         ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type bool\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX\n     | 1 -> buildY\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-141:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         bool\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-124:\n  | 0 -> buildX\n         ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-124:\n  | 0 -> buildX\n         ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-124:\n  | 0 -> buildX\n         ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-126:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-126:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-126:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> VarX\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-122:\n  | 0 -> VarX\n         ^^^^\nError: This variant expression is expected to have type unit\n       The constructor VarX does not belong to type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> VarX\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-126:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = let case = rand(0,6) in \nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = let case = rand(0,6)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,7) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,3) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 212-216:\n  ffor (-n, n, \n  ^^^^\nError: Unbound value ffor\n", "min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| FiboPlus   of expr * expr * expr * expr * expr\n| TheThing   of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This expression has type expr/1401\n       but an expression was expected of type expr/1214\nError: This expression has type string but an expression was expected of type\n         int\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 402-405:\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((exprToString ex1)*(exprToString ex1+exprToString ex2)*(exprToString ex1+exprToString ex2+exprToString ex3)*(exprToString ex1+exprToString ex2+exprToString ex3+exprToString ex4)*(exprToString ex1+exprToString ex2+exprToString ex3+exprToString ex4+exprToString ex5));;\n                                                     ^^^\nError: This expression has type expr/1401\n       but an expression was expected of type expr/1214\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((exprToString ex1) * ((exprToString ex1) + (exprToString ex2))) *\n          (((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)))\n         *\n         ((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4)))\n        *\n        (((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4))\n           + (exprToString ex5));;\n", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> \"((\"^exprToString ex1^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\"+\"^exprToString ex5^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 388-406:\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((exprToString ex1)*(exprToString ex1+exprToString ex2)*(exprToString ex1+exprToString ex2+exprToString ex3)*(exprToString ex1+exprToString ex2+exprToString ex3+exprToString ex4)*(exprToString ex1+exprToString ex2+exprToString ex3+exprToString ex4+exprToString ex5));;\n                                       ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((exprToString ex1) * ((exprToString ex1) + (exprToString ex2))) *\n          (((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)))\n         *\n         ((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4)))\n        *\n        (((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4))\n           + (exprToString ex5));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval ex1)*(eval ex1+eval ex2)*(eval ex1+eval ex2+eval ex3)*(eval ex1+eval ex2+eval ex3+eval ex4)*(eval ex1+eval ex2+eval ex3+eval ex4+eval ex5))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 394-397:\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval ex1)*(eval ex1+eval ex2)*(eval ex1+eval ex2+eval ex3)*(eval ex1+eval ex2+eval ex3+eval ex4)*(eval ex1+eval ex2+eval ex3+eval ex4+eval ex5));;\n                                             ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval ex1) * ((eval ex1) + (eval ex2))) *\n          (((eval ex1) + (eval ex2)) + (eval ex3)))\n         * ((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)))\n        *\n        (((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)) + (eval ex5));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval ex1)*.(eval ex1+eval ex2)*(eval ex1+eval ex2+eval ex3)*(eval ex1+eval ex2+eval ex3+eval ex4)*(eval ex1+eval ex2+eval ex3+eval ex4+eval ex5))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 394-397:\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval ex1)*.(eval ex1+eval ex2)*(eval ex1+eval ex2+eval ex3)*(eval ex1+eval ex2+eval ex3+eval ex4)*(eval ex1+eval ex2+eval ex3+eval ex4+eval ex5));;\n                                             ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval ex1) *. ((eval ex1) + (eval ex2))) *\n          (((eval ex1) + (eval ex2)) + (eval ex3)))\n         * ((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)))\n        *\n        (((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)) + (eval ex5));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval ex1)*.(eval ex1+eval ex2)*(eval ex1+eval ex2+eval ex3)*(eval ex1+eval ex2+eval ex3+eval ex4)*(eval ex1+eval ex2+eval ex3+eval ex4+eval ex5))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 394-397:\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval ex1)*.(eval ex1+eval ex2)*(eval ex1+eval ex2+eval ex3)*(eval ex1+eval ex2+eval ex3+eval ex4)*(eval ex1+eval ex2+eval ex3+eval ex4+eval ex5));;\n                                             ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval ex1) *. ((eval ex1) + (eval ex2))) *\n          (((eval ex1) + (eval ex2)) + (eval ex3)))\n         * ((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)))\n        *\n        (((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)) + (eval ex5));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+eval (ex2,x,y))*(eval (ex1,x,y)+eval (ex2,x,y)+eval (ex3,x,y))*(eval (ex1,x,y)+eval (ex2,x,y)+eval (ex3,x,y)+eval (ex4,x,y))*(eval (ex1,x,y)+eval (ex2,x,y)+eval (ex3,x,y)+eval (ex4,x,y)+eval (ex5,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 407-421:\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+eval (ex2,x,y))*(eval (ex1,x,y)+eval (ex2,x,y)+eval (ex3,x,y))*(eval (ex1,x,y)+eval (ex2,x,y)+eval (ex3,x,y)+eval (ex4,x,y))*(eval (ex1,x,y)+eval (ex2,x,y)+eval (ex3,x,y)+eval (ex4,x,y)+eval (ex5,x,y)));;\n                                                          ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) + (eval (ex2, x, y)))) *\n          (((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))))\n         *\n         ((((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))) +\n            (eval (ex4, x, y))))\n        *\n        (((((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))) +\n            (eval (ex4, x, y)))\n           + (eval (ex5, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,7) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildFiboPlus(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> \"((\"^exprToString ex1^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\"+\"^exprToString ex5^\"))\"\n| TheThing (ex1,ex2,ex3) -> \"(\"^exprToString ex1^\"*sin(\"^exprToString ex2^\")*cos(\"exprToString ex3^\")\"\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 846-854:\n  | TheThing (ex1,ex2,ex3) -> \"(\"^exprToString ex1^\"*sin(\"^exprToString ex2^\")*cos(\"exprToString ex3^\")\"\")\";;\n                                                                            ^^^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"*sin(\" ^\n              ((exprToString ex2) ^ ((\")*cos(\" exprToString ex3) ^ (\")\" \")\")))));;\n", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> \"((\"^exprToString ex1^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\"+\"^exprToString ex5^\"))\"\n| TheThing (ex1,ex2,ex3) -> \"(\"^exprToString ex1^\"*sin(\"^exprToString ex2^\")*cos(\"^exprToString ex3^\")\"\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 872-875:\n  | TheThing (ex1,ex2,ex3) -> \"(\"^exprToString ex1^\"*sin(\"^exprToString ex2^\")*cos(\"^exprToString ex3^\")\"\")\";;\n                                                                                                      ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"*sin(\" ^\n              ((exprToString ex2) ^\n                 (\")*cos(\" ^ ((exprToString ex3) ^ (\")\" \")\"))))));;\n", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> \"((\"^exprToString ex1^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\"+\"^exprToString ex5^\"))\"\n| TheThing (ex1,ex2,ex3) -> \"(\"^exprToString ex1^\"*sin(\"^exprToString ex2^\")*cos(\"^exprToString ex3^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> \"((\"^exprToString ex1^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\"+\"^exprToString ex5^\"))\"\n| TheThing (ex1,ex2,ex3) -> \"((\"^exprToString ex1^\"*sin(pi*\"^exprToString ex2^\")*cos(pi*\"^exprToString ex3^\"))/2)\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 668-682:\n  | TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*sin(pi* eval (ex2,x,y))*cos(pi* eval (ex3,x,y)))/2);;\n                                ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n          (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y))))\n         *.\n         ((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y))))\n        *.\n        (((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y)))\n           +. (eval (ex5, x, y)))\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) * (sin (pi * (eval (ex2, x, y))))) *\n         (cos (pi * (eval (ex3, x, y)))))\n        / 2;;\n", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| FiboPlus   of expr * expr * expr \n| TheThing   of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 409-439:\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) -> \"((\"^exprToString ex1^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"))\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: The constructor FiboPlus expects 3 argument(s),\n       but is applied here to 5 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^ ((exprToString ex3) ^ \"))\")))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\"*sin(pi*\" ^\n              ((exprToString ex2) ^\n                 (\")*cos(pi*\" ^ ((exprToString ex3) ^ \"))/2)\")))));;\n", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| FiboPlus (ex1,ex2,ex3) -> \"((\"^exprToString ex1^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"))\"\n| TheThing (ex1,ex2,ex3) -> \"((\"^exprToString ex1^\"*sin(pi*\"^exprToString ex2^\")*cos(pi*\"^exprToString ex3^\"))/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SixtyNine of expr * expr \n| TheThing   of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 428-450:\n  | 7 -> buildFiboPlus(build (rand,depth-1))\n                      ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFiboPlus (e1,e2) = FiboPlus (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 -> buildFiboPlus (build (rand, (depth - 1)))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SixtyNine of expr\n| TheThing   of expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| SixtyNine (ex1) -> \"((\"^exprToString ex1^\"*69))\"\n| TheThing (ex1,ex2,ex3) -> \"(\"^exprToString ex3^\"=\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex1^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 428-450:\n  | 7 -> buildFiboPlus(build (rand,depth-1))\n                      ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFiboPlus (e1,e2) = FiboPlus (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 -> buildFiboPlus (build (rand, (depth - 1)))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,8) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildSixtyNine(build (rand,depth-1))\n| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,8) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildSixtyNine(build (rand,depth-1))\n| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| SixtyNine (ex1) -> \"((\"^exprToString ex1^\"*69))\"\n| TheThing (ex1,ex2,ex3) -> \"((\"^exprToString ex1^\"*sin(pi*\"^exprToString ex2^\")*cos(pi*\"^exprToString ex3^\"))/.2.)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| SixtyNine (ex1) -> \"((\"^exprToString ex1^\"*69))\"\n| TheThing (ex1,ex2,ex3) -> \"((\"^exprToString ex1^\"*sin(pi*\"^exprToString ex2^\")*cos(pi*\"^exprToString ex3^\"))/.2.)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| SixtyNine (ex1) -> \"((\"^exprToString ex1^\"*69))\"\n| TheThing (ex1,ex2,ex3) -> \"((\"^exprToString ex1^\"*sin(pi*\"^exprToString ex2^\")*cos(pi*\"^exprToString ex3^\"))/.2.)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)"}]}
