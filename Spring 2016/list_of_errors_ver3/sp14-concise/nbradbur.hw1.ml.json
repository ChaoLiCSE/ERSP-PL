{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| x::xs -> listReverse xs @ [x]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet l = [] in\nlet m = n mod 10 in\nmatch m with\n| n -> n::l\n| _ -> n::digitsOfInt (n/10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  let l = [] in\n  let m = n mod 10 in\n  match m with | n -> n :: l | _ -> n :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n<0 then []", "out": "Characters 36-38:\n  if n<0 then [];;\n              ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet l = [] in\nif n<0 then l", "out": "Characters 50-51:\n  if n<0 then l;;\n              ^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet rec digitsOfInt n = let l = [] in if n < 0 then l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet l = [] in\nif n<0 then l else l", "out": "", "min": "\nlet rec digitsOfInt n = let l = [] in if n < 0 then l else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet l = [] in\nif n<0 then l else digitsHelper n l", "out": "Characters 53-65:\n  if n<0 then l else digitsHelper n l;;\n                     ^^^^^^^^^^^^\nError: Unbound value digitsHelper\n", "min": "\nlet digitsOfInt n = let l = [] in if n < 0 then l else digitsHelper n l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet l = [] in\nif n<0 then l else digitsHelper n l", "out": "", "min": "\nlet rec digitsHelper n l =\n  if (n mod 10) = n then [] else digitsHelper (n / 10) ((n mod 10) :: l);;\n\nlet digitsOfInt n = let l = [] in if n < 0 then l else digitsHelper n l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet l = [] in\nif n<0 then l else digitsHelper n l", "out": "", "min": "\nlet rec digitsHelper n l =\n  if (n mod 10) = n then [] else digitsHelper (n / 10) ((n mod 10) :: l);;\n\nlet digitsOfInt n = let l = [] in if n < 0 then l else digitsHelper n l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet l = [] in\nif n<0 then l else digitsHelper n l", "out": "", "min": "\nlet rec digitsHelper n l =\n  if n < 10 then n :: l else digitsHelper (n / 10) ((n mod 10) :: l);;\n\nlet digitsOfInt n = let l = [] in if n < 0 then l else digitsHelper n l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet l = [] in\nif n<0 then l else digitsHelper n l", "out": "", "min": "\nlet rec digitsHelper n l =\n  if n < 10 then n :: l else digitsHelper (n / 10) ((n mod 10) :: l);;\n\nlet digitsOfInt n = let l = [] in if n < 0 then l else digitsHelper n l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =\nlet l = digitsOfInt n in\nlet x = sumList l in\nif x = n then x else digitalRoot x", "out": "Characters 57-64:\n  let x = sumList l in\n          ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitsHelper n l =\n  if n < 10 then n :: l else digitsHelper (n / 10) ((n mod 10) :: l);;\n\nlet digitsOfInt n = let l = [] in if n < 0 then l else digitsHelper n l;;\n\nlet rec digitalRoot n =\n  let l = digitsOfInt n in\n  let x = sumList l in if x = n then x else digitalRoot x;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| x::xs -> listReverse xs @ [x]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet normal = explode w in\nlet reverse = listReverse (explode w) in\npalinHelper normal reverse", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n\nlet rec palinHelper normal reverse =\n  match normal with\n  | [] -> true\n  | x::xs ->\n      if x = (List.hd reverse)\n      then palinHelper xs (List.tl reverse)\n      else false;;\n\nlet palindrome w =\n  let normal = explode w in\n  let reverse = listReverse (explode w) in palinHelper normal reverse;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "type": ""}]}
