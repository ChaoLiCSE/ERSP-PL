{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 131-135:\n  seem\n  ^^^^\nError: Unbound value seem\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seem else h :: seem in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseem\nelse\nh::seem\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 53-57:\n  if y = true \n         ^^^^\nError: This expression has type bool but an expression was expected of type\n         int\n", "min": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if y = true then wwhile (f, x) else x;;\n", "in": "let rec wwhile (f,b) = \nlet f(b) = (x, y) in \nif y = true \nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 53-57:\n  if x = true \n         ^^^^\nError: This expression has type bool but an expression was expected of type\n         string\n", "min": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if x = true then wwhile (f, x) else x;;\n", "in": "let rec wwhile (f,b) = \nlet f(b) = (x, y) in \nif x = true \nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 36-38:\n  let f(b) = (b', c') in \n              ^^\nError: Unbound value b'\n", "min": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (b', c') in if c' = true then wwhile (f, b') else x;;\n", "in": "let rec wwhile (f,b) = \nlet f(b) = (b', c') in \nif c' = true \nthen wwhile (f, b')\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 35-37:\n  let f(b) = b', c' in \n             ^^\nError: Unbound value b'\n", "min": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (b', c') in if c' = true then wwhile (f, b') else x;;\n", "in": "let rec wwhile (f,b) = \nlet f(b) = b', c' in \nif c' = true \nthen wwhile (f, b')\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 34-36:\n  let f b = b', c' in \n            ^^\nError: Unbound value b'\n", "min": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (b', c') in if c' = true then wwhile (f, b') else x;;\n", "in": "let rec wwhile (f,b) = \nlet f b = b', c' in \nif c' = true \nthen wwhile (f, b')\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 34-35:\n  let f b = q, x in \n            ^\nError: Unbound value q\n", "min": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (q, x) in if c' = true then wwhile (f, b') else x;;\n", "in": "let rec wwhile (f,b) = \nlet f b = q, x in \nif c' = true \nthen wwhile (f, b')\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 34-35:\n  let f b = q, x in  \n            ^\nError: Unbound value q\n", "min": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (q, x) in if c' = true then wwhile (f, b') else x;;\n", "in": "let rec wwhile (f,b) = \nlet f b = q, x in  \nif c' = true \nthen wwhile (f, b')\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 34-35:\n  let f b = w in  \n            ^\nError: Unbound value w\n", "min": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) = let f b = w in if c' = true then wwhile (f, b') else x;;\n", "in": "let rec wwhile (f,b) = \nlet f b = w in  \nif c' = true \nthen wwhile (f, b')\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool -> 'a * bool\n       Type int is not compatible with type bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (a',b') = f b in if b' = true then wwhile (f, b') else a';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet b', c' = f b in  \nif c' = true \nthen wwhile (f, b')\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile (\nf,\nb)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile(f, b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-89:\n  wwhile(f' , b);;\n         ^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f' = if (f b) = b then (b, true) else (b, false) in wwhile (f', b);;\n", "in": "let fixpoint (f,b) = \nlet f' = \nif(f(b) = b)\nthen (b, true)\nelse\n(b, false)\nin \nwwhile(f' , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[]    -> \nseen\n| h::t  -> \nlet seen' =\nif List.mem h seen\nthen\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f, b) = \nif f(b) = b\nthen b\nelse helper(f, f(b))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f, b) = \nif f(b) = b\nthen b\nelse fixpoint(f, f(b))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f, b) = \nif f(b) = b\nthen b\nelse fixpoint(f, f(b))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX  -> \"x\"\n| VarY  -> \"y\"\n| Sine e1 -> \"(\"^ exprToString e1 ^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString Sine(VarX)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-12:\n  exprToString Sine(VarX);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString Sine VarX;;\n", "in": "exprToString (Sine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine e1\t  -> \"(sin\"^ exprToString e1 ^\")\"\n| Cosine e1\t  -> \"(cos\"^exprToString e1 ^ \")\"\n| Average (e1, e2)-> \"(\"^ exprToString e1 ^\"+\" ^ exprToString e2 ^ \")/2\"\n| Times (e1, e2)  -> \"(\"^ exprToString e1 ^\"*\"^exprToString e2 ^\")\"\n| Thresh (e1, e2, e3, e4) -> \"(\"^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \")?(\"^ exprToString e3 ^ \"):(\"^exprToString e4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString (Sine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine e1\t  -> \"sin(pi*\"^ exprToString e1 ^\")\"\n| Cosine e1\t  -> \"cos(pi*\"^exprToString e1 ^ \")\"\n| Average (e1, e2)-> \"((\"^ exprToString e1 ^\"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2)  -> \"\"^ exprToString e1 ^\"*\"^exprToString e2 ^\"\"\n| Thresh (e1, e2, e3, e4) -> \"(\"^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\"^ exprToString e3 ^ \":\"^exprToString e4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString (Sine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> BuildSine(eval(e))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 74-83:\n  | Sine e1 -> BuildSine(eval(e));;\n               ^^^^^^^^^\nError: Unbound constructor BuildSine\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> BuildSine (eval e);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-85:\n  | Sine e1 -> sin(eval(e));;\n                       ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-86:\n  | Sine e1 -> sin(eval(e1));;\n                       ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-85:\n  | Sine e1 -> sin(eval e1);;\n                        ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-85:\n  | Sine e1 -> sin(eval e1);;\n                        ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-92:\n  | Sine e1 -> sin(eval e1, x, y);;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin ((eval e1), x, y);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-168:\n  | Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2);;\n                         ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) + ((eval (e2, x, y)) / 2);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/.2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 188-189:\n  | Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/.2);;\n                                                           ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> (eval(e1, x, y) < eval(e2, x, y) ? eval(e3, x, y) : eval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \n(eval(e1, x, y) < eval(e2, x, y) \nthen\neval(e3, x, y)\nelse\neval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \neval(e1, x, y) < eval(e2, x, y)\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi*eval (e1, x, y))\n| Cosine e1 -> cos(pi*eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \neval(e1, x, y) < eval(e2, x, y)\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi*.eval (e1, x, y))\n| Cosine e1 -> cos(pi*.eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \neval(e1, x, y) < eval(e2, x, y)\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f, b) = \nhelper(f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 \nthen buildX()\nelse\nmatch rand(1,6) with\n| 1 ->  buildSine(build(rand, depth-1))\n| 2 -> buildCosine(build(rand, depth-1))\n| 3 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 4-> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 \nthen buildX()\nelse\nmatch rand(1,6) with\n| 1 ->  buildSine(build(rand, depth-1))\n| 2 -> buildCosine(build(rand, depth-1))\n| 3 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 4-> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 \nthen buildX()\nelse\nmatch rand(1,8) with\n| 1 ->  buildSine(build(rand, depth-1))\n| 2 -> buildCosine(build(rand, depth-1))\n| 3 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 4-> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildX()\n| 7 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 \nthen buildX()\nelse\nmatch rand(1,8) with\n| 1 ->  buildSine(build(rand, depth-1))\n| 2 -> buildCosine(build(rand, depth-1))\n| 3 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 4-> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildX()\n| 7 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Magic    of expr\n| Weird    of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 482-504:\n  | Weird (e1, e2, e3, e4) -> \"(tan(\"^ exprToString e1 ^\"*\"^exprToString e2 ^ \"*\" ^ exprToString e3 ^\"))\";;\n    ^^^^^^^^^^^^^^^^^^^^^^\nError: The constructor Weird expects 3 argument(s),\n       but is applied here to 4 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \"\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Magic e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Weird (e1,e2,e3,e4) ->\n      \"(tan(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n", "in": "exprToString (Sine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 482-504:\n  | Weird (e1, e2, e3, e4) -> \"(tan(\"^ exprToString e1 ^\"*\"^exprToString e2 ^ \"*\" ^ exprToString e3 ^\"))\";;\n    ^^^^^^^^^^^^^^^^^^^^^^\nError: The constructor Weird expects 3 argument(s),\n       but is applied here to 4 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \"\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Magic e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Weird (e1,e2,e3,e4) ->\n      \"(tan(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n", "in": "exprToString (Sine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 482-504:\n  | Weird (e1, e2, e3, e4) -> \"(tan(\"^ exprToString e1 ^\"*\"^exprToString e2 ^ \"*\" ^ exprToString e3 ^\"))\";;\n    ^^^^^^^^^^^^^^^^^^^^^^\nError: The constructor Weird expects 3 argument(s),\n       but is applied here to 4 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \"\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Magic e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Weird (e1,e2,e3,e4) ->\n      \"(tan(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n", "in": "exprToString (Sine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "exprToString (Sine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \neval(e1, x, y) < eval(e2, x, y)\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)\n| Magic e1 -> tan(eval(e1, x, y))\n| Weird (e1, e2, e3) -> \n(tan((eval( e1, x, y))*.(eval(e2, x, y)*.(eval(e3, x, y))*)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 \nthen buildX()\nelse\nmatch rand(1,8) with\n| 1 ->  buildSine(build(rand, depth-1))\n| 2 -> buildCosine(build(rand, depth-1))\n| 3 -> \nbuildAverage(build(rand, depth-1), build(rand, depth-1))\n| 4-> \nbuildTimes(build(rand, depth-1), build(rand, depth-1))\n| 5 -> \nbuildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| 6 -> \nbuildX()\n| 7 -> \nbuildY()\n| 8 -> \nbuildMagic(build(rand, depth-1))\n| 9 -> \nbuildWeird(build(rand, depth-1), build(rand, depth-1),build(rand, depth-1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 \nthen buildX()\nelse\nmatch rand(1,10) with\n| 1 ->  buildSine(build(rand, depth-1))\n| 2 -> buildCosine(build(rand, depth-1))\n| 3 -> \nbuildAverage(build(rand, depth-1), build(rand, depth-1))\n| 4-> \nbuildTimes(build(rand, depth-1), build(rand, depth-1))\n| 5 -> \nbuildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| 6 -> \nbuildX()\n| 7 -> \nbuildY()\n| 8 -> \nbuildMagic(build(rand, depth-1))\n| 9 -> \nbuildWeird(build(rand, depth-1), build(rand, depth-1),build(rand, depth-1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 495-560:\n  buildWeird(build(rand, depth-1), build(rand, depth-1),build(rand, depth-1))\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMagic e1 = Magic e1;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (e1,e2,e3,e4) = Weird (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 -> buildX ()\n     | 7 -> buildY ()\n     | 8 -> buildMagic (build (rand, (depth - 1)))\n     | 9 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n", "in": "let buildWeird(e1, e2, e3)     = Weird(e1, e2, e3)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \neval(e1, x, y) < eval(e2, x, y)\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)\n| Magic e1 -> tan(eval(e1, x, y))\n| Weird (e1, e2, e3) -> \n(tan((eval( e1, x, y))*.(eval(e2, x, y)*.(eval(e3, x, y)))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> (sin(pi*.(eval (e1, x, y))))\n| Cosine e1 -> (cos*pi(eval (e1, x, y)))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \neval(e1, x, y) < eval(e2, x, y)\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)\n| Magic e1 -> (sin*pi(cos(pi*.(eval(e1, x, y)))))\n| Weird (e1, e2, e3) -> \n(cos(pi*.(eval( e1, x, y))*.(eval(e2, x, y)*.(eval(e3, x, y)))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-2:\n  u2;;\n  ^^\nError: Unbound value u2\n", "min": "\nlet _ = u2;;\n", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-58:\n  wwhile(fun b -> (f(b), f(b)=b) , b);;\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> (((f b), ((f b) = b)), b));;\n", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f, b) = \nwwhile((fun b -> (f(b), f(b)=b)), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f, b) = \nwwhile((fun b -> (f(b), f(b)!=b)), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"}]}
