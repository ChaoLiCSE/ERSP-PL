{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) t_res =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif t_res then\nvi\nelse if ki = k then\nassoc_tl (d,k,l) true\nelse\nassoc_tl (d,k,tl) false\nin\nassoc_tl (d,k,l) false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) t_res =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif t_res then\nvi\nelse if ki = k then\nassoc_tl (d,k,l) true\nelse\nassoc_tl (d,k,tl) false\nin\nassoc_tl (d,k,l) false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc_tl (d,k,tl)\nin\nassoc_tl (d,k,l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc_tl (d,k,tl)\n| _\t\t-> d"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 81-89:\n  assoc_tl (d,k,tl)\n  ^^^^^^^^\nError: Unbound value assoc_tl\nHint: Did you mean assoc?\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc_tl (d, k, tl)\n  | _ -> d;;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif b' then\nwwhile (f,b')\nelse\nc'"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool -> bool * 'a\n       Type int is not compatible with type bool \n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if b' then wwhile (f, b') else c';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' then\nwwhile (f,b')\nelse\nb'"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (((=) f),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-36:\n  let fixpoint (f,b) = wwhile (((=) f),b);;\n                               ^^^^^^^\nError: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((=) f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 18-25:\n  let _ = fixpoint (collatz, 1);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = wwhile ((f (=)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g f b = (b = (f b))),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g f b = (b, (b = (f b)))),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 20-21:\n  let g b = (b, (b = (f b)));;\n                      ^\nError: Unbound value f\n", "min": "\nlet g b = (b, (b = (f b)));;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-22:\n  let g f = let xx = f x in (xx, xx = f xx);;\n                       ^\nError: Unbound value x\n", "min": "\nlet g f = let xx = f x in (xx, (xx = (f xx)));;\n", "in": "let fixpoint (f,b) = wwhile ((g),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((g),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((g f),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((g),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-32:\n  let fixpoint (f,b) = wwhile ((g),b);;\n                               ^^^\nError: This expression has type ('a -> 'b) * 'a -> 'b * bool\n       but an expression was expected of type\n         ('a -> 'b) * 'a -> (('a -> 'b) * 'a) * bool\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n", "min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "in": "let fixpoint (f,b) = wwhile ((g f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-31:\n  let fixpoint (f,b) = wwhile ((g f b),b);;\n                                ^\nError: This function has type ('a -> 'b) * 'a -> 'b * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((g (f, b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((g f),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 10-11:\n  let _ = g f;;\n            ^\nError: Unbound value f\n", "min": "\nlet g h x = let xx = h x in (xx, (x = (h x)));;\n\nlet _ = g f;;\n", "in": "let fixpoint (f,b) = wwhile ((g f),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 10-11:\n  let _ = g f;;\n            ^\nError: Unbound value f\n", "min": "\nlet g h x = let xx = h x in (xx, (x != (h x)));;\n\nlet _ = g f;;\n", "in": "let fixpoint (f,b) = wwhile ((g f),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 1);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 10-11:\n  let _ = g f;;\n            ^\nError: Unbound value f\n", "min": "\nlet g h x = let xx = h x in (xx, (x != xx));;\n\nlet _ = g f;;\n", "in": "let fixpoint (f,b) = wwhile ((g f),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((g f),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet g h x = let xx = h x in (xx, (x != xx));;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g f x = let xx = f x in (xx, x != xx)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g h x = let xx = h x in (xx, x != xx) in g f),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"(\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2\"\n| Times(e1, e2) ->  \"(\" ^ exprToString(e1) ^ \"*\" ^ exprToString(e2) ^ \")\"\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \" + \" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \" * \" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \" + \" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \" * \" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi * eval(e', x, y))\n| Cosine(e') -> cos(pi * exprToString(e'))\n| Average(e1, e2) -> ((exprToString(e1) + exprToString(e2))/2)\n| Times(e1, e2) ->  exprToString(e1) * exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> if (exprToString(e1) < exprToString(e2) then exprToString(e3) else exprToString(e4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi * eval(e', x, y))\n| Cosine(e') -> cos(pi * exprToString(e'))\n| Average(e1, e2) -> ((exprToString(e1) + exprToString(e2))/2)\n| Times(e1, e2) ->  exprToString(e1) * exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> if (exprToString(e1) < exprToString(e2)) then exprToString(e3) else exprToString(e4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. exprToString(e'))\n| Average(e1, e2) -> ((exprToString(e1) +. exprToString(e2))/2)\n| Times(e1, e2) ->  exprToString(e1) *. exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> if (exprToString(e1) < exprToString(e2)) then exprToString(e3) else exprToString(e4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e'))\n| Average(e1, e2) -> ((eval(e1) +. eval(e2))/2)\n| Times(e1, e2) ->  eval(e1) *. eval(e2)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1) < eval(e2)) then eval(e3) else eval(e4)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y))/2)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 423-485:\n  | 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1));;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 423-485:\n  | 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1));;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 422-484:\n  | 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1));;\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 516-521:\n  | _ -> randX();;\n         ^^^^^\nError: Unbound value randX\nHint: Did you mean rand?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> randX ());;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 516-521:\n  | _ -> randX();;\n         ^^^^^\nError: Unbound value randX\nHint: Did you mean rand?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> randX ());;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "set _ = build(rand, 5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 4) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| _ -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| _ -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 557-561:\n  | Asin(e1, e2, e3)      -> \"\";;\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"\";;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ exprToString(e2) ^ \n\")*2/(pi^2))\"\n| Asin(e1, e2, e3)      -> \"1\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 558-562:\n  | Asin(e1, e2, e3)      -> \"1\";;\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ exprToString(e2) ^ \")*2/(pi^2))\"\n| Asin(e1, e2, e3)      -> \"1\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 559-563:\n  | Asin(e1, e2, e3)      -> \"1\";;\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| Asin     of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ exprToString(e2) ^ \n\")*2/(pi*pi))\"\n| Asin(e1, e2, e3)      -> \"1\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 517-529:\n  | _ -> buildAcossin(first_forced, build(rand, depth - 1));;\n         ^^^^^^^^^^^^\nError: Unbound value buildAcossin\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 6) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildAcossin (first_forced, (build (rand, (depth - 1)))));;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Accossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 400-404:\n  | Acossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi);;\n                                 ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval e1)) *. (asin (eval e2))) *. 2.0) /. (pi *. pi);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 6) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildAcossin(first_forced, build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 579-589:\n  | _ -> buildCrazy(first_forced, first_forced, first_forced);;\n         ^^^^^^^^^^\nError: Unbound value buildCrazy\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 60000) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e2)"}, {"type": "type", "out": "Characters 555-572:\n  | Crazy(e1, e2, e3)      -> exprToString(e2);;\n    ^^^^^^^^^^^^^^^^^\nError: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e2;;\n", "in": "let buildX()                       = VarX"}, {"type": "", "out": "", "min": "", "in": "let buildY()                       = VarY"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 460-477:\n  | Crazy(e1, e2, e3) -> eval(e1, x, y);;\n    ^^^^^^^^^^^^^^^^^\nError: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval (e1, x, y);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 555-572:\n  | Crazy(e1, e2, e3)      -> exprToString(e1);;\n    ^^^^^^^^^^^^^^^^^\nError: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e1;;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| Crazy    of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> Average(e1, e2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> eval(Average(e1, e2), x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> eval(Average(e1, e2), x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 60000) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs(e3) else (-abs(e3))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs e3 else - (abs e3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs_float(e3) else (-abs_float(e3))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs_float e3 else - (abs_float e3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs_float(eval(e3)) else (-abs_float(eval(e3)))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if e1 > e2 then abs_float (eval e3) else - (abs_float (eval e3));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then 1.0 else (-1.0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then 1.0 else (-1.0)"}, {"type": "scope", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 60000) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1) > eval(e2)) then eval(e3) else (-eval(e3))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-eval(e3, x, y))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 546-560:\n  eval(e3, x, y) else (-eval(e3, x, y));;\n                        ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else - (eval (e3, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-1.0 * eval(e3, x, y))"}, {"type": "type", "out": "Characters 545-549:\n  eval(e3, x, y) else (-1.0 * eval(e3, x, y));;\n                       ^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) * (eval (e3, x, y));;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 60000) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-1.0 *. eval(e3, x, y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan2(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 707-718:\n  (atan2(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\n   ^^^^^^^^^^^\nError: This expression has type float -> float\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan2 res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 707-717:\n  (atan(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\n   ^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 750-751:\n  (atan(res1) +. atan(res2) -. atan(res3)) *. 2 / (3.0 *. pi)\n                                              ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 706-753:\n  (atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 / (3.0 *. pi)\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 779-793:\n  (eval(-1.0 *. res3));;\n       ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n(eval((-1.0) *. res3))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 779-795:\n  (eval((-1.0) *. res3));;\n       ^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n((-1.0) *. res3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n((-1.0) *. res3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-13:\n  doRandomColor(8, 1, 1500);;\n  ^^^^^^^^^^^^^\nError: Unbound value doRandomColor\n", "min": "\nlet _ = doRandomColor (8, 1, 1500);;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 10) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)"}, {"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-13:\n  doRandomColor(8, 1, 1500);;\n  ^^^^^^^^^^^^^\nError: Unbound value doRandomColor\n", "min": "\nlet _ = doRandomColor (8, 1, 1500);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \"\""}, {"type": "scope", "out": "Characters 41-45:\n  | VarX\t\t\t -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> \"\";;\n", "in": "let buildX()                       = VarX"}, {"type": "scope", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY"}, {"type": "scope", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n", "min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)"}, {"type": "scope", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n", "min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n", "min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}, {"type": "scope", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)"}, {"type": "scope", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)"}, {"type": "scope", "out": "Characters 30-37:\n  let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2);;\n                                ^^^^^^^\nError: Unbound constructor Acossin\n", "min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-12:\n  doRandomGray(1, 111, 1005);;\n  ^^^^^^^^^^^^\nError: Unbound value doRandomGray\n", "min": "\nlet _ = doRandomGray (1, 111, 1005);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\""}, {"type": "scope", "out": "Characters 41-45:\n  | VarX\t\t\t -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "in": "let buildX()                       = VarX"}, {"type": "scope", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY"}, {"type": "scope", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n", "min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)"}, {"type": "scope", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n", "min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n", "min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}, {"type": "scope", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)"}, {"type": "scope", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)"}, {"type": "scope", "out": "Characters 30-37:\n  let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2);;\n                                ^^^^^^^\nError: Unbound constructor Acossin\n", "min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-12:\n  doRandomGray(5, 1315, 666);;\n  ^^^^^^^^^^^^\nError: Unbound value doRandomGray\n", "min": "\nlet _ = doRandomGray (5, 1315, 666);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\""}, {"type": "scope", "out": "Characters 41-45:\n  | VarX\t\t\t -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "in": "let buildX()                       = VarX"}, {"type": "scope", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY"}, {"type": "scope", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n", "min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)"}, {"type": "scope", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n", "min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n", "min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}, {"type": "scope", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)"}, {"type": "scope", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)"}, {"type": "scope", "out": "Characters 30-37:\n  let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2);;\n                                ^^^^^^^\nError: Unbound constructor Acossin\n", "min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-12:\n  doRandomGray(8, 543, 35241);;\n  ^^^^^^^^^^^^\nError: Unbound value doRandomGray\n", "min": "\nlet _ = doRandomGray (8, 543, 35241);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 41-45:\n  | VarX\t\t\t -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "in": "let buildX()                       = VarX"}, {"type": "scope", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY"}, {"type": "scope", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n", "min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)"}, {"type": "scope", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n", "min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n", "min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}, {"type": "scope", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)"}, {"type": "scope", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)"}, {"type": "scope", "out": "Characters 30-37:\n  let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2);;\n                                ^^^^^^^\nError: Unbound constructor Acossin\n", "min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-12:\n  doRandomGray(8, 543, 35241);;\n  ^^^^^^^^^^^^\nError: Unbound value doRandomGray\n", "min": "\nlet _ = doRandomGray (8, 543, 35241);;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 10) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-13:\n  doRandomColor(10, 510, 150);;\n  ^^^^^^^^^^^^^\nError: Unbound value doRandomColor\n", "min": "\nlet _ = doRandomColor (10, 510, 150);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}, {"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. \nasin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l wi\n| (ki, vi)::> \nif ki = k then\nvssoc (d,k,tl)\n|\n\n\neDuplnt list -> int  \n* or more generally, removeDuplicates : 'a list -> 'a lit\n* (removeDuplicates l) is the list of elements of l with uplicates (second,\n* third ... occurrences) removed, and where the remaining lements \n* appear in the same order as in l.\n* e.g. (removeDuplicate [1;6;2;4;12;2;13;6;9]) is [1;6;2;4;2;13;9]\n*\n*  ** your function \"helper\" should be tail recursive **\n* orthis problem only, you may use the library function List.em and List.rev\n*"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []    ->  seen\n| h::t  -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nhelper(seen', t)\nin\nList.rev(helper([], l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-2:\n  cc;;\n  ^^\nError: Unbound value cc\n", "min": "\nlet _ = cc;;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)"}, {"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []    ->  seen\n| h::t  -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nhelper(seen', t)\nin\nList.rev(helper([], l))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-12:\n  doRandomGray(2, 111, 1005);;\n  ^^^^^^^^^^^^\nError: Unbound value doRandomGray\n", "min": "\nlet _ = doRandomGray (2, 111, 1005);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)"}, {"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []    ->  seen\n| h::t  -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nhelper(seen', t)\nin\nList.rev(helper([], l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
