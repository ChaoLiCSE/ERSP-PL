{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) t_res =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif t_res then\nvi\nelse if ki = k then\nassoc_tl (d,k,l) true\nelse\nassoc_tl (d,k,tl) false\nin\nassoc_tl (d,k,l) false", "min": "\nlet rec assoc (d,k,l) =\n  let rec assoc_tl (d,k,l) t_res =\n    match l with\n    | [] -> d\n    | (ki,vi)::tl ->\n        if t_res\n        then vi\n        else\n          if ki = k\n          then assoc_tl (d, k, l) true\n          else assoc_tl (d, k, tl) false in\n  assoc_tl (d, k, l) false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) t_res =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif t_res then\nvi\nelse if ki = k then\nassoc_tl (d,k,l) true\nelse\nassoc_tl (d,k,tl) false\nin\nassoc_tl (d,k,l) false", "min": "\nlet rec assoc (d,k,l) =\n  let rec assoc_tl (d,k,l) t_res =\n    match l with\n    | [] -> d\n    | (ki,vi)::tl ->\n        if t_res\n        then vi\n        else\n          if ki = k\n          then assoc_tl (d, k, l) true\n          else assoc_tl (d, k, tl) false in\n  assoc_tl (d, k, l) false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc_tl (d,k,tl)\nin\nassoc_tl (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec assoc_tl (d,k,l) =\n    match l with\n    | [] -> d\n    | (ki,vi)::tl -> if ki = k then vi else assoc_tl (d, k, tl) in\n  assoc_tl (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc_tl (d,k,tl)\n| _\t\t-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc_tl (d, k, tl)\n  | _ -> d;;\n", "out": "Characters 81-89:\n  assoc_tl (d,k,tl)\n  ^^^^^^^^\nError: Unbound value assoc_tl\nHint: Did you mean assoc?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif b' then\nwwhile (f,b')\nelse\nc'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if b' then wwhile (f, b') else c';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' then\nwwhile (f,b')\nelse\nb'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (((=) f),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((=) f), b);;\n", "out": "Characters 29-36:\n  let fixpoint (f,b) = wwhile (((=) f),b);;\n                               ^^^^^^^\nError: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f (=)),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f (=)), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((g),b)", "min": "\nlet g f b = (b, (b = (f b)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "out": "Characters 29-32:\n  let fixpoint (f,b) = wwhile ((g),b);;\n                               ^^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       Type 'a -> 'a * bool is not compatible with type ('a -> 'a) * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((g),b)", "min": "\nlet g f b = (b, (b = (f b)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "out": "Characters 29-32:\n  let fixpoint (f,b) = wwhile ((g),b);;\n                               ^^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       Type 'a -> 'a * bool is not compatible with type ('a -> 'a) * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((g),b)", "min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "out": "Characters 29-32:\n  let fixpoint (f,b) = wwhile ((g),b);;\n                               ^^^\nError: This expression has type ('a -> 'a) * 'a -> 'a * bool\n       but an expression was expected of type\n         ('a -> 'a) * 'a -> (('a -> 'a) * 'a) * bool\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "out": "Characters 29-34:\n  let fixpoint (f,b) = wwhile ((g f),b);;\n                               ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((g),b)", "min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "out": "Characters 29-32:\n  let fixpoint (f,b) = wwhile ((g),b);;\n                               ^^^\nError: This expression has type ('a -> 'b) * 'a -> 'b * bool\n       but an expression was expected of type\n         ('a -> 'b) * 'a -> (('a -> 'b) * 'a) * bool\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile ((g f b),b)", "min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f b), b);;\n", "out": "Characters 30-31:\n  let fixpoint (f,b) = wwhile ((g f b),b);;\n                                ^\nError: This function has type ('a -> 'b) * 'a -> 'b * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((g (f, b)),b)", "min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g (f, b)), b);;\n", "out": "Characters 29-39:\n  let fixpoint (f,b) = wwhile ((g (f, b)),b);;\n                               ^^^^^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "min": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "min": "\nlet g h x = let xx = h x in (xx, (x = (h x)));;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((g f),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "min": "\nlet g h x = let xx = h x in (xx, (x != (h x)));;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((g f),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "min": "\nlet g h x = let xx = h x in (xx, (x != xx));;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((g f),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let g h x = let xx = h x in (xx, x != xx) in g f),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let g h x = let xx = h x in (xx, (x != xx)) in g f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let g h x = let xx = h x in (xx, (x != xx)) in g f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let g h x = let xx = h x in (xx, x != xx) in g f),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let g h x = let xx = h x in (xx, (x != xx)) in g f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"(\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2\"\n| Times(e1, e2) ->  \"(\" ^ exprToString(e1) ^ \"*\" ^ exprToString(e2) ^ \")\"\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \" + \" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \" * \" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^ ((exprToString e3) ^ (\" : \" ^ (exprToString e4)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \" + \" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \" * \" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi * eval(e', x, y))\n| Cosine(e') -> cos(pi * exprToString(e'))\n| Average(e1, e2) -> ((exprToString(e1) + exprToString(e2))/2)\n| Times(e1, e2) ->  exprToString(e1) * exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> if (exprToString(e1) < exprToString(e2)) then exprToString(e3) else exprToString(e4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval (e', x, y)))\n  | Cosine e' -> cos (pi * (exprToString e'))\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "out": "Characters 78-80:\n  | Sine(e') -> sin(pi * eval(e', x, y))\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. exprToString(e'))\n| Average(e1, e2) -> ((exprToString(e1) +. exprToString(e2))/2)\n| Times(e1, e2) ->  exprToString(e1) *. exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> if (exprToString(e1) < exprToString(e2)) then exprToString(e3) else exprToString(e4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (exprToString e'))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "out": "Characters 126-142:\n  | Cosine(e') -> cos(pi *. exprToString(e'))\n                            ^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e'))\n| Average(e1, e2) -> ((eval(e1) +. eval(e2))/2)\n| Times(e1, e2) ->  eval(e1) *. eval(e2)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1) < eval(e2)) then eval(e3) else eval(e4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "out": "Characters 130-134:\n  | Cosine(e') -> cos(pi *. eval(e'))\n                                ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y))/2)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": "Characters 164-198:\n  | Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y))/2)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": "Characters 202-203:\n  | Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2)\n                                                              ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": "Characters 423-485:\n  | 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1));;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": "Characters 423-485:\n  | 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1));;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": "Characters 422-484:\n  | 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1));;\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> randX ());;\n", "out": "Characters 516-521:\n  | _ -> randX();;\n         ^^^^^\nError: Unbound value randX\nHint: Did you mean rand?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> randX ());;\n", "out": "Characters 516-521:\n  | _ -> randX();;\n         ^^^^^\nError: Unbound value randX\nHint: Did you mean rand?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 4) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 4) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| _ -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| _ -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ exprToString(e2) ^ \")*2/(pi^2))\"\n| Asin(e1, e2, e3)      -> \"1\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n", "out": "Characters 557-561:\n  | Asin(e1, e2, e3)      -> \"1\";;\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| Asin     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Asin of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ exprToString(e2) ^ \n\")*2/(pi*pi))\"\n| Asin(e1, e2, e3)      -> \"1\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Asin of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Accossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Accossin (e1,e2) ->\n      (((acos (eval e1)) *. (asin (eval e2))) *. 2.0) /. (pi *. pi);;\n", "out": "Characters 371-379:\n  | Accossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi);;\n    ^^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Accossin does not belong to type expr\nHint: Did you mean Acossin?\n"}, {"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval e1)) *. (asin (eval e2))) *. 2.0) /. (pi *. pi);;\n", "out": "Characters 400-404:\n  | Acossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi);;\n                                 ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 6) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildAcossin(first_forced, build(rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 6) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildAcossin (first_forced, (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e2;;\n", "out": "Characters 555-572:\n  | Crazy(e1, e2, e3)      -> exprToString(e2);;\n    ^^^^^^^^^^^^^^^^^\nError: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"}, {"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e1;;\n", "out": "Characters 555-572:\n  | Crazy(e1, e2, e3)      -> exprToString(e1);;\n    ^^^^^^^^^^^^^^^^^\nError: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| Crazy    of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> Average(e1, e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> Average (e1, e2);;\n", "out": "Characters 481-496:\n  | Crazy(e1, e2, e3) -> Average(e1, e2);;\n                         ^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}, {"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval (e1, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> eval(Average(e1, e2), x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval ((Average (e1, e2)), x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> eval(Average(e1, e2), x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval ((Average (e1, e2)), x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 60000) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "min": "\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 60000) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "out": "Characters 100-106:\n  if bin_rand = 0 then buildX()\n                       ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs(e3) else (-abs(e3))", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs e3 else - (abs e3);;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs_float(e3) else (-abs_float(e3))", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs_float e3 else - (abs_float e3);;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs_float(eval(e3)) else (-abs_float(eval(e3)))", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if e1 > e2 then abs_float (eval e3) else - (abs_float (eval e3));;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then 1.0 else (-1.0)", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then 1.0 else (-1.0)", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 60000) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "min": "\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 60000) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "out": "Characters 100-106:\n  if bin_rand = 0 then buildX()\n                       ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1) > eval(e2)) then eval(e3) else (-eval(e3))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval e1) > (eval e2) then eval e3 else - (eval e3);;\n", "out": "Characters 489-493:\n  | Crazy(e1, e2, e3) -> if (eval(e1) > eval(e2)) then eval(e3) else (-eval(e3));;\n                                 ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}, {"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-eval(e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else - (eval (e3, x, y));;\n", "out": "Characters 546-560:\n  eval(e3, x, y) else (-eval(e3, x, y));;\n                        ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-1.0 * eval(e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) * (eval (e3, x, y));;\n", "out": "Characters 545-549:\n  eval(e3, x, y) else (-1.0 * eval(e3, x, y));;\n                       ^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}, {"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-1.0 *. eval(e3, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) *. (eval (e3, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan2(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan2 res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "out": "Characters 707-718:\n  (atan2(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\n   ^^^^^^^^^^^\nError: This expression has type float -> float\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "out": "Characters 707-717:\n  (atan(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\n   ^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "out": "Characters 750-751:\n  (atan(res1) +. atan(res2) -. atan(res3)) *. 2 / (3.0 *. pi)\n                                              ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "out": "Characters 706-753:\n  (atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 / (3.0 *. pi)\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "out": "Characters 779-793:\n  (eval(-1.0 *. res3));;\n       ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         expr * float * float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n(eval((-1.0) *. res3))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "out": "Characters 779-795:\n  (eval((-1.0) *. res3));;\n       ^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         expr * float * float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n((-1.0) *. res3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else (-1.0) *. res3;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n((-1.0) *. res3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else (-1.0) *. res3;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 10) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCrazy (e1,e2,e3) = Crazy (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 10) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \"\"", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> \"\";;\n", "out": "Characters 41-45:\n  | VarX\t\t\t -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildX()                       = VarX", "min": "\nlet buildX () = VarX;;\n", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildY()                       = VarY", "min": "\nlet buildY () = VarY;;\n", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n"}, {"type": "scope", "in": "let buildSine(e)                   = Sine(e)", "min": "\nlet buildSine e = Sine e;;\n", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n"}, {"type": "scope", "in": "let buildCosine(e)                 = Cosine(e)", "min": "\nlet buildCosine e = Cosine e;;\n", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n"}, {"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "out": "Characters 30-37:\n  let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2);;\n                                ^^^^^^^\nError: Unbound constructor Acossin\n"}, {"type": "scope", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "min": "\nlet buildCrazy (e1,e2,e3) = Crazy (e1, e2, e3);;\n", "out": "Characters 32-37:\n  let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3);;\n                                  ^^^^^\nError: Unbound constructor Crazy\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else (-1.0) *. res3;;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 10) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "min": "\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 10) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "out": "Characters 100-106:\n  if bin_rand = 0 then buildX()\n                       ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\"", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "out": "Characters 41-45:\n  | VarX\t\t\t -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildX()                       = VarX", "min": "\nlet buildX () = VarX;;\n", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildY()                       = VarY", "min": "\nlet buildY () = VarY;;\n", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n"}, {"type": "scope", "in": "let buildSine(e)                   = Sine(e)", "min": "\nlet buildSine e = Sine e;;\n", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n"}, {"type": "scope", "in": "let buildCosine(e)                 = Cosine(e)", "min": "\nlet buildCosine e = Cosine e;;\n", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n"}, {"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "out": "Characters 30-37:\n  let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2);;\n                                ^^^^^^^\nError: Unbound constructor Acossin\n"}, {"type": "scope", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "min": "\nlet buildCrazy (e1,e2,e3) = Crazy (e1, e2, e3);;\n", "out": "Characters 32-37:\n  let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3);;\n                                  ^^^^^\nError: Unbound constructor Crazy\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else (-1.0) *. res3;;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\"", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "out": "Characters 41-45:\n  | VarX\t\t\t -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildX()                       = VarX", "min": "\nlet buildX () = VarX;;\n", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildY()                       = VarY", "min": "\nlet buildY () = VarY;;\n", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n"}, {"type": "scope", "in": "let buildSine(e)                   = Sine(e)", "min": "\nlet buildSine e = Sine e;;\n", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n"}, {"type": "scope", "in": "let buildCosine(e)                 = Cosine(e)", "min": "\nlet buildCosine e = Cosine e;;\n", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n"}, {"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "out": "Characters 30-37:\n  let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2);;\n                                ^^^^^^^\nError: Unbound constructor Acossin\n"}, {"type": "scope", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "min": "\nlet buildCrazy (e1,e2,e3) = Crazy (e1, e2, e3);;\n", "out": "Characters 32-37:\n  let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3);;\n                                  ^^^^^\nError: Unbound constructor Crazy\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else (-1.0) *. res3;;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\"", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "out": "Characters 41-45:\n  | VarX\t\t\t -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let buildX()                       = VarX", "min": "\nlet buildX () = VarX;;\n", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildY()                       = VarY", "min": "\nlet buildY () = VarY;;\n", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n"}, {"type": "scope", "in": "let buildSine(e)                   = Sine(e)", "min": "\nlet buildSine e = Sine e;;\n", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n"}, {"type": "scope", "in": "let buildCosine(e)                 = Cosine(e)", "min": "\nlet buildCosine e = Cosine e;;\n", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n"}, {"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "out": "Characters 30-37:\n  let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2);;\n                                ^^^^^^^\nError: Unbound constructor Acossin\n"}, {"type": "scope", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "min": "\nlet buildCrazy (e1,e2,e3) = Crazy (e1, e2, e3);;\n", "out": "Characters 32-37:\n  let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3);;\n                                  ^^^^^\nError: Unbound constructor Crazy\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else (-1.0) *. res3;;\n", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 10) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "min": "\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 10) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "out": "Characters 100-106:\n  if bin_rand = 0 then buildX()\n                       ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. \nasin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else (-1.0) *. res3;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet buildCrazy (e1,e2,e3) = Crazy (e1, e2, e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g h x = let x = h x in (xx, x != xx) in g f),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let g h x = let x = h x in (xx, (x != xx)) in g f), b);;\n", "out": "Characters 58-60:\n  let fixpoint (f,b) = wwhile ((let g h x = let x = h x in (xx, x != xx) in g f),b);;\n                                                            ^^\nError: Unbound value xx\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else (-1.0) *. res3;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCrazy (e1,e2,e3) = Crazy (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 7) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ ->\n         buildCrazy\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else (-1.0) *. res3;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let g h x = let xx = h x in (xx, (x != xx)) in g f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
