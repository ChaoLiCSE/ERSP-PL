{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f b with\n| (i,true) -> wwhile(f,i)\n| (i, false) -> i", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 50) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 50)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 25) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 25)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 2) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 2)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 3) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 3)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 4) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 4)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 25) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 25)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 24) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 24)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 23) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 23)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 22) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 22)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 512) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 512)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 500) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 500)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 513) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 513)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 600) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 600)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 20) in\nwwhile (f, 3)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 20)) in wwhile (f, 3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 28) in\nwwhile (f, 3)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 28)) in wwhile (f, 3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint(f,b),b)", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 43-44:\n  let fixpoint (f,b) = wwhile (fixpoint(f,b),b);;\n                                             ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (if b = f b then b else f(b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "out": "Characters 52-56:\n  let fixpoint (f,b) = wwhile (if b = f b then b else f(b),b);;\n                                                      ^^^^\nError: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (if b = f b then b else f b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "out": "Characters 52-55:\n  let fixpoint (f,b) = wwhile (if b = f b then b else f b,b);;\n                                                      ^^^\nError: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (if b = (f b) then b else (f b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "out": "Characters 54-59:\n  let fixpoint (f,b) = wwhile (if b = (f b) then b else (f b),b);;\n                                                        ^^^^^\nError: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (if b = (f b) then (b,false) else ((f b),true),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if b = (f b) then (b, false) else (((f b), true), b));;\n", "out": "Characters 62-74:\n  let fixpoint (f,b) = wwhile (if b = (f b) then (b,false) else ((f b),true),b);;\n                                                                ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (if x = f x then (b, false) else (b, true),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if x = (f x) then (b, false) else ((b, true), b));;\n", "out": "Characters 32-33:\n  let fixpoint (f,b) = wwhile (if x = f x then (b, false) else (b, true),b);;\n                                  ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (if x = f x then (x, false) else (x, true),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if x = (f x) then (x, false) else ((x, true), b));;\n", "out": "Characters 32-33:\n  let fixpoint (f,b) = wwhile (if x = f x then (x, false) else (x, true),b);;\n                                  ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (if b = f b then (b, false) else (b, true),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if b = (f b) then (b, false) else ((b, true), b));;\n", "out": "Characters 61-70:\n  let fixpoint (f,b) = wwhile (if b = f b then (b, false) else (b, true),b);;\n                                                               ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((if b = f b then (b, false) else (b, true)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((if b = (f b) then (b, false) else (b, true)), b);;\n", "out": "Characters 46-56:\n  let fixpoint (f,b) = wwhile ((if b = f b then (b, false) else (b, true)),b);;\n                                                ^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile ((helper b), b);;\n", "out": "Characters 91-99:\n  wwhile (helper b,b);;\n          ^^^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile (helper, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) in\nwwhile (helper,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile (helper, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = let helper x = \nif b = (f b) then (b, false) else (b, true) in\nwwhile (helper,b)", "min": "\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile (helper, b);;\n", "out": "Characters 84-90:\n  wwhile (helper,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = let helper x = \nif b = (f b) then (b, false) else (f b, true) in\nwwhile (helper,b)", "min": "\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else ((f b), true) in\n  wwhile (helper, b);;\n", "out": "Characters 86-92:\n  wwhile (helper,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((if b = (f b) then (b, false) else (f b, true)),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((if b = (f b) then (b, false) else ((f b), true)), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((if b = (f b) then (b, false) else (f b, true)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((if x = (f x) then (x, false) else ((f x), true)), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "min": "\nlet fixpoint (f,b) =\n  let helper x = if x = (f x) then (x, false) else ((f x), true) in\n  wwhile (helper, b);;\n", "out": "Characters 86-92:\n  wwhile (helper,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((if x = (f x) then (x, false) else ((f x), true)), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "min": "\nlet fixpoint (f,b) =\n  let helper x = if x = (f x) then (x, false) else ((f x), true) in\n  wwhile (helper, b);;\n", "out": "Characters 86-92:\n  wwhile (helper,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" + exprToString e", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" + (exprToString e);;\n", "out": "Characters 78-88:\n  | Sine e -> \"sin (pi*\" + exprToString e;;\n              ^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ (exprToString e);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX\t\t        -> \"x\"\n| VarY\t\t        -> \"y\"\n| Sine e\t        -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e\t\t-> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2)\t        -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y\n| Sine e1\t        -> sin (pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos (pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 104-106:\n  | Sine e1\t        -> sin (pi*eval (e1,x,y))\n                            ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y\n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 103-105:\n  | Sine e1\t        -> sin(pi*eval (e1,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> float_of_int x\n| VarY\t\t        -> float_of_int y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 130-132:\n  | Sine e1\t        -> sin(pi*eval (e1,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 104-106:\n  | Sine e1\t        -> sin(pi*eval (e1,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*(eval (e1,x,y)))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 104-106:\n  | Sine e1\t        -> sin(pi*(eval (e1,x,y)))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| buildX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 106-108:\n  | Sine e1\t        -> sin(pi*eval (e1,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| buildX\t                -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 113-115:\n  | Sine e1\t        -> sin(pi*eval (e1,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 113-115:\n  | Sine e1\t        -> sin(pi*eval (e1,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 104-106:\n  | Sine e1\t        -> sin(pi*eval (e1,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 104-106:\n  | Sine e1\t        -> sin(pi*eval (e1,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 224-225:\n  | Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n                                                                ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 330-332:\n  | Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y);;\n                                             ^^\nError: Unbound value <.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 350-363:\n  | Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y);;\n                                                                 ^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n", "out": "Characters 328-332:\n  | Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y);;\n                                           ^^^^\nError: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 330-332:\n  | Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y);;\n                                             ^^\nError: Unbound value <.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "out": "Characters 350-363:\n  | Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y);;\n                                                                 ^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)>=eval (e2,x,y)->  eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) >= (eval (e2, x, y)) ->\n      eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)\nwhen eval (e1,x,y) < eval (e2,x,y) ->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)\nwhen eval (e1,x,y) < eval (e2,x,y) ->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = if depth > 0 then match rand 0 4 with\n| 0 -> buildX()\nelse match rand 0 1 with\n| 0 -> buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then match rand 0 4 with | 0 -> buildX ()\n  else (match rand 0 1 with | 0 -> buildX ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, depth') in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "out": "Characters 50-56:\n  let e = build(rand,depth') in\n                     ^^^^^^\nError: Unbound value depth'\nHint: Did you mean depth?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "out": "Characters 207-216:\n  | 4 -> buildTimes(e,e,e,e)\n                   ^^^^^^^^^\nError: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand 0 4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match (rand 0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand 0 4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match (rand 0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 92-93:\n  let e1 = build (g, depth) in\n                  ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0 4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": "Characters 92-93:\n  if depth > 1 then match rand (0 4) with\n                                ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": "Characters 93-94:\n  if depth > 1 then match (rand (0 4)) with\n                                 ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": "Characters 92-93:\n  if depth > 1 then match (rand(0 4)) with\n                                ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then let e = build(rand,depth-1) in\nmatch rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    let e = build (rand, (depth - 1)) in\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then let e = build(rand,depth-1) in\nmatch rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    let e = build (rand, (depth - 1)) in\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    let e = build (rand, (depth - 1)) in\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    let e = build (rand, (depth - 1)) in\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f b with\n| (i,true) -> wwhile(f,i)\n| (i, false) -> i", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if x = (f x) then (x, false) else ((f x), true) in\n  wwhile (helper, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile (fun x -> if x = (f x) then (x, false) else (f x, true),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if x = (f x) then (x, false) else (((f x), true), b));;\n", "out": "Characters 28-86:\n  let fixpoint (f,b) = wwhile (fun x -> if x = (f x) then (x, false) else (f x, true),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x->if x = (f x) then (x, false) else (f x, true)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((fun x  -> if x = (f x) then (x, false) else ((f x), true)), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 28) in\nwwhile (f, 3)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 28)) in wwhile (f, 3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (\n(fun x -> \nif x = (f x) then \n(x, false) \nelse \n(f x, true))\n, b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((fun x  -> if x = (f x) then (x, false) else ((f x), true)), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((fun x  -> if x = (f x) then (x, false) else ((f x), true)), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,5) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4|5 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 5) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4|5 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,5) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 5) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,7) with\n| 0|1 -> buildSine(build(rand,depth-1))\n| 2|3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 7) with\n    | 0|1 -> buildSine (build (rand, (depth - 1)))\n    | 2|3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,7) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2|3 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 7) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2|3 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4|5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,9) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4|5 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 6|7 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 9) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4|5 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6|7 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 15) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,2) with\n| 0 -> buildX()\n| 1|2 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 15) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | 1|2 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildY()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,2) with\n| 0 -> buildY()\n| 1|2 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 15) with\n    | 0 -> buildY ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildY () | 1|2 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,2) with\n| 0 -> buildX()\n| 1|2 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 15) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | 1|2 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 15) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | 1|2 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 15) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | 1|2 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 15) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (1,16) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (1,2) with\n| 1 -> buildX()\n| 2 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (1, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (1,16) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,3) with\n| 0|1 -> buildX()\n| 2|3 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (1, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 3) with | 0|1 -> buildX () | 2|3 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (1,16) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4|5 -> buildSine(build(rand,depth-1))\n| 6|7|8 -> buildCosine(build(rand,depth-1))\n| 9|10 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,3) with\n| 0|1 -> buildX()\n| 2|3 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (1, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4|5 -> buildSine (build (rand, (depth - 1)))\n    | 6|7|8 -> buildCosine (build (rand, (depth - 1)))\n    | 9|10 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 3) with | 0|1 -> buildX () | 2|3 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 15) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | 1|2 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n", "out": "Characters 79-85:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Divide   of expr * expr\n| MultDiv  of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)\nwhen eval (e1,x,y) < eval (e2,x,y) ->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Divide (e1,e2)        -> eval (e1,x,y) /. eval (e2,x,y)\n| MultDiv(e1,e2,e3)     -> (eval (e1,x,y) *. eval (e2,x,y))/eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) / (eval (e3, x, y));;\n", "out": "Characters 490-522:\n  | MultDiv(e1,e2,e3)     -> (eval (e1,x,y) *. eval (e2,x,y))/eval (e3,x,y);;\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) when eval (e1,x,y) < eval (e2,x,y) \n->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Divide (e1,e2)        -> eval (e1,x,y) /. eval (e2,x,y)\n| MultDiv(e1,e2,e3)     -> (eval (e1,x,y) *. eval (e2,x,y))/.eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) /. (eval (e3, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) /. (eval (e3, x, y));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,dept-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,dept-1),\nbuild(rand,depth-1),\nbuild(rand,dept-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDivide (e1,e2) = Divide (e1, e2);;\n\nlet buildMultDiv (e1,e2,e3) = MultDiv (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 13|14|15 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 16|17 ->\n        buildDivide ((build (rand, (dept - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildMultDiv\n          ((build (rand, (dept - 1))), (build (rand, (depth - 1))),\n            (build (rand, (dept - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n", "out": "Characters 488-492:\n  | 16|17    -> buildDivide(build(rand,dept-1),build(rand,depth-1))\n                                       ^^^^\nError: Unbound value dept\nHint: Did you mean depth?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDivide (e1,e2) = Divide (e1, e2);;\n\nlet buildMultDiv (e1,e2,e3) = MultDiv (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 13|14|15 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 16|17 ->\n        buildDivide\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildMultDiv\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDivide (e1,e2) = Divide (e1, e2);;\n\nlet buildMultDiv (e1,e2,e3) = MultDiv (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 13|14|15 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 16|17 ->\n        buildDivide\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildMultDiv\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) /. (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDivide (e1,e2) = Divide (e1, e2);;\n\nlet buildMultDiv (e1,e2,e3) = MultDiv (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 13|14|15 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 16|17 ->\n        buildDivide\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildMultDiv\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Divide (e1,e2) -> (exprToString e1) ^ (\"/\" ^ (exprToString e2))\n  | MultDiv (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\")/\" ^ (exprToString e3)))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDivide (e1,e2) = Divide (e1, e2);;\n\nlet buildMultDiv (e1,e2,e3) = MultDiv (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 13|14|15 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 16|17 ->\n        buildDivide\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildMultDiv\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) /. (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDivide (e1,e2) = Divide (e1, e2);;\n\nlet buildMultDiv (e1,e2,e3) = MultDiv (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 1\n  then\n    match rand (0, 16) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 3|4 -> buildSine (build (rand, (depth - 1)))\n    | 5|6 -> buildCosine (build (rand, (depth - 1)))\n    | 7|8|9 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 10|11|12 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 13|14|15 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 16|17 ->\n        buildDivide\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildMultDiv\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Divide (e1,e2) -> (exprToString e1) ^ (\"/\" ^ (exprToString e2))\n  | MultDiv (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\")/\" ^ (exprToString e3)))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "buildMultDiv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet buildMultDiv (e1,e2,e3) = MultDiv (e1, e2, e3);;\n\nlet _ = buildMultDiv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Tan      of expr\n| NegPos   of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | NegPos of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\n| VarX\t\t        -> \"x\"\n| VarY\t\t        -> \"y\"\n| Sine e\t        -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e\t\t-> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2)\t        -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Tan (e1)              -> \"tan(pi*\" ^ exprToString e1 ^ \")\"\n| NegPos (e1,e2,e3)     -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?-\" ^ exprToString e3 \n^ \":\" ^ exprToString v ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | NegPos of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Tan e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | NegPos (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?-\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString v) ^ \")\")))))));;\n", "out": "Characters 649-650:\n  ^ \":\" ^ exprToString v ^ \")\";;\n                       ^\nError: Unbound value v\n"}, {"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | NegPos of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX\t\t        -> \"x\"\n| VarY\t\t        -> \"y\"\n| Sine e\t        -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e\t\t-> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2)\t        -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Tan (e1)              -> \"tan(pi*\" ^ exprToString e1 ^ \")\"\n| NegPos (e1,e2,e3)     -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?-\" ^ exprToString e3 \n^ \":\" ^ exprToString e3 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | NegPos of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Tan e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | NegPos (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?-\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e3) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) when eval (e1,x,y) < eval (e2,x,y) \n->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Tan e1                -> tan (pi*.eval (e1,x,y))\n| NegPos(e1,e2,e3) when eval (e1,x,y) < eval (e2,x,y)\n-> -.eval (e3,x,y)\n| NegPos(e1,e2,e3)      -> eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Tan e1 -> tan (pi *. (eval (e1, x, y)))\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Tan e1 -> tan (pi *. (eval (e1, x, y)))\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square   of expr\n| NegPos   of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) when eval (e1,x,y) < eval (e2,x,y) \n->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Square e1             -> eval (e1,x,y) ** 2.\n| NegPos(e1,e2,e3) when eval (e1,x,y) < eval (e2,x,y)\n-> -.eval (e3,x,y)\n| NegPos(e1,e2,e3)      -> eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildSquare(e1)                = Square(e1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet buildSquare e1 = Square e1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) when eval (e1,x,y) < eval (e2,x,y) \n->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Square e1             -> eval (e1,x,y) ** 2.\n| NegPos(e1,e2,e3) when eval (e1,x,y) < eval (e2,x,y)\n-> 0.-.eval (e3,x,y)\n| NegPos(e1,e2,e3)      -> eval (e3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf(rv)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf rv;;\n", "out": "Characters 62-66:\n  Format.sprintf(rv);;\n                ^^^^\nError: This expression has type float but an expression was expected of type\n         ('a, unit, string) format =\n           ('a, unit, string, string, string, string)\n           CamlinternalFormatBasics.format6\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf(\"%d\" !rv)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf (\"%d\" (!rv));;\n", "out": "Characters 63-67:\n  Format.sprintf(\"%d\" !rv);;\n                 ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%d\" !rv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf \"%d\" (!rv);;\n", "out": "Characters 69-71:\n  Format.sprintf \"%d\" !rv;;\n                       ^^\nError: This expression has type float but an expression was expected of type\n         'a ref\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%f\" !rv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf \"%f\" (!rv);;\n", "out": "Characters 69-71:\n  Format.sprintf \"%f\" !rv;;\n                       ^^\nError: This expression has type float but an expression was expected of type\n         'a ref\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) =  eval (e,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = eval (e, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t when s = k -> i\n  | (s,i)::t -> assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> \nd\n| (s,i)::t -> \nif s = k then \ni \nelse \nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then \nseen \nelse \nh::seen \nin let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f b with\n| (i,true) -> wwhile(f,i)\n| (i, false) -> i", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
