{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> v1\n| _       -> assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> if k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 118-123:\n  let seen' = helper (h::seen', t) in\n                         ^^^^^\nError: Unbound value seen'\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = helper ((h :: seen'), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = helper (h::seen', t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 114-132:\n  let seen' = if List.mem (h, seen) then helper (h::seen, t) in\n                 ^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then helper ((h :: seen), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem (h, seen) then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 135-154:\n  let seen' = if List.mem h seen then helper (h::seen, t) in\n                                      ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then helper ((h :: seen), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 111-121:\n  if List.mem h then\n     ^^^^^^^^^^\nError: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse (h::seen) in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse (h::seen) in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse (h::seen) in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen'\nelse h::seen' in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 136-141:\n  if List.mem h seen then seen'\n                          ^^^^^\nError: Unbound value seen'\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen' else h :: seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h::seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h::seen"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 135-139:\n  let seen' = if List.mem h seen then seen in\n                                      ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen \nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen \nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 62-67:\n  | False -> b'\n    ^^^^^\nError: Unbound constructor False\nHint: Did you mean false?\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | False  -> b' | True  -> wwhile (f, b');;\n", "in": "let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 18-19:\n  let _ = fixpoint (g,0);;\n                    ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (failWith,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-37:\n  let fixpoint (f,b) = wwhile (failWith,b);;\n                               ^^^^^^^^\nError: Unbound value failWith\nHint: Did you mean failwith?\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (failWith, b);;\n", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (failwith,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (failwith,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen \nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": " _ = fixpoint (collatz, 1)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-2:\n  le;;\n  ^^\nError: Unbound value le\n", "min": "\nlet _ = le;;\n", "in": " _ = fixpoint (collatz, 1)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-2:\n  le;;\n  ^^\nError: Unbound value le\n", "min": "\nlet _ = le;;\n", "in": " fixpoint (f,b) = wwhile (f,b)"}, {"type": "scope", "out": "Error: Unbound value b\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 13-14:\n   fixpoint (f,b) = wwhile (f,b);;\n               ^\nError: Unbound value b\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet _ = (fixpoint (f, b)) = (wwhile (f, b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( if b' = b in let (b', c') = f b, b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f', b) in\nlet f' = \nlet b' = f b if\nb = b' then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = \nlet c = f x in (c, c != x) in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = \nlet c = f x in (c, c != x) in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 420-425:\n  | Tresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\";;\n    ^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Tresh does not belong to type expr\nHint: Did you mean Thresh?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToSring ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString expr1) ^ (\" * \" ^ (exprToString expr2))\n  | Tresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToSring ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 285-296:\n  | Average (ex1, ex2)         -> \"((\" ^ exprToSring ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n                                         ^^^^^^^^^^^\nError: Unbound value exprToSring\nHint: Did you mean exprToString?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToSring ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString expr1) ^ (\" * \" ^ (exprToString expr2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 384-389:\n  | Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n                                               ^^^^^\nError: Unbound value expr1\nHint: Did you mean expm1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString expr1) ^ (\" * \" ^ (exprToString expr2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \" * \" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 467-472:\n  | Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\";;\n                                                      ^^^^^\nError: Unbound value expr1\nHint: Did you mean expm1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\" * \" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \" * \" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString ex1 ^ \"<\" ^ exprToString ex2 ^ \" ? \" ^ exprToString ex3 ^ \" : \" ^ exprToString ex4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \"+\" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \"*\" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString ex1 ^ \"<\" ^ exprToString ex2 ^ \"?\" ^ exprToString ex3 ^ \":\" ^ exprToString ex4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin(pi*\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos(pi*\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \"+\" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \"*\" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString ex1 ^ \"<\" ^ exprToString ex2 ^ \"?\" ^ exprToString ex3 ^ \":\" ^ exprToString ex4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (ex)                 -> \"sin(pi*\" ^ exprToString ex ^ \")\"\n| Cosine (ex)               -> \"cos(pi*\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)        -> \"((\" ^ exprToString ex1 ^ \"+\" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)          -> exprToString ex1 ^ \"*\" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString ex1 ^ \"<\" ^ exprToString ex2 ^ \"?\" ^ exprToString ex3 ^ \":\" ^ exprToString ex4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-81:\n  | Sine (ex) -> sin(pi * eval (ex,x,y))\n                     ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (eval (ex, x, y)))\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex) -> sin(pi * (eval (ex,x,y))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)\n\n\n(* uncomment after implementing eval\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-81:\n  | Sine (ex) -> sin(pi * (eval (ex,x,y)))\n                     ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (eval (ex, x, y)))\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 107-109:\n  | Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)\n                                                 ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> let ex1 = eval (ex, x, y) in sin (pi * ex1)\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-83:\n  | Sine (ex)   -> sin(pi * (eval (ex,x,y)))\n                       ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (eval (ex, x, y)))\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 170-184:\n  | Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n                          ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 170-184:\n  | Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n                          ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 169-203:\n  | Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 207-208:\n  | Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2\n                                                               ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 169-203:\n  | Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 233-247:\n  | Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n                         ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value buildTresh\nHint: Did you mean buildThresh?\nError: Unbound value buildTresh\nHint: Did you mean buildTimes?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 379-389:\n  | 5 -> buildTresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1));;\n         ^^^^^^^^^^\nError: Unbound value buildTresh\nHint: Did you mean buildThresh?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (1, 5) in\n     match r with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (1,5) in match r with\n| 1 -> buildSine(build (rand, depth-1))\n| 2 -> buildCosine( build (rand, depth-1))\n| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 5 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, ex)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "assoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 7-9:\n  (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n   ^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k1,v1) -> if k = k1 then v1 else assoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)])\n    23;;\n", "in": "assoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "assoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "removeDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-16:\n  removeDuplicates\n  ^^^^^^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9] [1; 6; 2; 4; 12; 13; 9];;\n", "in": "removeDuplicates\n[1;6;2;4;12;2;13;6;9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "emitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "emitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sam = exprToString (build (rand, 3))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 31-35:\n  let sam = exprToString (build (rand, 3));;\n                                 ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (0, 4) in\n     match r with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sam = exprToString (build (rand, 3));;\n", "in": "let sam = build (rand, 3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 17-21:\n  let sam = build (rand, 3);;\n                   ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (0, 4) in\n     match r with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet sam = build (rand, 3);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = eval (NewExprA(VarX, Vary), 1., -1.);;\n          ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval ((NewExprA (VarX, Vary)), 1., (-1.));;\n", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 468-480:\n  | NewExprB (e1,e2,e3) -> eval(e1,x,y) + eval(e2,x,y) + eval(e3,x,y);;\n                           ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) + (eval (e2, x, y))) + (eval (e3, x, y));;\n", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" exprToString e1 ^ \":\" exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 587-590:\n  | NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" exprToString e1 ^ \":\" exprToString e2\n                                                                       ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 ((\"?\" exprToString e1) ^ (\":\" exprToString e2)))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 611-614:\n  | NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" exprToString e2\n                                                                                               ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" exprToString e2))))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 658-661:\n  | NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\";;\n                           ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 725-727:\n  | NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\";;\n                                                                                              ^^\nError: Unbound value ex\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\")))));;\n", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2 ^ \")\"s\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 635-638:\n  | NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2 ^ \")\"s\n                                                                                                                       ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e1) ^\n                       (\":\" ^ ((exprToString e2) ^ (\")\" s))))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2 ^ \")\"\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2 ^ \")\"\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"-\" ^ exprToString e3 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = eval (NewExprA(VarX, Vary), 1., -1.);;\n          ^^^^\nError: Unbound value eval\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet _ = eval ((NewExprA (VarX, Vary)), 1., (-1.));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (e)   -> sin(pi *. (eval (e,x,y)))\n| Cosine (e) -> cos(pi *. eval (e,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)\n| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)\n| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (e)   -> sin(pi *. (eval (e,x,y)))\n| Cosine (e) -> cos(pi *. eval (e,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)\n| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)\n| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,2) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,9) in match r with\n| 0 -> buildSine( build(rand, depth-1))\n| 1 -> buildCosine( build(rand, depth-1))\n| 2 -> buildAverage( build(rand,depth -1), build(rand, depth -1))\n| 3 -> buildTimes( build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand, depth-1),build(rand,depth-1))\n| 5 -> buildSine( build(rand, depth-1))\n| 6 -> buildCosine( build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,2) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,7) in match r with\n| 0 -> buildSine( build(rand, depth-1))\n| 1 -> buildCosine( build(rand, depth-1))\n| 2 -> buildAverage( build(rand,depth -1), build(rand, depth -1))\n| 3 -> buildTimes( build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand, depth-1),build(rand,depth-1))\n| 5 -> buildSine( build(rand, depth-1))\n| 6 -> buildCosine( build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildNewExprA(e1,e2)           = NewExprA(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| NewExprA of expr * expr\n| NewExprB of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
