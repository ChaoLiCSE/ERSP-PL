{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 64-67:\n  | x :: xs' -> x + sum xs';;\n                    ^^^\nError: Unbound value sum\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sum xs');;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sum xs'"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 64-67:\n  | x :: xs' -> x + sum xs';;\n                    ^^^\nError: Unbound value sum\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sum xs');;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sum xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-97:\n  in digitsOfInt x @ y;;\n                     ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let x = n / 10\n        and y = n mod 10 in (digitsOfInt x) @ y);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin digitsOfInt x @ y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin digitsOfInt x @ [y]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin if x = 0 && y =0 then []\nelse digitsOfInt x @ [y]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin if x = 0 && y = 0 then []\nelse digitsOfInt x @ [y]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n mod 10 = 0) then 0\nelse \nlet x = sumList (digitsOfInt n)\nin 1 + additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n mod 10 = 0) then 0\nelse \nlet x = sumList (digitsOfInt n)\nin 1 + additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 8-15:\n  let x = sumList digitsOfInt 10;;\n          ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList digitsOfInt 10;;\n", "in": "let x = sumList digitsOfInt 10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 8-15:\n  let x = sumList digitsOfInt 10;;\n          ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList digitsOfInt 10;;\n", "in": "let x = sumList digitsOfInt 10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let x = sumList (digitsOfInt 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let x = sumList (digitsOfInt 99)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let x = sumList (digitsOfInt 9876)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let x = sumList (digitsOfInt 30)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n mod 10 = 0 || n/10 = 0) then 0\nelse \nlet x = sumList (digitsOfInt n)\nin 1 + additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n mod 10 = 0 || n/10 = 0) then 0\nelse \nlet x = sumList (digitsOfInt n)\nin (1 + additivePersistence x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n/10 = 0) then 0\nelse \nlet x = sumList (digitsOfInt n)\nin 1 + additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n/10 = 0) then n\nelse \nlet x = sumList (digitsOfInt n)\nin digitalRoot x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-75:\n  | x :: l' -> listReverse l' @ [x];;\n               ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') @ [x];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l' @ [x]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-76:\n  | x :: l' -> listReverse [l'] @ [x];;\n                            ^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse [l']) @ [x];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-76:\n  | x :: l' -> listReverse [l'] @ [x];;\n                            ^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse [l']) @ [x];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-78:\n  | x :: l' -> listReverse l'::x;;\n               ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') :: x;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'::x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-80:\n  | x :: l' -> listReverse l'::[x];;\n               ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l = match l with | [] -> 0 | x::l' -> [listReverse l'; x];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'::[x]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-80:\n  | x :: xl -> listReverse x :: [];;\n               ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l = match l with | [] -> 0 | x::xl -> [listReverse x];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: xl -> listReverse x :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-81:\n  | x :: xl -> listReverse xl :: [];;\n               ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l = match l with | [] -> 0 | x::xl -> [listReverse xl];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: xl -> listReverse xl :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-68:\n  | head::tail -> tail;;\n                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l = match l with | [] -> 0 | head::tail -> tail;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| head::tail -> tail"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-70:\n  | head :: tail -> tail;;\n                    ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l = match l with | [] -> 0 | head::tail -> tail;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| head :: tail -> tail"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-100:\n  | head::tail -> listReverse tail @ head;;\n                                     ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ head;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] ->[x]\n| head::tail -> listReverse tail @ head"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] ->[x]\n| head::tail -> listReverse tail @ [head]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 23-34:\n  if listReverse explode w = w then true\n     ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse explode w) = w then true else false;;\n", "in": "let palindrome w = \nif listReverse explode w = w then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 51-52:\n  if (listReverse (explode w)) = w then true\n                                 ^\nError: This expression has type string but an expression was expected of type\n         char list\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse (explode w)) = w then true else false;;\n", "in": "let palindrome w = \nif (listReverse (explode w)) = w then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \n(listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 51-52:\n  if (listReverse (explode w)) = w then 1\n                                 ^\nError: This expression has type string but an expression was expected of type\n         char list\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse (explode w)) = w then 1 else 0;;\n", "in": "let palindrome w = \nif (listReverse (explode w)) = w then 1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nif (listReverse (explode w)) = explode w then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-90:\n  | head::tail -> listReverse tail::head;;\n                  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with\n  | _ -> []\n  | x -> [x]\n  | head::tail -> (listReverse tail) :: head;;\n", "in": "let rec listReverse l = \nmatch l with\n| _ -> []\n| x ->[x]\n| head::tail -> listReverse tail::head"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-81:\n  | head::tail -> listReverse tail::[head];;\n                  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | x::[] -> x | head::tail -> [listReverse tail; head];;\n", "in": "let rec listReverse l = \nmatch l with\n| [x] -> x\n| head::tail -> listReverse tail::[head]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> head::tail::t::s"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-85:\n  | head::tail::t::s -> s::t::tail::head;;\n                        ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s -> s :: t :: tail :: head;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> s::t::tail::head"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-85:\n  | head::tail::t::s -> s::t::tail::head;;\n                        ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s -> s :: t :: tail :: head;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> s::t::tail::head"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 99-103:\n  | head::tail::t::s::l -> s::t::tail::head;;\n                                       ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s::l -> s :: t :: tail :: head;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s::l -> s::t::tail::head"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-95:\n  | head::tail::third -> head::tail;;\n                               ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> [x] | head::tail::third -> head :: tail;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::tail"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::[tail]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-99:\n  | head::tail::third::fourth -> fourth::third::tail::[head];;\n                                 ^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::third::fourth -> [fourth; third; tail; head];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third::fourth -> fourth::third::tail::[head]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third::fourth::fifth -> fourth::third::tail::[head]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-100:\n  | head::tail -> head::listReverse tail::tail;;\n                        ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> head :: (listReverse tail) :: tail;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail::tail"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec helper l a = \nmatch l with \n| [] -> a\n| head::tail -> helper tail (head::a) in\nhelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = n/10 \nand y = n mod 10 in \nif x = 0 && y = 0 then []\nelse listReverse (y::digitsOfInt x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = n/10 \nand y = n mod 10 in \nif x = 0 && y = 0 then []\nelse let result = y::digitsOfInt x in\nlistReverse result"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = n/10 \nand y = n mod 10 in \nif x = 0 && y = 0 then []\nelse let result = y::digitsOfInt x in\nlistReverse result"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-9:\n  let x = m/10 \n          ^\nError: Unbound value m\n", "min": "\nlet listReverse l =\n  let rec helper l a =\n    match l with | [] -> a | head::tail -> helper tail (head :: a) in\n  helper l [];;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0)\n     then []\n     else (let result = y :: (digitsOfInt x) in listReverse result));;\n\nlet _ =\n  let x = m / 10\n  and y = m mod 10 in if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-68:\n  and x = m/10 \n          ^\nError: Unbound value m\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = n\n     and x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-68:\n  and x = m/10 \n          ^\nError: Unbound value m\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = n\n     and x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-68:\n  and x = m/10 \n          ^\nError: Unbound value m\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = n\n     and x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 77-78:\n  and x = m/10 \n          ^\nError: Unbound value m\n", "min": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = reverseInt n\n     and x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = reverseInt n\nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-81:\n  in let x = m/10 \n             ^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = reverseInt n in\n     let x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = reverseInt n\nin let x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-68:\n  let x = reverseInt n/10 \n          ^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n) / 10\n     and y = (reverseInt n) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n/10 \nand y = reverseInt n mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-95:\n  and y = reverseInt n mod 10 in \n          ^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n 0) / 10\n     and y = (reverseInt n) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "string_of_int ex;\n\n\nlet rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n /10 \nand y = reverseInt n  mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 14-15:\n  string_of_int x;;;\n                ^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet x = \"13\";;\n\nlet _ = string_of_int x;;\n", "in": "int_of_string x;\n\n\nlet rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n /10 \nand y = reverseInt n  mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-91:\n  and y= x /10 \n         ^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-91:\n  and y= x /10 \n         ^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-91:\n  and y= x /10 \n         ^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-91:\n  and y= x /10 \n         ^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-91:\n  and y= x /10 \n         ^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = int_of_string reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-69:\n  let x = int_of_string reverse (string_of_int n) \n          ^^^^^^^^^^^^^\nError: This function has type string -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = int_of_string reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) \nand n2 = int_of_string s  \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 106-107:\n  and n2 = int_of_string s  \n                         ^\nError: Unbound value s\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet x = \"123\";;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n)\n     and n2 = int_of_string s\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s  \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 120-121:\n  and z = x mod 10 in \n          ^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet x = \"123\";;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s  in\nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then [];\nif z = 0 then \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s then z++ in\ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse n in z = z+1"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 and let n2 = reverse n in z = z+1"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0"}, {"type": "scope", "out": "Characters 17-18:\n  let n2 = reverse n in z = z+1;;\n                   ^\nError: Unbound value n\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet _ = let n2 = reverse n in z = (z + 1);;\n", "in": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse n in z = z+1"}, {"type": "type", "out": "Characters 78-79:\n  else if z = 0 then let n2 = reverse n in z = z+1;;\n                                      ^\nError: This expression has type int but an expression was expected of type\n         bytes = string\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0 then [] else if z = 0 then (let n2 = reverse n in z = (z + 1));;\n", "in": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n) in z = z+1"}, {"type": "type", "out": "Characters 99-106:\n  else if z = 0 then let n2 = reverse (string_of_int n) in z = z+1;;\n                                                           ^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if z = 0 then (let n2 = reverse (string_of_int n) in z = (z + 1));;\n", "in": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n) in z+1"}, {"type": "type", "out": "Characters 99-102:\n  else if z = 0 then let n2 = reverse (string_of_int n) in z+1;;\n                                                           ^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if z = 0 then (let n2 = reverse (string_of_int n) in z + 1);;\n", "in": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitOfInt n2"}, {"type": "scope", "out": "Characters 111-121:\n  digitOfInt n2;;\n  ^^^^^^^^^^\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitOfInt n2);;\n", "in": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2"}, {"type": "type", "out": "Characters 111-125:\n  digitsOfInt n2;;\n  ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2);;\n", "in": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-10:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 186-188:\n  if x = 0 && y = 0 then []\n                         ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then\n      (let n2 = reverse (string_of_int n)\n       and z = 1 in\n       digitsOfInt n2;\n       (let x = n2 / 10\n        and y = n2 mod 10 in\n        if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x)));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 141-143:\n  let x = n2/10 \n          ^^\nError: Unbound value n2\n", "min": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n2 / 10\n       and y = n2 mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-112:\n  let c = s2.[i] in\n          ^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec digitsOfInt n =\n  let s = string_of_int n in\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s2.[i] in s2.[i] <- s2.[(n - i) - 1]; s2.[(n - i) - 1] <- c)\n  done;\n  int_of_string s2;;\n", "in": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-112:\n  let c = s2.[i] in\n          ^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec digitsOfInt n =\n  let s = string_of_int n in\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s2.[i] in s2.[i] <- s2.[(n - i) - 1]; s2.[(n - i) - 1] <- c)\n  done;\n  int_of_string s2;;\n", "in": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-51:\n  else if z = 0 then \n          ^\nError: Unbound value z\n", "min": "\nlet rec reverse s =\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(s2 - i) - 1]; s.[(s2 - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let z = 0;\n\nlet rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = true then \nlet n2 = reverse (string_of_int n)\nand z = false in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z then \nlet n2 = reverse (string_of_int n)\nand z = false in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = digitsOfInt 3124;;\n          ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 70-77:\n  let n2 = reverse (string_of_int n)\n           ^^^^^^^\nError: Unbound value reverse\n", "min": "\nlet rec digitsOfInt n z =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2 0;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 70-77:\n  let n2 = reverse (string_of_int n)\n           ^^^^^^^\nError: Unbound value reverse\n", "min": "\nlet rec digitsOfInt n z =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2 0)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2 0;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x 0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = digitsOfInt (-42313);;\n          ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet _ = digitsOfInt (-42313);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec helper n a =\nmatch n with\n| n < 0 -> []\n| n < 10 -> [n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1*(10**s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 152-154:\n  and rest = n - 1*(10**s) in\n                    ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = n - (1 * (10 ** s)) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n. - 1.*(10.**s.) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 145-159:\n  and rest = float_of_int n - 1.*(10.** float_of_int s) in\n             ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = (float_of_int n) - (1. * (10. ** (float_of_int s))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = (float_of_int n) - 1.*(10.** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 145-161:\n  and rest = (float_of_int n) - 1.*(10.** float_of_int s) in\n             ^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = (float_of_int n) - (1. * (10. ** (float_of_int s))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1* int_of_float (10 ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 166-168:\n  and rest = n - 1* int_of_float (10 ** float_of_int s) in\n                                  ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = n - (1 * (int_of_float (10 ** (float_of_int s)))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1* int_of_float (10. ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 186-187:\n  and rest = n - 1* int_of_float (10. ** float_of_int s) in\n                                                      ^\nError: Unbound value s\n", "min": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = n - (1 * (int_of_float (10. ** (float_of_int s)))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 207-208:\n  if x = 0 && y = 0 then []\n              ^\nError: Unbound value y\n", "min": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n) in\n       let rest = n - (1 * (int_of_float (10. ** (float_of_int s)))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) then\nhead::digitsOfInt rest"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s);\nhead::digitsOfInt rest;"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse let n2 = rev (string_of_int) in\nlet rec reverse n2 = \nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::reverse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse let n2 = rev (string_of_int n) in\nlet rec reverse n3 = \nlet x = n3/10 \nand y = n3 mod 10 in\nif x = 0 && y = 0 then []\nelse y::reverse x in\nreverse n2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse let n2 = rev (string_of_int n) in\nlet rec reverse n3 = \nlet x = n3/10 \nand y = n3 mod 10 in\nif x = 0 && y = 0 then []\nelse y::reverse x in\nreverse n2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"}]}
