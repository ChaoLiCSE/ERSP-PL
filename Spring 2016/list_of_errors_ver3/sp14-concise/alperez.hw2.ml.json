{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> d", "min": "\nlet rec assoc (d,k,l) = match l with | [] -> d | h::t -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = let (b',c') = f b in \nif c'\nthen f b'\nelse b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "out": "Characters 66-68:\n  else b';;\n       ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = let (bs,cs) = f b in \nif cs\nthen f bs\nelse bs", "min": "\nlet rec wwhile (f,b) = let (bs,cs) = f b in if cs then f bs else bs;;\n", "out": "Characters 66-68:\n  else bs;;\n       ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 50) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 50)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 0) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 0)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 10) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 10)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 513) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 513)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c'\nthen wwhile (f,b')\nelse b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 1)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b'=b then\nb\nelse \n(f,b')", "min": "\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else (f, b');;\n", "out": "Characters 60-61:\n  (f,b');;\n   ^\nError: This expression has type 'a * 'b -> 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b -> 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b'=b then\nb\nelse \nfixpoint (f,b')", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nwwhile (f,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = let (a',b')=wwhile (f,b)in a'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let (a',b') = wwhile (f, b) in a';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nlet b' = (b, f b = b) in b'", "min": "\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet b' = (b, f b = b) in \nwwhile (f,b')", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in wwhile (f, b');;\n", "out": "Characters 56-57:\n  wwhile (f,b');;\n          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet b' = (b, (f b = b)) in \nwwhile (f,b')", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in wwhile (f, b');;\n", "out": "Characters 58-59:\n  wwhile (f,b');;\n          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet b' = (b, (f b < b)) in \nwwhile (f,b')", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) < b)) in wwhile (f, b');;\n", "out": "Characters 58-59:\n  wwhile (f,b');;\n          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nlet f' = (f b, f'=b ) in\nwwhile (f',b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' = ((f b), (f' = b)) in wwhile (f', b);;\n", "out": "Characters 37-39:\n  let f' = (f b, f'=b ) in\n                 ^^\nError: Unbound value f'\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet f' = (f b, f b=b ) in\nwwhile (f',b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' = ((f b), ((f b) = b)) in wwhile (f', b);;\n", "out": "Characters 56-58:\n  wwhile (f',b);;\n          ^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), (b = (f b))) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), (b = (f b))) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nwwhile (f,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet f' = fun f -> fun b -> (f b, b=f b) in\nwwhile(f',b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' f b = ((f b), (b = (f b))) in wwhile (f', b);;\n", "out": "Characters 72-74:\n  wwhile(f',b);;\n         ^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       Type 'a -> 'a * bool is not compatible with type ('a -> 'a) * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nfailwith \"to be d\"", "min": "\nlet fixpoint (f,b) = failwith \"to be d\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 1)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 110)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 110);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in (b', b'= b) in\nwwhile (f, b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', (b' = b)) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c'\nthen wwhile (f,b')\nelse b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in (b', b=b') in\nwwhile (f, b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', (b = b')) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', (b = b')) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = (x-1) in fixpoint (g,8)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', (b = b')) in wwhile (f, b);;\n\nlet _ = let g x = x - 1 in fixpoint (g, 8);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in (b', b=b') in\nb=b'", "min": "\nlet fixpoint (f,b) = let f b = let b' = f b in (b', (b = b')) in b = b';;\n", "out": "Characters 63-65:\n  b=b';;\n    ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in\n\nlet g x = (x-1) in fixpoint (g,8)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', (b = b')) in wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in b = b' in let g x = x - 1 in fixpoint (g, 8);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in b'", "min": "\nlet fixpoint (f,b) = let f b = let b' = f b in b = b' in b';;\n", "out": "Characters 55-57:\n  let f b = let b' = f b in b=b' in b';;\n                                    ^^\nError: Unbound value b'\n"}, {"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', (b = b')) in wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in b = b' in let g x = x - 1 in fixpoint (g, 8);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nf b = b'", "min": "\nlet fixpoint (f,b) = (f b) = b';;\n", "out": "Characters 27-29:\n  f b = b';;\n        ^^\nError: Unbound value b'\n"}, {"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', (b = b')) in wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in b = b' in let g x = x - 1 in fixpoint (g, 8);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nf b = b", "min": "\nlet fixpoint (f,b) = (f b) = b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b != b) in\nwwhile (f, b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) != b)) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) != b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b != b) in\nwwhile (f, b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) != b)) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) != b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = failwith \"to be written\"", "min": "\nlet rec exprToString e = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = failwith \"to be written\"", "min": "\nlet rec exprToString e = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\" | VarY  -> \"y\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^exprToString", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n", "out": "Characters 84-96:\n  | Sine m -> \"sin\"^exprToString;;\n                    ^^^^^^^^^^^^\nError: This expression has type expr -> string\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^ exprToString m", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let b = exprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n", "out": "Characters 8-20:\n  let b = exprToString Sine(VarX);;\n          ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let b = exprToString (Sine(VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString (Sine VarX);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average m,n -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "out": "Characters 153-164:\n  | Average m,n -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\";;\n    ^^^^^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "out": "Characters 177-189:\n  | Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\";;\n                            ^^^^^^^^^^^^\nError: Unbound value exprToStirng\nHint: Did you mean exprToString?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let b = exprToString (Cosine(VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n\nlet b = exprToString (Cosine VarX);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let b = exprToString (Average(VarX,VarY))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n\nlet b = exprToString (Average (VarX, VarY));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let b = exprToString (Average(Cosine(VarX),VarY))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n\nlet b = exprToString (Average ((Cosine VarX), VarY));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Tresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "out": "Characters 281-286:\n  | Tresh (m,n,o,p) -> \n    ^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Tresh does not belong to type expr\nHint: Did you mean Thresh?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let b = exprToString (Average(Cosine(VarX),VarY))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n\nlet b = exprToString (Average ((Cosine VarX), VarY));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let b = exprToString (Average(Cosine(VarX),VarY))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n\nlet b = exprToString (Average ((Cosine VarX), VarY));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildY()                       = VarY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval m))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m));;\n", "out": "Characters 75-76:\n  | Sine m -> sin(pi*. (eval m));;\n                             ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval m))\n| _ -> x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m)) | _ -> x;;\n", "out": "Characters 75-76:\n  | Sine m -> sin(pi*. (eval m))\n                             ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| _ -> x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval (m, x, y))) | _ -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval(m,x,y)+.eval(n,x,y))/2.", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "out": "Characters 155-181:\n  | Average (m,n) -> (eval(m,x,y)+.eval(n,x,y))/2.;;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2.", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "out": "Characters 155-183:\n  | Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2.;;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2.", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "out": "Characters 155-185:\n  | Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2.;;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "min": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = rand 1 2", "min": "\nlet rec build (rand,depth) = rand 1 2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = rand", "min": "\nlet rec build (rand,depth) = rand;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = rand 1 2", "min": "\nlet rec build (rand,depth) = rand 1 2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = depth", "min": "\nlet rec build (rand,depth) = depth;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = 1", "min": "\nlet rec build (rand,depth) = 1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = rand", "min": "\nlet rec build (rand,depth) = rand;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = failwith \"tbd\"", "min": "\nlet rec build (rand,depth) = failwith \"tbd\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = rand 3 4", "min": "\nlet rec build (rand,depth) = rand 3 4;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = let num = rand 4 53 in\nmatch num with\n| _ -> VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  let num = rand 4 53 in match num with | _ -> VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = let num = rand 4 53 in\nmatch num with\n| 1 -> VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  let num = rand 4 53 in match num with | 1 -> VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 1 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 1 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand(x1,x2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand(x1,x2) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (x1, x2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (x1, x2) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": "Characters 63-65:\n  let num = rand(x1,x2) in\n                 ^^\nError: Unbound value x1\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 1 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 1 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 2 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 2 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 2 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num (a,b) = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num (a,b) = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num (a,b) = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num (a,b) = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": "Characters 89-90:\n  | 0 -> VarX\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a * 'b -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> BuildSine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": "Characters 165-174:\n  | 0 -> BuildSine(build(rand,depth-1))\n         ^^^^^^^^^\nError: This variant expression is expected to have type expr\n       The constructor BuildSine does not belong to type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),buildAverage(build(rand,depth-1)))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))),\n             (buildAverage (build (rand, (depth - 1)))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": "Characters 248-269:\n  | 1 -> buildAverage(build(rand,depth-1),buildAverage(build(rand,depth-1)))\n                                                      ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildThresh(build(rand,depth-1), build(rand,depth-1),\nbuild(rand,depth-1), build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n(*| 3 -> buildThresh(build(rand,depth-1), build(rand,depth-1),\nbuild(rand,depth-1), build(rand,depth-1))*)\n| _ -> buildCosine(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Divide   of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divide of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Divide (m,n)      -> exprToString m ^ \"/\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divide of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Divide (m,n) -> (exprToString m) ^ (\"/\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Divide (m,n)      -> \"(\" ^ exprToString m ^ \"/\" ^ exprToString n^\"(\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divide of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Divide (m,n) ->\n      \"(\" ^ ((exprToString m) ^ (\"/\" ^ ((exprToString n) ^ \"(\")))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Divide (m,n)      -> \"(\" ^ exprToString m ^ \"/\" ^ exprToString n^\")\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divide of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Divide (m,n) ->\n      \"(\" ^ ((exprToString m) ^ (\"/\" ^ ((exprToString n) ^ \")\")))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Square   of expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Square of expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Square of expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "out": "Characters 163-164:\n  | Square m -> eval(m,x,y)**2\n                             ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> buildSquare (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildSquare(build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExp    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExp of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExpr    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ expToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (expToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "out": "Characters 437-448:\n  | MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ expToString  ^\"?sqrt(|\" ^\n                                                     ^^^^^^^^^^^\nError: Unbound value expToString\nHint: Did you mean exprToString?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (exprToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "out": "Characters 437-449:\n  | MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString  ^\"?sqrt(|\" ^\n                                                     ^^^^^^^^^^^^\nError: This expression has type expr -> string\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString n ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExpr   of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "out": "Characters 371-372:\n  else eval(o,x,y) /. 2\n                      ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y))) \nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExpr   of expr * expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildMyExpr(a,b,a_less,b_less) = MyExpr(a,b,a_less,b_less)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExpr   of expr * expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
