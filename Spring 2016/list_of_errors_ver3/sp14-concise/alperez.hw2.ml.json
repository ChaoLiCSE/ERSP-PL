{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-68:\n  else b';;\n       ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "in": "let rec wwhile (f,b) = let (b',c') = f b in \nif c'\nthen f b'\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-68:\n  else bs;;\n       ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (bs,cs) = f b in if cs then f bs else bs;;\n", "in": "let rec wwhile (f,b) = let (bs,cs) = f b in \nif cs\nthen f bs\nelse bs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 50) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 0) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 10) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 513) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c'\nthen wwhile (f,b')\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b'=b then\nb\nelse \n(f,b')"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-61:\n  (f,b');;\n   ^\nError: This expression has type 'a * 'b -> 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b -> 'a * 'b\n", "min": "\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else (f, b');;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b'=b then\nb\nelse \nfixpoint (f,b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = let (a',b')=wwhile (f,b)in a'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet b' = (b, f b = b) in b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet b' = (b, f b = b) in \nwwhile (f,b')"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-57:\n  wwhile (f,b');;\n          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in wwhile (f, b');;\n", "in": "let fixpoint (f,b) = \nlet b' = (b, (f b = b)) in \nwwhile (f,b')"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-59:\n  wwhile (f,b');;\n          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in wwhile (f, b');;\n", "in": "let fixpoint (f,b) = \nlet b' = (b, (f b < b)) in \nwwhile (f,b')"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-59:\n  wwhile (f,b');;\n          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) < b)) in wwhile (f, b');;\n", "in": "let fixpoint (f,b) = \nlet f' = (f b, f'=b ) in\nwwhile (f',b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 37-39:\n  let f' = (f b, f'=b ) in\n                 ^^\nError: Unbound value f'\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' = ((f b), (f' = b)) in wwhile (f', b);;\n", "in": "let fixpoint (f,b) = \nlet f' = (f b, f b=b ) in\nwwhile (f',b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-58:\n  wwhile (f',b);;\n          ^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' = ((f b), ((f b) = b)) in wwhile (f', b);;\n", "in": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nlet f' = f b -> (f b, b=f b) in\nwwhile(f',b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-74:\n  wwhile(f',b);;\n         ^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       Type 'a -> 'a * bool is not compatible with type ('a -> 'a) * bool \n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' f b = ((f b), (b = (f b))) in wwhile (f', b);;\n", "in": "let fixpoint (f,b) =\nfailwith \"to be d\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 110)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b (b', b'= b) in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c'\nthen wwhile (f,b')\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in (b', b=b') in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = (x-1) in fixpoint (g,8)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in (b', b=b') in\nb=b'"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-65:\n  b=b';;\n    ^^\nError: Unbound value b'\n", "min": "\nlet fixpoint (f,b) = let f b = let b' = f b in (b', (b = b')) in b = b';;\n", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nf b = b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nf b = b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b != b) in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) =\nlet f b = (f b, f b != b) in\nwwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let a = Zero;;\n          ^^^^\nError: Unbound constructor Zero\n", "min": "\nlet a = Zero;;\n", "in": "let rec exprToString e = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^exprToString"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-96:\n  | Sine m -> \"sin\"^exprToString;;\n                    ^^^^^^^^^^^^\nError: This expression has type expr -> string\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^ exprToString m"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = exprToString Sine(VarX)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 8-20:\n  let b = exprToString Sine(VarX);;\n          ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n", "in": "let b = exprToString (Sine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average m,n -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 153-164:\n  | Average m,n -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\";;\n    ^^^^^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 177-189:\n  | Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\";;\n                            ^^^^^^^^^^^^\nError: Unbound value exprToStirng\nHint: Did you mean exprToString?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = exprToString (Cosine(VarX))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = exprToString (Average(VarX,VarY))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = exprToString (Average(Cosine(VarX),VarY))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n|\n\nlet b = exprToString (Average(Cosine(VarX),VarY))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Tresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 281-286:\n  | Tresh (m,n,o,p) -> \n    ^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Tresh does not belong to type expr\nHint: Did you mean Thresh?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = exprToString (Average(Cosine(VarX),VarY))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = exprToString (Average(Cosine(VarX),VarY))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildY()                       = VarY"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval m))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-76:\n  | Sine m -> sin(pi*. (eval m));;\n                             ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval m))\n| _ -> x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-76:\n  | Sine m -> sin(pi*. (eval m))\n                             ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m)) | _ -> x;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| _ -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval(m,x,y)+.eval(n,x,y))/2."}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 155-181:\n  | Average (m,n) -> (eval(m,x,y)+.eval(n,x,y))/2.;;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2."}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 155-183:\n  | Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2.;;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2."}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 155-185:\n  | Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2.;;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2."}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \neval(m,x,y) < eval(n,x,y) ? eval(o,x,y) : eval(p,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 35-36:\n  let rec build (rand, depth) = rand i j;;\n                                     ^\nError: Unbound value i\n", "min": "\nlet rec build (rand,depth) = rand i j;;\n", "in": "let rec build (rand, depth) = rand 1 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = rand"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = rand 1 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = depth"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = rand"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = failwith \"tbd\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = rand (1,3);;\n          ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\nlet _ = rand (1, 3);;\n", "in": "let rec build (rand, depth) = rand 3 4"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = let num = rand 4 53 in\nmatch num with\n| _ -> VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = let num = rand 4 53 in\nmatch num with\n| 1 -> VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 1 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand(x1,x2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand(x1,x2) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-65:\n  let num = rand(x1,x2) in\n                 ^^\nError: Unbound value x1\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (x1, x2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (x1, x2) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 1 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 2 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 92-93:\n  let e1 = build (g, depth) in\n                  ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}, {"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 2 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 2 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num (a,b) = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num (a,b) = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 89-90:\n  | 0 -> VarX\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a * 'b -> 'c\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num (a,b) = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num (a,b) = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 11-15:\n  let num  = rand (0,1);;\n             ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\nlet num = rand (0, 1);;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> BuildSine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 165-174:\n  | 0 -> BuildSine(build(rand,depth-1))\n         ^^^^^^^^^\nError: This variant expression is expected to have type expr\n       The constructor BuildSine does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),buildAverage(build(rand,depth-1)))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 248-269:\n  | 1 -> buildAverage(build(rand,depth-1),buildAverage(build(rand,depth-1)))\n                                                      ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))),\n             (buildAverage (build (rand, (depth - 1)))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildThresh(build(rand,depth-1), build(rand,depth-1),\nbuild(rand,depth-1), build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n(*| 3 -> buildThresh(build(rand,depth-1), build(rand,depth-1),\nbuild(rand,depth-1), build(rand,depth-1))*)\n| _ -> buildCosine(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Divide   of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Divide (m,n)      -> exprToString m ^ \"/\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Divide (m,n)      -> \"(\" ^ exprToString m ^ \"/\" ^ exprToString n^\"(\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Divide (m,n)      -> \"(\" ^ exprToString m ^ \"/\" ^ exprToString n^\")\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Square   of expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This variant expression is expected to have type expr\n       The constructor Square does not belong to type expr\nError: This variant pattern is expected to have type expr\n       The constructor Divide does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-20:\n  let _ = eval (Square(VarX),1.0,0.5);;\n                ^^^^^^\nError: This variant expression is expected to have type expr\n       The constructor Square does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divide of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Divide (m,n) -> (eval (m, x, y)) /. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet _ = eval ((Square VarX), 1.0, 0.5);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 163-164:\n  | Square m -> eval(m,x,y)**2\n                             ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildSquare(build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExp    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\nHint: Did you mean MyExp?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 21-27:\n  let _ = exprToString(MyExpr(VarX,VarY,VarX));;\n                       ^^^^^^\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExp of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet _ = exprToString (MyExpr (VarX, VarY, VarX));;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExpr    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ expToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "NO ERROR FROM MINIMAL PROGRAM!!!\nCharacters 21-27:\n  let _ = exprToString(MyExpr(VarX,VarY,VarX));;\n                       ^^^^^^\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet _ = exprToString (MyExpr (VarX, VarY, VarX));;\n", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ expToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value expToString\nHint: Did you mean exprToString?\nError: Unbound value expToString\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 8-19:\n  let _ = expToString(MyExpr(VarX,VarY,VarX));;\n          ^^^^^^^^^^^\nError: Unbound value expToString\nHint: Did you mean exprToString?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = expToString (MyExpr (VarX, VarY, VarX));;\n", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "NO ERROR FROM MINIMAL PROGRAM!!!\nCharacters 21-27:\n  let _ = exprToString(MyExpr(VarX,VarY,VarX));;\n                       ^^^^^^\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet _ = exprToString (MyExpr (VarX, VarY, VarX));;\n", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString n ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExpr   of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 371-372:\n  else eval(o,x,y) /. 2\n                      ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y))) \nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExpr   of expr * expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildMyExpr(a,b,a_less,b_less) = MyExpr(a,b,a_less,b_less)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Square   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| MyExpr   of expr * expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This expression has type expr/2623\n       but an expression was expected of type expr/2890\nError: This expression has type expr/3015\n       but an expression was expected of type expr/3037\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: This expression has type expr/2623\n       but an expression was expected of type expr/2890\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
