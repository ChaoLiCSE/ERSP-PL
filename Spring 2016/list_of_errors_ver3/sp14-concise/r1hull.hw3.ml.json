{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = (+) x in\nlet base = [] in\nList.fold_left f base xs", "min": "\nlet sqsum xs = let f a x = (+) x in let base = [] in List.fold_left f base xs;;\n", "out": "Characters 71-75:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int -> int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = (+) x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs = let f a x = (+) x in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 70-74:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  a' in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = a' in List.fold_left f base fs;;\n", "out": "Characters 46-48:\n  let base =  a' in\n              ^^\nError: Unbound value a'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  f in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  fs in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "out": "Characters 74-76:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  x a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x a in List.fold_left f base fs;;\n", "out": "Characters 46-47:\n  let base =  x a in\n              ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 46-47:\n  let base =  a in\n              ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x (f a) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x (f a) in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 30-31:\n  let f a x = x (f a) in\n                 ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n", "out": "Characters 47-48:\n  let base = f a in\n               ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (f) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f g in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f g in List.fold_left f base fs;;\n", "out": "Characters 47-48:\n  let base = f g in\n               ^\nError: Unbound value g\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f base in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in let base = f base in List.fold_left f base fs;;\n", "out": "Characters 47-51:\n  let base = f base in\n               ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = (+) in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = () in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (base) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "out": "Characters 45-51:\n  let base = (base) in\n             ^^^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x a in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = x a in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet rec base = base in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in let rec base = base in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun q ->  x (a q)in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x q = x (a q) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun q ->  x (a q)in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x q = x (a q) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = sepConcat(\";\" List.map(f l))", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\" List.map (f l));;\n", "out": "Characters 33-36:\n  let stringOfList f l = sepConcat(\";\" List.map(f l));;\n                                   ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = sepConcat(\"\" List.map(f l))", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\"\" List.map (f l));;\n", "out": "Characters 33-35:\n  let stringOfList f l = sepConcat(\"\" List.map(f l));;\n                                   ^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = sepConcat(\"\" List.map(f l))", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\"\" List.map (f l));;\n", "out": "Characters 33-35:\n  let stringOfList f l = sepConcat(\"\" List.map(f l));;\n                                   ^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = sepConcat\"\" List.map(f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" List.map (f l);;\n", "out": "Characters 23-32:\n  let stringOfList f l = sepConcat\"\" List.map(f l);;\n                         ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = sepConcat \"\" List.map(f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" List.map (f l);;\n", "out": "Characters 23-32:\n  let stringOfList f l = sepConcat \"\" List.map(f l);;\n                         ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = let x = List.map(f l) in\nsepConcat \";\" x", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map (f l) in sepConcat \";\" x;;\n", "out": "Characters 62-63:\n  sepConcat \";\" x;;\n                ^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = sepConcat \";\" List.map f l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map f l;;\n", "out": "Characters 23-32:\n  let stringOfList f l = sepConcat \";\" List.map f l;;\n                         ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \"[;\" x", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \"[;\" x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet x = List.map f l  in\n\"[\"^(sepConcat \";\" x) ^\"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let x = List.map f l in \"[\" ^ ((sepConcat \";\" x) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet x = List.map f l  in\n\"[\"^(sepConcat \";\" x)^\"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let x = List.map f l in \"[\" ^ ((sepConcat \";\" x) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nif n <= 0 then []\nelse n :: clone x n-1", "min": "\nlet rec clone x n = if n <= 0 then [] else n :: ((clone x n) - 1);;\n", "out": "Characters 49-58:\n  else n :: clone x n-1;;\n            ^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nif n <= 0 then []\nelse n :: (clone x n-1)", "min": "\nlet rec clone x n = if n <= 0 then [] else n :: ((clone x n) - 1);;\n", "out": "Characters 50-59:\n  else n :: (clone x n-1);;\n             ^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse n :: (clone x (n-1))", "min": "\nlet rec clone x n = if n <= 0 then [] else n :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: (clone x (n-1))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: (clone x (n-1))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then clone 0 (x2-x1)\nelse clone 0 (x1-x2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then clone 0 (x2 - x1) else clone 0 (x1 - x2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then x1 @ clone 0 (x2-x1)\nelse x2 @ clone 0 (x1-x2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then x1 @ (clone 0 (x2 - x1)) else x2 @ (clone 0 (x1 - x2));;\n", "out": "Characters 93-95:\n  if x1 < x2 then x1 @ clone 0 (x2-x1)\n                  ^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then l1 @ clone 0 (x2-x1)\nelse l2 @ clone 0 (x1-x2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then l1 @ (clone 0 (x2 - x1)) else l2 @ (clone 0 (x1 - x2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then l1 @ (clone 0 (x2-x1))\nelse l2 @ (clone 0 (x1-x2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then l1 @ (clone 0 (x2 - x1)) else l2 @ (clone 0 (x1 - x2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then (l1 @ (clone 0 (x2-x1)), l2)\nelse (l1, l2 @ (clone 0 (x1-x2)))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then ((l1 @ (clone 0 (x2 - x1))), l2)\n  else (l1, (l2 @ (clone 0 (x1 - x2))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then ((clone 0 (x2-x1)) @ l1, l2)\nelse (l1, (clone 0 (x1-x2) @ l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h <> 0 then l else removeZero t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h <> 0 then l else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::[] -> if h <> 0 then l else []\n| h::t -> if h <> 0 then l else removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = a + x**2 in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 35-36:\n  let f a x = a + x**2 in\n                     ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = a + x**2.0 in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 32-38:\n  let f a x = a + x**2.0 in\n                  ^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 77-81:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0.0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2.0) in let base = 0.0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = a + x**2 in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 35-36:\n  let f a x = a + x**2 in\n                     ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let sqsum xs = \nlet f a x = a + (pow x 2) in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (pow x 2) in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 33-36:\n  let f a x = a + (pow x 2) in\n                   ^^^\nError: Unbound value pow\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + int_of_float(float_of_int(x)**2.0) in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (int_of_float ((float_of_int x) ** 2.0)) in\n  let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun q ->  x (a q)in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x q = x (a q) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 101-109:\n  let args = List.combine (l1, l2) in\n                          ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 147-151:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 143-147:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::[] -> if h <> 0 then l else []\n| h::t -> if h <> 0 then l else removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + int_of_float(float_of_int(x)**2.0) in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (int_of_float ((float_of_int x) ** 2.0)) in\n  let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l", "min": "\nlet rec mulByDigit i l = if i <> 0 then mulByDigit (i - 1) bigAdd l l else l;;\n", "out": "Characters 58-64:\n  if i <> 0 then mulByDigit (i-1) bigAdd l l\n                                  ^^^^^^\nError: Unbound value bigAdd\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::[] -> if h <> 0 then l else []\n| h::t -> if h <> 0 then l else removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (hold, res) = f a x in\nmatch x with\n| (x1, x2) :: (x3, x4) :: t -> \nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n()\n\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (hold,res) = f a x in\n      match x with\n      | (x1,x2)::(x3,x4)::t ->\n          let tens = x1 + (x2 / 10) in let ones = x1 + (x2 mod 10) in () in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 71-72:\n  let (hold, res) = f a x in\n                    ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (a1 , a2) = a in\nmatch x with\n| (x1, x2) :: t -> \nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n[(tens , ones)] :: a\n| [] -> a\nin\nlet base = [(0,0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 192-193:\n  [(tens , ones)] :: a\n                     ^\nError: This expression has type int * 'a\n       but an expression was expected of type (int * int) list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (a1 , a2) = a in\nmatch x with\n| (x1, x2) :: t -> \nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n[(tens , ones)] :: a\n| [] -> a\nin\nlet base = [(0,0)] in\nlet args = List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 192-193:\n  [(tens , ones)] :: a\n                     ^\nError: This expression has type int * 'a\n       but an expression was expected of type (int * int) list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (a1 , a2) = a in\nmatch x with\n| (x1, x2) :: t -> \nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n[(tens , ones)] :: a\n| [] -> a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 192-193:\n  [(tens , ones)] :: a\n                     ^\nError: This expression has type int * 'a\n       but an expression was expected of type (int * int) list list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::[] -> if h <> 0 then l else []\n| h::t -> if h <> 0 then l else removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (a1 , a2) = a in\nmatch x with\n| (x1, x2) :: t -> \nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\na @ [(tens,ones)]\n| [] -> a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 173-174:\n  a @ [(tens,ones)]\n  ^\nError: This expression has type int * 'a\n       but an expression was expected of type 'b list\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| (x1, x2) :: t -> \nlet ha :: ht = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\na @ [(tens,ones)]\n| [] -> a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::ht = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 258-266:\n  let args = List.rev List.combine l1 l2 in\n             ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| (x1, x2) :: t -> \nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\na @ [(tens,ones)]\n| [] -> a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 257-265:\n  let args = List.rev List.combine l1 l2 in\n             ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| (x1, x2) :: t -> \nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\na @ [(tens,ones)]\n| [] -> a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 327-331:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| (x1, x2) :: t -> \nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a\n| [] -> a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 327-331:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| h :: t -> \nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a\n| [] -> a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          let (x1,x2) = h in\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 340-344:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + int_of_float(float_of_int(x)**2.0) in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (int_of_float ((float_of_int x) ** 2.0)) in\n  let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd = 0", "min": "\nlet bigAdd = 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd = failwith \"TBD\"", "min": "\nlet bigAdd = failwith \"TBD\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = failwith \"TBD\"", "min": "\nlet bigAdd l1 l2 = failwith \"TBD\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + int_of_float(float_of_int(x)**2.0) in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (int_of_float ((float_of_int x) ** 2.0)) in\n  let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = failwith \"TBD\"", "min": "\nlet bigAdd l1 l2 = failwith \"TBD\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| h :: t -> \nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a\n| [] -> a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          let (x1,x2) = h in\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 340-344:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::[] -> if h <> 0 then l else []\n| h::t -> if h <> 0 then l else removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| h :: t -> a\n(*\nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a *)\n| [] -> a\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> a | [] -> a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 196-200:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x\n(*\nmatch x with\n| h :: t -> a\n\nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \n| [] -> a *)\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 188-209:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 104-106:\n  let tens = x1 + x2 + a1 / 10 in\n             ^^\nError: Unbound value x1\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 299-303:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int\n       but an expression was expected of type (int * int) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 284-310:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones)\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 291-292:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type (int * 'a) list -> int * int -> int * int\n       but an expression was expected of type\n         (int * 'a) list -> int * int -> (int * 'a) list\n       Type int * int is not compatible with type (int * 'a) list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 283-309:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nmatch a1 with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      match a1 with\n      | h::t ->\n          let tens = (x1 + x2) + (h / 10) in\n          let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2))\n      | [] ->\n          let tens = x1 + (x2 / 10) in\n          let ones = x1 + (x2 mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nmatch a1 with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      match a1 with\n      | h::t ->\n          let tens = (x1 + x2) + (h / 10) in\n          let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2))\n      | [] ->\n          let tens = x1 + (x2 / 10) in\n          let ones = x1 + (x2 mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(carry :: a1, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match carry with\n      | h::t ->\n          let tens = (x1 + x2) + (h / 10) in\n          let ones = (x1 + x2) + (h mod 10) in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let tens = x1 + (x2 / 10) in\n          let ones = x1 + (x2 mod 10) in ((carry :: a1), (ones :: res)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 285-290:\n  (carry :: a1, ones :: res)\n   ^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(tens :: carry, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match carry with\n      | h::t ->\n          let tens = (x1 + x2) + (h / 10) in\n          let ones = (x1 + x2) + (h mod 10) in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let tens = x1 + (x2 / 10) in\n          let ones = x1 + (x2 mod 10) in ((tens :: carry), (ones :: res)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n(tens :: carry, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match carry with\n      | h::t ->\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let tens = (x1 + x2) / 10 in\n          let ones = (x1 + x2) mod 10 in ((tens :: carry), (ones :: res)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nmatch x2 with\n| h :: t ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: ones :: res)\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      match x2 with\n      | h::t ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 140-142:\n  let tens = (x1 + x2 + h) / 10 in\n                   ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nmatch x with\n| h :: t ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: ones :: res)\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      match x with\n      | h::t ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 88-94:\n  | h :: t ->\n    ^^^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h :: t -> \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\nif t = [] then (0 ,tens :: ones :: res)\nelse (tens :: carry, ones :: res)\n| [] -> a\n\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          let (x1,x2) = x in\n          let (carry,res) = a in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in\n          if t = []\n          then (0, (tens :: ones :: res))\n          else ((tens :: carry), (ones :: res))\n      | [] -> a in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 94-95:\n  let (x1, x2) = x in\n                 ^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 292-293:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int * int list -> int * int -> int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int list\n       Type int list is not compatible with type int * int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens ,tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 300-304:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int list * 'a list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens , tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 301-305:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int list * 'a list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens , tens :: ones :: res)\nin\nlet base = ([0], [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 302-306:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n([tens] , tens :: ones :: res)\nin\nlet base = ([0], [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in\n      ([tens], (tens :: ones :: res)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 302-303:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int * int list -> int * int -> int list * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet tens = (x1 + x2 + carry) / 10 in\nlet ones = (x1 + x2 + carry) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let tens = ((x1 + x2) + carry) / 10 in\n        let ones = ((x1 + x2) + carry) mod 10 in\n        ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 139-144:\n  let tens = (x1 + x2 + carry) / 10 in\n                        ^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet lastTens :: rest = res in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: rest)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: rest)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let lastTens::rest = res in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in\n        ([tens], (tens :: ones :: rest))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif res <> [] then\nlet lastTens :: rest = res in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: rest)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: rest)\n\nelse \nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i <> 0 then mulByDigit (i - 1) bigAdd l l else l;;\n", "out": "Characters 41-68:\n  if i <> 0 then mulByDigit (i-1) bigAdd l l\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) (bigAdd l l)\nelse l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <> 0 then mulByDigit (i - 1) (bigAdd l l) else l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet n = bigAdd l l in\nif i <> 0 then mulByDigit (i-1) n\nelse n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let n = bigAdd l l in if i <> 0 then mulByDigit (i - 1) n else n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 524-526:\n  let tens = (x1 + x2 + h1) / 10 in\n                        ^^\nError: Unbound value h1\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet n = bigAdd l l in\nif i <> 0 then mulByDigit (i-1) n\nelse n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let n = bigAdd l l in if i <> 0 then mulByDigit (i - 1) n else n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec helper ans i l =\nif i = 0 then ans \nelse helper (bigAdd ans l) (i-1) l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper ans i l =\n  if i = 0 then ans else helper (bigAdd ans l) (i - 1) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = helper 0 i l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper ans i l =\n  if i = 0 then ans else helper (bigAdd ans l) (i - 1) l;;\n\nlet rec mulByDigit i l = helper 0 i l;;\n", "out": "Characters 32-33:\n  let rec mulByDigit i l = helper 0 i l;;\n                                  ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = helper [0] i l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper ans i l =\n  if i = 0 then ans else helper (bigAdd ans l) (i - 1) l;;\n\nlet rec mulByDigit i l = helper [0] i l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = helper [0] i l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper ans i l =\n  if i = 0 then ans else helper (bigAdd ans l) (i - 1) l;;\n\nlet rec mulByDigit i l = helper [0] i l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = failwith \"TBD\"", "min": "\nlet bigMul l1 l2 = failwith \"TBD\";;\n", "out": ""}]}
