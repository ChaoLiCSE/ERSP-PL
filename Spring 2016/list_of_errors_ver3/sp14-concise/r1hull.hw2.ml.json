{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 121-126:\n  let seen' = if List.mem h seen' then seen' else h :: seen' in\n                            ^^^^^\nError: Unbound value seen'\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen' then seen' else h :: seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h :: seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif !c' then b' else wwhile(f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif !c' then b' else wwhile(f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif c' = false then b' else wwhile(f, b')"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-37:\n  let fixpoint (f,b) = wwhile (f b <> b,b);;\n                               ^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "in": "let fixpoint (f,b) = wwhile (f b <> b,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f ,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f b ,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 43-44:\n  let fixpoint (f,b) = wwhile (wwhile (f, b),b);;\n                                             ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (wwhile (f, b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-47:\n  let fixpoint (f,b) = wwhile (wwhile (f , b) , b);;\n                                                ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (wwhile (f , b) , b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 53-56:\n  let fixpoint (f,b) = wwhile ( if f b = b then b else f b , b);;\n                                                       ^^^\nError: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( if f b = b then b else f b , b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 48-49:\n  let fixpoint (f,b) = wwhile ( fixpoint (f , b), b);;\n                                                  ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ( fixpoint (f , b), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a -> 'a * bool) * 'a ->\n         (('a -> 'a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside\n       (('a -> 'a -> 'a * bool) * 'a) * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 30-38:\n  let fixpoint (f,b) = wwhile ( fixpoint , b);;\n                                ^^^^^^^^\nError: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a -> 'a * bool) * 'a ->\n         (('a -> 'a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside\n       (('a -> 'a -> 'a * bool) * 'a) * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (fixpoint, b);;\n", "in": "let fixpoint (f,b) = wwhile ( fixpoint , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( f, b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-74:\n  let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b', b);;\n                                                                        ^^^^\nError: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile (let b' = f b in if b' = b then f b else ((f b'), b));;\n", "in": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b', b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 289-292:\n  | Times(expr, expr2) -> exprToString(expr)^\"*\"exprToString(expr2)\n                                             ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" exprToString expr2)\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^ (\":\" ^ (exprToString expr4 \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 427-439:\n  | Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\";;\n                                                                                                                    ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^ (\":\" ^ (exprToString expr4 \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 170-171:\n  | Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))\n                                            ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) /. 2) + ((eval (e2, x, y)) /. 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 150-174:\n  | Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n                        ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) + ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildY()                       = VarY"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi *. eval(e, x, y ))\n| Cosine(e)  -> cos(pi *. eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 39-47:\n  let f = makeRand(rand) in\n          ^^^^^^^^\nError: Unbound value makeRand\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  let f = makeRand rand in\n  if depth = 0\n  then buildX ()\n  else\n    (match f with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 105-106:\n  | 2 -> buildSine(build(rand, depth - 1))\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type\n         int * int -> int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let f = makeRand rand in\n  if depth = 0\n  then buildX ()\n  else\n    (match f with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 62-63:\n  let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f , b);;\n                                                                ^\nError: Unbound value f\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx = b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 62-63:\n  let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f, b);;\n                                                                ^\nError: Unbound value f\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx = b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif c' = false then b' else wwhile(f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 44-45:\n  let fixpoint (f,b) = wwhile ( wwhile(f, b), b);;\n                                              ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ( wwhile(f, b), b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 52-55:\n  let fixpoint (f,b) = wwhile (if f b = b then b else f b , b);;\n                                                      ^^^\nError: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile (if f b = b then b else f b , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-69:\n  if b = b' then b else wwhile (f , b);;\n                                ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let b' = f b in if b = b' then b else wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else wwhile (f , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet (b', c') = f b in\nif b = b' then b else wwhile (f , b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let (b',c') = f b in if b = b' then b else wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-69:\n  if b = b' then b else wwhile (f , b);;\n                                ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let b' = f b in if b = b' then b else wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else wwhile (f , b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 75-76:\n  if b = b' then b else f b in wwhile (f , b);;\n                                       ^\nError: Unbound value f\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b = b' then b else f b in\n  wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in wwhile (f , b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 75-76:\n  if b = b' then b else f b in wwhile (f b, b);;\n                                       ^\nError: Unbound value f\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b = b' then b else f b in\n  wwhile ((f b), b);;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in wwhile (f b, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 32-34:\n  let f b = b' in\n            ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let f b = b' in if b = b' then b else f b in\n  wwhile ((f b), b);;\n", "in": "let fixpoint (f,b) = \nlet f b = b' in\nif b = b' then b else f b in wwhile (f b, b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-76:\n  let f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b);;\n                                                     ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile ((f b), b);;\n", "in": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx = b) in wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet xx = f b in (xx, xx <>  b) in wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 56-62:\n  let xx = f b in (xx, xx <>  b) in wwhile (f, b);;\n                                    ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 66-72:\n  let f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b);;\n                                              ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let f b = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\")/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet d' = depth - 1 in\nif depth = 0 then\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith\"ruh roh\"\nelse\nmatch rand(2, 7) with\n| 2 -> buildSine(build(rand, d'))\n| 3 -> buildCosine(build(rand , d'))\n| 4 -> buildAverage(build(rand, d'), build(rand, d'))\n| 5 -> buildTimes(build(rand, d'), build(rand, d'))\n| 6 -> buildThresh(build(rand, d'), build(rand, d'), build(rand, d'), build(rand, d'))\n| _ -> failwith \"ruh roh2\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Chunky   of expr * expr * expr\n| Monkey   of expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 507-509:\n  | Monkey(e1 , e2) -> if eval(e1, x, y) < eval(e2, x, y) then -1 else 1;;\n                                                               ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Chunky of expr* expr* expr\n  | Monkey of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Chunky (e1,e2,e3) ->\n      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))\n  | Monkey (e1,e2) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then (-1) else 1;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\")/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"\n| Chunky(expr, expr2, expr3) -> \"((\"^exprToString(expr)^\"^\"^exprToString(expr2)^\")^\"^exprToString(expr3)^\")\"\n| Monkey(expr, expr2) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?-1.0:1.0)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
