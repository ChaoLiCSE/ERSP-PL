{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList List.tl xs)", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "out": "Characters 66-73:\n  | xs -> List.hd xs + (sumList List.tl xs);;\n                        ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| x::xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0", "min": "\nlet rec sumList xs = match xs with | [] -> 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ n mod 10", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "out": "Characters 69-77:\n  else  digitsOfInt (n/10) @ n mod 10;;\n                             ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  (digitsOfInt (n/10) )@ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse (digitsOfInt (n/10) )@ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [0] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let additivePersistence n =\nif n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))\nelse n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet additivePersistence n =\n  if n > 9\n  then additivePersistence (List.fold_left (+) (digitsOfInt n))\n  else n;;\n", "out": "Characters 42-61:\n  if n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))\n                ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "out": "Characters 42-56:\n  if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\n                ^^^^^^^^^^^^^^\nError: Unbound value additiveHelper\n"}, {"type": "scope", "in": "let additivePersistence n = additiveHelper n 0", "min": "\nlet additivePersistence n = additiveHelper n 0;;\n", "out": "Characters 28-42:\n  let additivePersistence n = additiveHelper n 0;;\n                              ^^^^^^^^^^^^^^\nError: Unbound value additiveHelper\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "out": "Characters 42-56:\n  if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\n                ^^^^^^^^^^^^^^\nError: Unbound value additiveHelper\n"}, {"type": "scope", "in": "let additivePersistence n = additiveHelper n 0", "min": "\nlet additivePersistence n = additiveHelper n 0;;\n", "out": "Characters 28-42:\n  let additivePersistence n = additiveHelper n 0;;\n                              ^^^^^^^^^^^^^^\nError: Unbound value additiveHelper\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalHelper n = \nif n > 9 then digitalHelper (sumList(digitsOfInt n))\nelse n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec digitalHelper n =\n  if n > 9 then digitalHelper (sumList (digitsOfInt n)) else n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with | [] -> [] | x::xs -> listReverse xs @ [x]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with | [] -> [] | x::xs -> listReverse xs @ [x]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = if explode w = listReverse (explode w) then true else false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w =  explode w = listReverse (explode w)", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1) else acc", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1) else acc", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10))[n mod 10])", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "out": "Characters 77-99:\n  else append( (digitsOfInt (n / 10))[n mod 10]);;\n               ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10)) [n mod 10])", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "out": "Characters 77-99:\n  else append( (digitsOfInt (n / 10)) [n mod 10]);;\n               ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10)) [n mod 10])", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "out": "Characters 77-99:\n  else append( (digitsOfInt (n / 10)) [n mod 10]);;\n               ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
