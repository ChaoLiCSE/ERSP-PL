{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-73:\n  | xs -> List.hd xs + (sumList List.tl xs);;\n                        ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList List.tl xs)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| x::xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-77:\n  else  digitsOfInt (n/10) @ n mod 10;;\n                             ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ n mod 10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  (digitsOfInt (n/10) )@ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse (digitsOfInt (n/10) )@ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 42-61:\n  if n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))\n                ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet additivePersistence n =\n  if n > 9\n  then additivePersistence (List.fold_left (+) (digitsOfInt n))\n  else n;;\n", "in": "let additivePersistence n =\nif n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 42-56:\n  if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\n                ^^^^^^^^^^^^^^\nError: Unbound value additiveHelper\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "in": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc"}, {"type": "scope", "out": "Characters 28-42:\n  let additivePersistence n = additiveHelper n 0;;\n                              ^^^^^^^^^^^^^^\nError: Unbound value additiveHelper\n", "min": "\nlet additivePersistence n = additiveHelper n 0;;\n", "in": "let additivePersistence n = additiveHelper n 0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 42-56:\n  if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\n                ^^^^^^^^^^^^^^\nError: Unbound value additiveHelper\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "in": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc"}, {"type": "scope", "out": "Characters 28-42:\n  let additivePersistence n = additiveHelper n 0;;\n                              ^^^^^^^^^^^^^^\nError: Unbound value additiveHelper\n", "min": "\nlet additivePersistence n = additiveHelper n 0;;\n", "in": "let additivePersistence n = additiveHelper n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalHelper n = \nif n > 9 then digitalHelper (sumList(digitsOfInt n))\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with | [] -> [] | x::xs -> listReverse xs @ [x]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with | [] -> [] | x::xs -> listReverse xs @ [x]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = if explode w = listReverse (explode w) then true else false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w =  explode w = listReverse (explode w)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1) else acc"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1) else acc"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-99:\n  else append( (digitsOfInt (n / 10))[n mod 10]);;\n               ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10))[n mod 10])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-99:\n  else append( (digitsOfInt (n / 10)) [n mod 10]);;\n               ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10)) [n mod 10])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-99:\n  else append( (digitsOfInt (n / 10)) [n mod 10]);;\n               ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10)) [n mod 10])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
