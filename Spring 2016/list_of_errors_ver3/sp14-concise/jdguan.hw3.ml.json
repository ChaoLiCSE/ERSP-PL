{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a ** 2) + x in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 31-32:\n  let f a x = a**2 + x in\n                 ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = a**2. + x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a ** 2.) + x in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 28-33:\n  let f a x = a**2. + x in\n              ^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 75-79:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0. in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (a*a) + x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x' in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = x' in List.fold_left f base fs;;\n", "out": "Characters 45-47:\n  let base = x' in\n             ^^\nError: Unbound value x'\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (f s = s) in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a x in let base = (f s) = s in List.fold_left f base fs;;\n", "out": "Characters 48-49:\n  let base = (f s = s) in\n                ^\nError: Unbound value s\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = (x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x+x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x + x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base = x in List.fold_left f base fs;;\n", "out": "Characters 43-44:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = () in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base = () in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x in\nlet base = base in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base = base in List.fold_left f base fs;;\n", "out": "Characters 43-47:\n  let base = base in\n             ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x y = x y in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = a (x y) in let base x y = x y in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x y -> (x y)in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = a (x y) in let base x y = x y in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> y in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = a (x y) in let base x = y in List.fold_left f base fs;;\n", "out": "Characters 67-68:\n  let base = fun x -> y in\n                      ^\nError: Unbound value y\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = l in List.fold_left f base l;;\n", "out": "Characters 112-113:\n  let l = l in\n          ^\nError: Unbound value l\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if a != \"\" then a ^ sep ^ x else x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != \"\" then a ^ sep ^ x else x) in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != \"1\" then a ^ sep ^ x else x) in\nlet base = \"1\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"1\" then a ^ (sep ^ x) else x in\n      let base = \"1\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != \"\" then a ^ sep ^ x else x) in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != \"\" then a ^ sep else \"\") ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (if a != \"\" then a ^ sep else \"\") ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = (^) h in let l = t in List.fold_left f base l;;\n", "out": "Characters 143-147:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = (^) h in let l = t in List.fold_left f base l;;\n", "out": "Characters 139-143:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = fun x-> h ^ x in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base x = h ^ x in let l = t in List.fold_left f base l;;\n", "out": "Characters 147-151:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n =\nif n > 0 then\nx :: clone x n-1\nelse\n[]", "min": "\nlet rec clone x n = if n > 0 then x :: ((clone x n) - 1) else [];;\n", "out": "Characters 39-48:\n  x :: clone x n-1\n       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1,(clone 0 (List.length l1 - List.length l2))::l2)\nelse\n((clone 0 (List.length l2 - List.length l1))::l1,l2)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,(clone 0 ((List.length l1) - (List.length l2)))::l2)\nelse\n((clone 0 ((List.length l2) - (List.length l1)))::l1,l2)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,(clone 0 ((List.length l1) - (List.length l2)))@l2)\nelse\n((clone 0 ((List.length l2) - (List.length l1)))@l1,l2)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,l2)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| 0::t -> t\n| _ -> l", "min": "\nlet rec removeZero l = match l with | 0::t -> t | _ -> l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l", "min": "\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\nin\nlet base = (0,0) in\nlet args = List.rev (List.combine (List.map (fun x -> [x]) l1) (List.map (fun x -> [x]) l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f + d) / 10) :: ((h + j) mod 10) in\n    let base = (0, 0) in\n    let args =\n      List.rev\n        (List.combine (List.map (fun x  -> [x]) l1)\n           (List.map (fun x  -> [x]) l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 114-128:\n  | ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\n                                               ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\nin\nlet base = ([],[]) in\nlet args = List.rev (List.combine (List.map (fun x -> [x]) l1) (List.map (fun x -> [x]) l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f + d) / 10) :: ((h + j) mod 10) in\n    let base = ([], []) in\n    let args =\n      List.rev\n        (List.combine (List.map (fun x  -> [x]) l1)\n           (List.map (fun x  -> [x]) l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 114-128:\n  | ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\n                                               ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e)::c) \nin\nlet base = ([], []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,h::t),(d,e)) ->\n          (b, (((d + e) / 10) :: (((d + e) + h) mod 10) :: t)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,((d+e) mod 10)::c) \nin\nlet base = ([], []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | ((b,c),(d,e)) -> (b, (((d + e) mod 10) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,h::t),(d,e)) ->\n          (b, (((d + e) / 10) :: (((d + e) + h) mod 10) :: t)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e)::c) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e)::c) \nin\nlet base = ([], []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e) mod 10::c) \nin\nlet base = ([], []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | ((b,c),(d,e)) -> (b, (((d + e) mod 10) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + e) + h) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 103-104:\n  | ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) \n                                    ^\nError: Unbound value h\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+b+e) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + b) + e) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+b+e) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + b) + e) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine 0::l1 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 179-180:\n  let args = List.rev (List.combine 0::l1 0::l2) in\n                                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine 0::l1 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 179-180:\n  let args = List.rev (List.combine 0::l1 0::l2) in\n                                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine (0 :: l1) 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 187-188:\n  let args = List.rev (List.combine (0::l1) 0::l2) in\n                                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = mulByDigit i-1 bigAdd l l", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 bigAdd l l);;\n", "out": "Characters 25-37:\n  let rec mulByDigit i l = mulByDigit i-1 bigAdd l l;;\n                           ^^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = mulByDigit (i - 1) bigAdd l l;;\n", "out": "Characters 25-52:\n  let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l;;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) bigAdd l l else 0;;\n", "out": "Characters 39-66:\n  mulByDigit (i-1) bigAdd l l\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) (bigAdd l l) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l", "min": "\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper i-1 (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l", "min": "\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then (helper i) - (1 (bigAdd acc l) l) else acc in\n  helper i [] l;;\n", "out": "Characters 64-72:\n  helper i-1 (bigAdd acc l) l\n  ^^^^^^^^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper (i-1) (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l", "min": "\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n", "out": "Characters 78-84:\n  helper (i-1) (bigAdd acc l) l\n                ^^^^^^\nError: Unbound value bigAdd\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) -> ((b + 1), ((mulByDigit d l1) :: (clone 0 b))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 70-80:\n  | ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\n                       ^^^^^^^^^^\nError: Unbound value mulByDigit\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) -> ((b + 1), (List.append (mulByDigit d l1) (clone 0 b))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 82-92:\n  | ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\n                                   ^^^^^^^^^^\nError: Unbound value mulByDigit\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 69-75:\n  | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n                      ^^^^^^\nError: Unbound value bigAdd\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
