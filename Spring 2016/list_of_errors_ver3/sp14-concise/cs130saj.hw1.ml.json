{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt div(n, 10)) @ [n]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt div (n, 10)) @ [n];;\n", "out": "Characters 49-60:\n  else (digitsOfInt div(n, 10)) @ [n];;\n        ^^^^^^^^^^^\nError: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt n / 10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n", "out": "Characters 49-62:\n  else (digitsOfInt n / 10) @ [n mod 10];;\n        ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersAndRoot xs (Pers, Root) =\nif (sumList xs) < 10 then (Pers, sumList xs)\nelse additivePersAndRoot digits(sumList(xs)) (Pers + 1, Root)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs (Pers ,Root ) =\n  if (sumList xs) < 10\n  then (Pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) ((Pers + 1), Root);;\n", "out": "Characters 32-36:\n  let rec additivePersAndRoot xs (Pers, Root) =\n                                  ^^^^\nError: Unbound constructor Pers\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersAndRoot xs (Pers, Root) =\nif (sumList xs) < 10 then (Pers, (sumList xs))\nelse additivePersAndRoot digits(sumList(xs)) (Pers + 1, Root)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs (Pers ,Root ) =\n  if (sumList xs) < 10\n  then (Pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) ((Pers + 1), Root);;\n", "out": "Characters 32-36:\n  let rec additivePersAndRoot xs (Pers, Root) =\n                                  ^^^^\nError: Unbound constructor Pers\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersAndRoot xs (Pers, Root) =\nif (sumList xs) < 10 then (Pers, sumList xs)\nelse additivePersAndRoot digits(sumList(xs)) (Pers + 1, Root)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs (Pers ,Root ) =\n  if (sumList xs) < 10\n  then (Pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) ((Pers + 1), Root);;\n", "out": "Characters 32-36:\n  let rec additivePersAndRoot xs (Pers, Root) =\n                                  ^^^^\nError: Unbound constructor Pers\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersAndRoot xs Pers =\nif (sumList xs) < 10 then (Pers, sumList xs)\nelse additivePersAndRoot digits(sumList(xs)) (Pers + 1) Root", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs (Pers ) =\n  if (sumList xs) < 10\n  then (Pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) (Pers + 1) Root;;\n", "out": "Characters 31-35:\n  let rec additivePersAndRoot xs Pers =\n                                 ^^^^\nError: Unbound constructor Pers\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersAndRoot xs pers =\nif (sumList xs) < 10 then (pers, sumList xs)\nelse additivePersAndRoot digits(sumList(xs)) (pers + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  if (sumList xs) < 10\n  then (pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) (pers + 1);;\n", "out": "Characters 88-107:\n  else additivePersAndRoot digits(sumList(xs)) (pers + 1);;\n       ^^^^^^^^^^^^^^^^^^^\nError: This function has type int list -> 'a -> 'a * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersAndRoot xs pers =\nif (sumList xs) < 10 then (pers, sumList xs)\nelse additivePersAndRoot(digits(sumList(xs)) (pers + 1))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  if (sumList xs) < 10\n  then (pers, (sumList xs))\n  else additivePersAndRoot (digits (sumList xs) (pers + 1));;\n", "out": "Characters 108-114:\n  else additivePersAndRoot(digits(sumList(xs)) (pers + 1));;\n                           ^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersAndRoot xs pers =\nif (sumList xs) < 10 then (pers, sumList xs)\nelse additivePersAndRoot((digits sumList(xs)) (pers + 1))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  if (sumList xs) < 10\n  then (pers, (sumList xs))\n  else additivePersAndRoot ((digits sumList xs) (pers + 1));;\n", "out": "Characters 109-115:\n  else additivePersAndRoot((digits sumList(xs)) (pers + 1));;\n                            ^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersAndRoot xs pers =\nif (sumList xs) < 10 then (pers, sumList xs)\nelse additivePersAndRoot((digits sumList(xs)) (pers + 1))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  if (sumList xs) < 10\n  then (pers, (sumList xs))\n  else additivePersAndRoot ((digits sumList xs) (pers + 1));;\n", "out": "Characters 109-115:\n  else additivePersAndRoot((digits sumList(xs)) (pers + 1));;\n                            ^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot((digits theSum) (pers + 1))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  let theSum = sumList xs in\n  if (sumList xs) < 10\n  then (pers, theSum)\n  else additivePersAndRoot ((digits theSum) (pers + 1));;\n", "out": "Characters 132-147:\n  else additivePersAndRoot((digits theSum) (pers + 1));;\n                           ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot((digits theSum) (pers + 1))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  let theSum = sumList xs in\n  if (sumList xs) < 10\n  then (pers, theSum)\n  else additivePersAndRoot ((digits theSum) (pers + 1));;\n", "out": "Characters 132-147:\n  else additivePersAndRoot((digits theSum) (pers + 1));;\n                           ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersAndRoot n = if n <= 0 then (0, 0) else (1, 1);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet _ =\n  let nextArr = digits theSum in\n  if (sumList xs) < 10\n  then (pers, theSum)\n  else additivePersAndRoot (nextArr (pers + 1));;\n", "out": "Characters 21-27:\n  let nextArr = digits theSum in \n                       ^^^^^^\nError: Unbound value theSum\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot((digits theSum) (pers + 1))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  let theSum = sumList xs in\n  if theSum < 10\n  then (pers, theSum)\n  else additivePersAndRoot ((digits theSum) (pers + 1));;\n", "out": "Characters 125-140:\n  else additivePersAndRoot((digits theSum) (pers + 1));;\n                           ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  let theSum = sumList xs in\n  if theSum < 10\n  then (pers, theSum)\n  else additivePersAndRoot (digits theSum) (pers + 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot xs persCount =\nlet theSum = sumList xs in\nif theSum < 10 then (theSum, persCount)\nelse additivePersAndRoot (digits theSum) (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs persCount =\n  let theSum = sumList xs in\n  if theSum < 10\n  then (theSum, persCount)\n  else additivePersAndRoot (digits theSum) (persCount + 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot xs persCount =\nlet theSum = sumList xs in\nif theSum < 10 then (persCount, theSum)\nelse additivePersAndRoot (digits theSum) (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs persCount =\n  let theSum = sumList xs in\n  if theSum < 10\n  then (persCount, theSum)\n  else additivePersAndRoot (digits theSum) (persCount + 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot num persCount =\nif num < 10 then (persCount, num)\nelse let xs = digits num in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot num persCount =\n  if num < 10\n  then (persCount, num)\n  else\n    (let xs = digits num in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot num persCount =\nlet _ = (num, persCount) in\nif num < 10 then (persCount, num)\nelse let xs = digits num in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot num persCount =\n  let _ = (num, persCount) in\n  if num < 10\n  then (persCount, num)\n  else\n    (let xs = digits num in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersAndRoot num persCount =\n(num, persCount) in\nif num < 10 then (persCount, num)\nelse let xs = digits num in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet _ =\n  let rec additivePersAndRoot num persCount = (num, persCount) in\n  if num < 10\n  then (persCount, num)\n  else\n    (let xs = digits num in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": "Characters 67-70:\n  if num < 10 then (persCount, num)\n     ^^^\nError: Unbound value num\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersAndRoot num persCount =\nnum, persCount in\nif num < 10 then (persCount, num)\nelse let xs = digits num in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet _ =\n  let rec additivePersAndRoot num persCount = (num, persCount) in\n  if num < 10\n  then (persCount, num)\n  else\n    (let xs = digits num in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": "Characters 65-68:\n  if num < 10 then (persCount, num)\n     ^^^\nError: Unbound value num\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot num persCount =\nif num < 10 then (persCount, abs(num))\nelse let xs = digits num in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot num persCount =\n  if num < 10\n  then (persCount, (abs num))\n  else\n    (let xs = digits num in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot num persCount =\nlet absNum = abs(num) in\nif absNum < 10 then (persCount, absNum)\nelse let xs = digits absNum in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot num persCount =\n  let absNum = abs num in\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot n in\nl", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot num persCount =\n  let absNum = abs num in\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot n in l;;\n", "out": "Characters 46-67:\n  let (l, r) = additivePersAndRoot n in\n               ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> int * int\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot absNum persCount =\nif absNum < 10 then (persCount, absNum)\nelse let xs = digits absNum in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot(abs(n)) in\nl", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot (abs n) in l;;\n", "out": "Characters 46-73:\n  let (l, r) = additivePersAndRoot(abs(n)) in\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> int * int\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot(abs(n) 0) in\nl", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n 0) in l;;\n", "out": "Characters 66-69:\n  let (l, r) = additivePersAndRoot(abs(n) 0) in\n                                   ^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot abs(n) 0 in\nl", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n", "out": "Characters 46-65:\n  let (l, r) = additivePersAndRoot abs(n) 0 in\n               ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot absNum persCount =\nif absNum < 10 then (persCount, absNum)\nelse let xs = digits absNum in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot abs(n) 0 in\nl", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n", "out": "Characters 46-65:\n  let (l, r) = additivePersAndRoot abs(n) 0 in\n               ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot abs(n) 0 in\nl", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n", "out": "Characters 46-65:\n  let (l, r) = additivePersAndRoot abs(n) 0 in\n               ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot abs(n) 0 in\nl", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n", "out": "Characters 46-65:\n  let (l, r) = additivePersAndRoot abs(n) 0 in\n               ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot (abs n) 0 in\nl", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n) 0 in l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet (l, r) = additivePersAndRoot (abs n) 0 in\nr", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec digitalRoot n = let (l,r) = additivePersAndRoot (abs n) 0 in r;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with\n[] -> []\n| r::h ->\n(listReverse h) @ [r]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet (l,r) = additivePersAndRoot (abs (-2)) 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | r::h -> (listReverse h) @ [r];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = \nlet ex = explode w in\nex[0] && ex[_end]", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;\n", "out": "Characters 42-44:\n  ex[0] && ex[_end];;\n  ^^\nError: This expression has type char list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = \nlet ex = explode w in\nex[0] && ex[_end]", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;\n", "out": "Characters 42-44:\n  ex[0] && ex[_end];;\n  ^^\nError: This expression has type char list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet ex = explode w in 2", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in 2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nlet ex = explode w in\nlet revex = listReverese ex in\nex = revex", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let ex = explode w in let revex = listReverese ex in ex = revex;;\n", "out": "Error: Unbound value listReverese\nHint: Did you mean listReverse?\nError: Unbound value listReverese\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 54-66:\n  let revex = listReverese ex in\n              ^^^^^^^^^^^^\nError: Unbound value listReverese\nHint: Did you mean listReverse?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nlet ex = explode w in\nlet revex = listReverese ex in\nex = revex", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let ex = explode w in let revex = listReverese ex in ex = revex;;\n", "out": "Error: Unbound value listReverese\nHint: Did you mean listReverse?\nError: Unbound value listReverese\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 54-66:\n  let revex = listReverese ex in\n              ^^^^^^^^^^^^\nError: Unbound value listReverese\nHint: Did you mean listReverse?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet ex = explode w in\nlet revex = listReverse ex in\nex = revex", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet (l,r) = additivePersAndRoot (abs (-2)) 0;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | r::h -> (listReverse h) @ [r];;\n\nlet palindrome w =\n  let ex = explode w in let revex = listReverse ex in ex = revex;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n / 10)) :: [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "out": "Characters 48-70:\n  else (digitsOfInt (n / 10)) :: [n mod 10];;\n       ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet next_tail = digitsOfInt (n / 10) in\nif n <= 0 then []\nelse next_tail @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  let next_tail = digitsOfInt (n / 10) in\n  if n <= 0 then [] else next_tail @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \nlet next_tail = digitsOfInt (n / 10) in\nmatch next_tail with\nx::xs -> \nxs @ [x :: (n % 10)]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let next_tail = digitsOfInt (n / 10) in\n     match next_tail with | x::xs -> xs @ [x :: (n % 10)]);;\n", "out": "Characters 125-126:\n  xs @ [x :: (n % 10)];;\n        ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \nlet next_tail = digitsOfInt (n / 10) in\nmatch next_tail with\nx::xs -> \nxs @ [x :: (n % 10)]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let next_tail = digitsOfInt (n / 10) in\n     match next_tail with | x::xs -> xs @ [x :: (n % 10)]);;\n", "out": "Characters 125-126:\n  xs @ [x :: (n % 10)];;\n        ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \nlet next_tail = digitsOfInt (n / 10) in\nmatch next_tail with\nx::xs -> \nxs @ [x :: (n mod 10)]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let next_tail = digitsOfInt (n / 10) in\n     match next_tail with | x::xs -> xs @ [x :: (n mod 10)]);;\n", "out": "Characters 125-126:\n  xs @ [x :: (n mod 10)];;\n        ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \ndigitsOfInt (n / 10) @ (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "out": "Characters 71-81:\n  digitsOfInt (n / 10) @ (n mod 10);;\n                         ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse digitsOfInt (n / 10) @ (n % 10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n % 10);;\n", "out": "Characters 73-74:\n  else digitsOfInt (n / 10) @ (n % 10);;\n                                 ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "out": "Characters 72-82:\n  else (digitsOfInt (n / 10)) @ (n mod 10);;\n                                ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse (digitsOfInt (n / 10)) :: (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 47-69:\n  else (digitsOfInt (n / 10)) :: (n mod 10);;\n       ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse backCons (digitsOfInt (n / 10)) (n mod 10)", "min": "\nlet rec backCons xs x =\n  match xs with | [] -> [x] | y::ys -> y :: (backCons ys x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else backCons (digitsOfInt (n / 10)) (n mod 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot n 0 in\nl", "min": "\nlet rec backCons xs x =\n  match xs with | [] -> [x] | y::ys -> y :: (backCons ys x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else backCons (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot n 0 in l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersAndRoot absNum persCount =\nif absNum < 0 then additivePersAndRoot (-absNum) persCount\nelse if absNum < 10 then (persCount, absNum)\nelse let xs = digits absNum in\nlet theSum = sumList xs in\nadditivePersAndRoot theSum (persCount + 1)", "min": "\nlet rec backCons xs x =\n  match xs with | [] -> [x] | y::ys -> y :: (backCons ys x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else backCons (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 0\n  then additivePersAndRoot (- absNum) persCount\n  else\n    if absNum < 10\n    then (persCount, absNum)\n    else\n      (let xs = digits absNum in\n       let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n", "out": ""}]}
