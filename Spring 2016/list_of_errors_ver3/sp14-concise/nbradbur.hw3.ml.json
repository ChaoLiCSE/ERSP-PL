{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match x with\n| []   -> a\n| h::t -> List.fold_left f (a + (h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 78-79:\n  | h::t -> List.fold_left f (a + (h*h)) t in\n                           ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x =\n    match x with | [] -> a | h::t -> List.fold_left f (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 83-84:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun a -> x(x a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x a = x (x a) in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = if n <= 0 then [] else x::(clone x (n-1))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 -diff) @ l1, l2)", "out": "Characters 119-126:\n  else ((clone 0 -diff) @ l1, l2);;\n         ^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else ((((clone 0) - diff) @ l1), l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 abs diff) @ l1, l2)", "out": "Characters 119-124:\n  else ((clone 0 abs diff) @ l1, l2);;\n         ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 abs diff) @ l1), l2);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 (abs diff)) @ l1, l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| []   -> []\n| h::t -> match h with\n| 0 -> removeZero t\n| _ -> h::removeZero t", "out": "", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: (removeZero t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| []   -> []\n| h::t -> match h with\n| 0 -> removeZero t\n| _ -> t", "out": "", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| []   -> []\n| h::t -> match h with\n| 0 -> removeZero t\n| _ -> h::t", "out": "", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 372-398:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | [] ->\n          if (arg1 + arg2) > 9\n          then [1] @ ([(arg1 + arg2) mod 10] @ a)\n          else (arg1 + arg2) :: a\n      | h::t ->\n          if ((arg1 + arg2) + h) > 9\n          then [1] @ ([((arg1 + arg2) + h) mod 10] @ a)\n          else ((arg1 + arg2) + h) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | [] ->\n          if (arg1 + arg2) > 9\n          then [1] @ ([(arg1 + arg2) mod 10] @ a)\n          else (arg1 + arg2) :: a\n      | h::t ->\n          if ((arg1 + arg2) + h) > 9\n          then [1] @ ([((arg1 + arg2) + h) mod 10] @ a)\n          else ((arg1 + arg2) + h) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | [] ->\n          if (arg1 + arg2) > 9\n          then [1] @ ([(arg1 + arg2) mod 10] @ a)\n          else (arg1 + arg2) :: a\n      | h::t ->\n          if ((arg1 + arg2) + h) > 9\n          then [1] @ ([((arg1 + arg2) + h) mod 10] @ a)\n          else ((arg1 + arg2) + h) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10]\nelse [arg1 + arg2]\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ t\nelse ((arg1 + arg2 + h)::t)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | [] ->\n          if (arg1 + arg2) > 9\n          then [1] @ [(arg1 + arg2) mod 10]\n          else [arg1 + arg2]\n      | h::t ->\n          if ((arg1 + arg2) + h) > 9\n          then [1] @ ([((arg1 + arg2) + h) mod 10] @ t)\n          else ((arg1 + arg2) + h) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1,_::t) -> \nif ((arg1 + arg2 + h) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 217-218:\n  if ((arg1 + arg2 + h) > 9)\n                     ^\nError: Unbound value h\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (1,_::t) ->\n          if ((arg1 + arg2) + h) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1,_::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (1,_::t) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, h::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (1,h::t) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, _) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 261-262:\n  then (1, [(arg1 + arg2 + 1) mod 10] @ t)\n                                        ^\nError: Unbound value t\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (1,_) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, h::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (1,h::t) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (_, h::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (_,h::t) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,_)   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (_, h::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,_) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (_,h::t) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,_)   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (_, _) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ a)\nelse (0, ((arg1 + arg2 + 1)::a))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 260-261:\n  then (1, [(arg1 + arg2 + 1) mod 10] @ a)\n                                        ^\nError: This expression has type int * 'a\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,_) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (_,_) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ a))\n          else (0, (((arg1 + arg2) + 1) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0, acc) -> \nif ((arg1 + arg2) > 9)\nthen (1, ((arg1 + arg2) mod 10)::acc)\nelse (0,(arg1 + arg2)::acc)\n| (0, [])  ->\nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0, [arg1 + arg2])\n| (_, acc) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, ((arg1 + arg2 + 1) mod 10)::acc)\nelse (0, ((arg1 + arg2 + 1)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,acc) ->\n          if (arg1 + arg2) > 9\n          then (1, (((arg1 + arg2) mod 10) :: acc))\n          else (0, ((arg1 + arg2) :: acc))\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (_,acc) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ((((arg1 + arg2) + 1) mod 10) :: acc))\n          else (0, (((arg1 + arg2) + 1) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0, acc) -> \nif ((arg1 + arg2) > 9)\nthen (1, ((arg1 + arg2) mod 10)::acc)\nelse (0,(arg1 + arg2)::acc)\n| (_, acc) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, ((arg1 + arg2 + 1) mod 10)::acc)\nelse (0, ((arg1 + arg2 + 1)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,acc) ->\n          if (arg1 + arg2) > 9\n          then (1, (((arg1 + arg2) mod 10) :: acc))\n          else (0, ((arg1 + arg2) :: acc))\n      | (_,acc) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ((((arg1 + arg2) + 1) mod 10) :: acc))\n          else (0, (((arg1 + arg2) + 1) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nlet (carry, acc) = a in \nif ((arg1 + arg2 + carry) > 9)\nthen (1, ((arg1 + arg2 + carry) mod 10)::acc)\nelse (0, ((arg1 + arg2 + carry)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nlet (carry, acc) = a in \nif ((arg1 + arg2 + carry) > 9)\nthen (1, ((arg1 + arg2 + carry) mod 10)::acc)\nelse (0, ((arg1 + arg2 + carry)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (fin,res) = List.fold_left f base args in\nfin::res\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> mulByDigit (i-1) (bigAdd l l)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> l | _ -> mulByDigit (i - 1) (bigAdd l l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| _ -> mulByDigit (i-1) (bigAdd l l)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> mulByDigit (i - 1) (bigAdd l l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> mulByDigit (i-1) (bigAdd l l)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 1 -> l | _ -> mulByDigit (i - 1) (bigAdd l l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n| 8 -> l\n| _ -> mulByDigit (i-1) (bigAdd l l)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 8 -> l | _ -> mulByDigit (i - 1) (bigAdd l l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n| 7 -> l\n| _ -> mulByDigit (i-1) (bigAdd l l)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 7 -> l | _ -> mulByDigit (i - 1) (bigAdd l l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nlet (carry, acc) = a in \nif ((arg1 + arg2 + carry) > 9)\nthen (1, ((arg1 + arg2 + carry) mod 10)::acc)\nelse (0, ((arg1 + arg2 + carry)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (fin,res) = List.fold_left f base args in\nfin::res\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let mulByDigit i l = \nlet saved = l in\nlet rec helper i' l' = match i' with\n| 1 -> l'\n| _ -> helper (i'-1) (bigAdd saved l')\nin helper i l", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with | 1 -> l' | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let mulByDigit i l = \nlet saved = l in\nlet rec helper i' l' = match i' with\n| 0 -> []\n| 1 -> l'\n| _ -> helper (i'-1) (bigAdd saved l')\nin helper i l", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = ([0], (List.rev l1)) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (acc, l) = a in\nmatch l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) in\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (acc,l) = a in\n    match l with\n    | [] -> ([], [])\n    | h::t ->\n        let (first,second) = padZero [h] acc in\n        let f_rev = List.rev first in ((0 :: acc), (mulByDigit x f_rev)) in\n  let base = ([0], (List.rev l1)) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nmatch l with\n| []   -> ([], [], acc)\n| h::t -> let (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, mulByDigit x f_rev) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (mulByDigit x f_rev)) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nmatch l with\n| []   -> ([], [], acc)\n| h::t -> let (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nmatch l with\n| []   -> ([0], List.rev l1, acc)\n| h::t -> let (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    match l with\n    | [] -> ([0], (List.rev l1), acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10^((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type int but an expression was expected of type\n         string\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 77-81:\n  let padded_x = x*10^((List.length padding) - 1) in\n                 ^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let padded_x = (x * 10) ^ ((List.length padding) - 1) in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit padded_x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10**((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 79-81:\n  let padded_x = x*10**((List.length padding) - 1) in\n                   ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let padded_x = x * (10 ** ((List.length padding) - 1)) in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit padded_x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10.**((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 84-111:\n  let padded_x = x*10.**((List.length padding) - 1) in\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let padded_x = x * (10. ** ((List.length padding) - 1)) in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit padded_x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 n-1) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let rec pow10 exp = match exp with | 0 -> 1 | n -> 10 * ((pow10 n) - 1) in\n    let padded_x = x * (pow10 ((List.length padding) - 1)) in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit padded_x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let rec pow10 exp = match exp with | 0 -> 1 | n -> 10 * (pow10 (n - 1)) in\n    let padded_x = x * (pow10 ((List.length padding) - 1)) in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit padded_x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "Error: Unbound value List.reverse\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 325-337:\n  let f_rev = List.reverse first in\n              ^^^^^^^^^^^^\nError: Unbound value List.reverse\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let rec pow10 exp = match exp with | 0 -> 1 | n -> 10 * (pow10 (n - 1)) in\n    let padded_x = x * (pow10 ((List.length padding) - 1)) in\n    let rec helper padding l acc padded_x =\n      match l with\n      | [] -> []\n      | h::t ->\n          let (first,second) = padZero [h] padding in\n          let f_rev = List.reverse first in\n          bigAdd (mulByDigit padded_x f_rev)\n            (helper (0 :: padding) t (mulByDigit padded_x f_rev) padded_x) in\n    let result = helper padding l acc padded_x in ([0], t, result) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "Error: Unbound value t\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 494-495:\n  ([0], t, result) in\n        ^\nError: Unbound value t\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let rec pow10 exp = match exp with | 0 -> 1 | n -> 10 * (pow10 (n - 1)) in\n    let padded_x = x * (pow10 ((List.length padding) - 1)) in\n    let rec helper padding l acc padded_x =\n      match l with\n      | [] -> []\n      | h::t ->\n          let (first,second) = padZero [h] padding in\n          let f_rev = List.rev first in\n          bigAdd (mulByDigit padded_x f_rev)\n            (helper (0 :: padding) t (mulByDigit padded_x f_rev) padded_x) in\n    let result = helper padding l acc padded_x in ([0], t, result) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let rec pow10 exp = match exp with | 0 -> 1 | n -> 10 * (pow10 (n - 1)) in\n    let padded_x = x * (pow10 ((List.length padding) - 1)) in\n    let rec helper padding l acc padded_x =\n      match l with\n      | [] -> []\n      | h::t ->\n          let (first,second) = padZero [h] padding in\n          let f_rev = List.rev first in\n          bigAdd (mulByDigit padded_x f_rev)\n            (helper (0 :: padding) t (mulByDigit padded_x f_rev) padded_x) in\n    let result = helper padding l acc padded_x in ([0], l, result) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\nacc\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let rec pow10 exp = match exp with | 0 -> 1 | n -> 10 * (pow10 (n - 1)) in\n    let padded_x = x * (pow10 ((List.length padding) - 1)) in\n    let rec helper padding l acc padded_x =\n      match l with\n      | [] -> acc\n      | h::t ->\n          let (first,second) = padZero [h] padding in\n          let f_rev = List.rev first in\n          bigAdd (mulByDigit padded_x f_rev)\n            (helper (0 :: padding) t (mulByDigit padded_x f_rev) padded_x) in\n    let result = helper padding l acc padded_x in ([0], l, result) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nlet (padding, acc) = a in\n(padding+1, l1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type\n         int * int list -> int -> int * int list * int list\n       but an expression was expected of type\n         int * int list -> int -> int * int list\n       Type int * int list * int list is not compatible with type\n         int * int list \nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 207-208:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int * int list -> int -> int * int list * int list\n       but an expression was expected of type\n         int * int list -> int -> int * int list\n       Type int * int list * int list is not compatible with type\n         int * int list \n", "min": "\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,acc) = a in\n    ((padding + 1), l1, (bigAdd acc ((mulByDigit x l1) @ (clone 0 padding)))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nlet (padding, acc) = a in\n(padding+1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,acc) = a in\n    ((padding + 1), (bigAdd acc ((mulByDigit x l1) @ (clone 0 padding)))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
