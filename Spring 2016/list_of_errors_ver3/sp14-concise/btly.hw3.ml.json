{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x a y) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a ^ x) in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a ^ sep) ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a ^ sep) ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = ((a ^ sep) ^ x) in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-38:\n  let stringOfList f l = \"[\" ^ (List.map f \"; \" l) ^ \"]\";;\n                                ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet stringOfList f l = \"[\" ^ ((List.map f \"; \" l) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (List.map f \"; \" l) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 42-46:\n  let stringOfList f l = \"[\" ^ (List.map f (\"; \" l)) ^ \"]\";;\n                                            ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet stringOfList f l = \"[\" ^ ((List.map f (\"; \" l)) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (List.map f (\"; \" l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-50:\n  let stringOfList f l = \"[\" ^ (List.map (f \"; \") l) ^ \"]\";;\n                               ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = \"[\" ^ ((List.map (f \"; \") l) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (List.map (f \"; \") l) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n < 1 then []\nelse x::(clone x (n-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n((List.append (clone 0 (len2-len1)) l1), (List.append (clone 0 (len1-len2)) l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse h::t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (i, l) -> match x with\n| (x1, x2) -> (((x1+x2+i)/10), (((x1+x2+i) mod 10)::l))\nin\nlet base = (0, []) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (i, l) -> match x with\n| (x1, x2) -> (((x1+x2+i)/10), (((x1+x2+i) mod 10)::l))\nin\nlet base = (0, []) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (i, l) -> match x with\n| (x1, x2) -> (((x1+x2+i)/10), (((x1+x2+i) mod 10)::l))\nin\nlet base = (0, []) in\nlet args = (List.rev (List.combine (0::l1) (0::l2))) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 130-150:\n  | h::t -> (((h*i)+i') mod 10)::(mulByDigit ((((h*i)+i')/10), t))\n                                             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "min": "\nlet _ =\n  let rec mulByDigit i l =\n    let (i',l') = (0, (List.rev l)) in\n    match l' with\n    | [] -> []\n    | h::t -> (((h * i) + i') mod 10) ::\n        (mulByDigit ((((h * i) + i') / 10), t)) in\n  List.rev (mulByDigit i l);;\n", "in": "let rec mulByDigit i l = \nlet (i', l') = (0, (List.rev l)) in\nmatch l' with\n| [] -> []\n| h::t -> (((h*i)+i') mod 10)::(mulByDigit ((((h*i)+i')/10), t))\nin\nList.rev (mulByDigit i l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 51-72:\n  if i > 0 then mulByDigit ((i-1), (bigAdd l l))\n                           ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then mulByDigit ((i - 1), (bigAdd l l)) else l;;\n", "in": "let rec mulByDigit i l = \nif i > 0 then mulByDigit ((i-1), (bigAdd l l))\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = bigAdd l (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-68:\n  let rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i-1) l);;\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> bigAdd l (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd l (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> bigAdd l (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 92-153:\n  | h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (i,l) ->\n        (match x with\n         | [] -> []\n         | h::t ->\n             ((i + 1),\n               (bigAdd l (List.append (mulByDigit h l1) (clone 0 i))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> (i, [0])\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> ((i+1), bigAdd l (List.append (mulByDigit x l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
