{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-82:\n  | _ -> List.hd xs + sumList List.tl;;\n                              ^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-71:\n  | _ -> List.hd xs + sumList List.tl\n                              ^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "min": "\nlet rec sumList xs =\n  match xs with | _ -> (List.hd xs) + (sumList List.tl) | [] -> [];;\n", "in": "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + sumList List.tl\n| [] -> []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-82:\n  | _ -> List.hd xs + List.tl sumList;;\n                              ^^^^^^^\nError: This expression has type int list -> 'a list\n       but an expression was expected of type 'b list\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (List.tl sumList);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + List.tl sumList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-68:\n  | _ -> List.hd xs + 2;;\n         ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> (List.hd xs) + 2;;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-68:\n  | [] -> [];;\n          ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs = match xs with | _ -> (List.hd xs) + 2 | [] -> [];;\n", "in": "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + 2\n| [] -> []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-75:\n  | _ -> List.hd xs + (sumList List.tl xs);;\n                       ^^^^^^^\nError: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-74:\n  | _ -> List.hd xs + sumList List.tl xs;;\n                      ^^^^^^^\nError: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-65:\n  | (x::xs) -> x + x;;\n               ^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x + x;;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x + x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-75:\n  | xs -> List.hd xs + sumList List.tl xs;;\n                       ^^^^^^^\nError: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| xs -> List.hd xs + sumList List.tl xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-74:\n  | xs -> List.hd xs + sumList List.tl xs;;\n                       ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> List.hd xs + sumList List.tl xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "sumList [1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> 5"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-56:\n  | 0 -> [];;\n         ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = match n with | n -> 5 | 0 -> [];;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| 0 -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 51-53:\n  | 0 -> [] :: ns\n               ^^\nError: Unbound value ns\n", "min": "\nlet rec digitsOfInt n = match n with | 0 -> [] :: ns | n -> n :: ns;;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> [] :: ns\n| n -> n :: ns"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-52:\n  | n -> n :: ns;;\n              ^^\nError: Unbound value ns\n", "min": "\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: ns"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n :: ns"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-51:\n  | n -> (n::ns);;\n             ^^\nError: Unbound value ns\n", "min": "\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n::ns -> (n::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n mod 10)::ns"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> (n mod 10)::ns"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> (n mod 10)::ns"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-79:\n  | n -> List.hd (n mod 10)::ns;;\n                 ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (List.hd (n mod 10)) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd (n mod 10)::ns"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n - List.hd ((n mod 10)::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> digitsOfInt(n - List.hd ((n mod 10)::ns))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> digitsOfInt(n - List.hd ((n mod 10)::ns))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n - List.hd ((n mod 10)::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n mod List.hd ((n mod 10)::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> ((n mod 10)::ns)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> ((n mod 10)::ns)\ndigitsOfInt n / 10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-77:\n  | n -> ((n mod 10)::ns)\n         ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (((n mod 10) :: ns) digitsOfInt n) / 10;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-106:\n  | n -> ((n mod 10)::(digitsOfInt (n / 10)));;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-110:\n  | n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns;;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> ((n mod 10) :: (digitsOfInt (n / 10))) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10)::ns)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-97:\n  | n -> ((digitsOfInt (n / 10))::(n mod 10)::ns);;\n          ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-97:\n  | n -> ((digitsOfInt (n / 10))::((n mod 10)::ns));;\n          ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-96:\n  | n -> (digitsOfInt (n / 10))::((n mod 10)::ns);;\n         ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-97:\n  | n -> ((digitsOfInt (n / 10))::(n mod 10));;\n          ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-96:\n  | n -> (digitsOfInt (n / 10))::(n mod 10);;\n         ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-96:\n  | n -> (digitsOfInt (n / 10))::(n mod 10);;\n         ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt 222"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt 3124"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n > 0\nthen ((n mod 10)::(digitsOfInt (n / 10)))\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt -5"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-11:\n  digitsOfInt -5;;\n  ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt - 5;;\n", "in": "digitsOfInt -5"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-11:\n  digitsOfInt -5;;\n  ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt - 5;;\n", "in": "digitsOfInt (-5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt (0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt (0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt 123"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))\n| 0 -> ns"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt (0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt (-2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt -2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-11:\n  digitsOfInt -2;;\n  ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt - 2;;\n", "in": "digitsOfInt (-2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 25-32:\n  sumList digitsOfInt n;;\n  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 25-32:\n  sumList digitsOfInt n;;\n  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-60:\n  else digitsOfInt n;;\n       ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-59:\n  else digitsOfInt n;;\n       ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}, {"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 20"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nsumList digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 25-32:\n  sumList digitsOfInt n;;\n  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "in": "let rec digitalRoot n = \nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 9876"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 9876"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 3"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 3"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 9876"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 14"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 14"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = count + 1 in\nlet count = 0 in\nif n < 10\nthen count\nelse additivePersistence (digitalRoot n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 44-49:\n  let count = count + 1 in\n              ^^^^^\nError: Unbound value count\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec additivePersistence n =\n  let count = count + 1 in\n  let count = 0 in\n  if n < 10 then count else additivePersistence (digitalRoot n);;\n", "in": "let rec additivePersistence n =\nlet count = 0 in\nlet count = count + 1 in\nif n < 10\nthen count\nelse additivePersistence (digitalRoot n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nlet count = count + 1 in\nif n < 10\nthen count\nelse additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nif (sumList (digitsOfInt n)) != digitalRoot n\nthen count = count + 1\nelse additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nif (sumList (digitsOfInt n)) != digitalRoot n\nthen count + 1\nelse additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) != digitalRoot n'\nthen count + 1\nelse additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) != digitalRoot n'\nthen count\nelse count + 1 and additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\ncount = count + 1 in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value n'\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 124-126:\n  if (sumList (digitsOfInt n)) = digitalRoot n'\n                                             ^^\nError: Unbound value n'\n", "min": "\nlet count = 3;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet n = (-234);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet _ =\n  let rec additivePersistence n =\n    let count = 0\n    and n' = n in count = (count + 1) in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else additivePersistence (sumList (digitsOfInt n));;\n", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\ncount = count + 1\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l'))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n ="}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (listReverse (List.tl l))::(List.hd l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-96:\n  | l -> (listReverse (List.tl l))::(List.hd l);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | l -> (listReverse (List.tl l)) :: (List.hd l);;\n", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| h::t -> (List.hd l)::(listReverse (List.tl l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (List.hd l)::l' (List.tl l) in\nlr [] listReverse"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-89:\n  | h::t -> lr (List.hd l)::l' (List.tl l) in\n            ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  let rec lr l' =\n    match l with | [] -> l' | h::t -> (lr (List.hd l)) :: (l' (List.tl l)) in\n  lr [] listReverse;;\n", "in": "let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-85:\n  | h::t -> lr (h::l') t in\n               ^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "min": "\nlet rec listReverse l =\n  let rec lr l' = match l with | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "in": "let rec listReverse l = \nlet rec lr l' = function\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-104:\n  lr [] listReverse;;\n        ^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 89-100:\n  lr [] listReverse;;\n        ^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n", "min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | h::t -> (List.hd l) :: (listReverse (List.tl l));;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nexplode w"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 11-16:\n  palindrome hello;;\n             ^^^^^\nError: Unbound value hello\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = explode w;;\n\nlet _ = palindrome hello;;\n", "in": "palindrome \"hello\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nexplode w = listReverse (explode w )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "palindrome \"hello\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "palindrome \"racecar\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = failwith \"TBD: ...\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet rec count i =\nif n = digitalRoot n\nthen i\nelse (sumList (digitsOfInt n))\nin\ncount 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet rec countHelper n i =\nlet countHelper2 = countHelper3 n in\nmatch countHelper2 with\n| i = digitalRoot n -> count\n| n -> countHelper countHelper3 n (i + 1)\nin\ncountHelper 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot(n)\nthen i\nelse helper n (sumList (digitsOfInt n)) (count + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot(n)\nthen i\nelse helper n (sumList (digitsOfInt n)) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nmatch n' with\nif n' = digitalRoot(n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 60-71:\n  if n' = digitalRoot(n)\n          ^^^^^^^^^^^\nError: Unbound value digitalRoot\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 60-71:\n  if n' = digitalRoot (n)\n          ^^^^^^^^^^^\nError: Unbound value digitalRoot\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 1111;\nlet _ = additivePersistence 9876"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 98765"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 99999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 9999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 999999999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 99999999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 9999999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 9999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 99999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 9999999999"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 3"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 9"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 11"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 15"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 18"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 22"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 99"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 1010"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "additivePersistence 981"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse (((n mod 10)::(digitsOfInt (n / 10))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse (ns)\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ((digitsOfInt (n / 10))) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse (( digitsOfInt (n / 10) ) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse ( ((n mod 10) ::  ( digitsOfInt (n / 10)) ) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-133:\n  else ((n mod 10) ::  ( digitsOfInt (n / 10)) :: []);;\n                       ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 112-132:\n  else ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) );;\n                         ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-133:\n  else ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: [];;\n                       ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [(n mod 10) :: (digitsOfInt (n / 10))];;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 115-118:\n  else let rev = listReverse ns' in\n                             ^^^\nError: Unbound value ns'\nHint: Did you mean ns?\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else\n        (let rev = listReverse ns' in (n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 115-118:\n  else let rev = listReverse ns' in\n                             ^^^\nError: Unbound value ns'\nHint: Did you mean ns?\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else\n        (let rev = listReverse ns' in (n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse ( ((n mod 10) ::  ( digitsOfInt (n / 10)) ) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| (h::t) -> listReverse ns\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-84:\n  | 0 -> ns\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | h::t -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| _ -> listReverse ns\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\n| _ -> listReverse ns"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "digitalRoot 14"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sumList = [1; 2; 3]"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-1:\n  h::t sumList;;\n  ^\nError: Unbound value h\n", "min": "\nlet sumList = [1; 2; 3];;\n\nlet _ = h :: (t sumList);;\n", "in": "(h::t) sumList"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 1-2:\n  (h::t) sumList;;\n   ^\nError: Unbound value h\n", "min": "\nlet sumList = [1; 2; 3];;\n\nlet _ = (h :: t) sumList;;\n", "in": "sumList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet this = listReverse n in\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-69:\n  | 0 -> []\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this = listReverse n in\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nlet this = function\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-138:\n  in this listReverse n;;\n     ^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  this listReverse n;;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}, {"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet xxx = function \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 141-144:\n  in listReverse (xxx n);;\n                  ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 101-104:\n  else ((n mod 10) :: ( xxx (n / 10)))\n                        ^^^\nError: Unbound value xxx\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let digitsOfInt n = \nlet rec xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 105-108:\n  else ((n mod 10) :: ( xxx (n / 10)))\n                        ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 144-147:\n  in listReverse (xxx n);;\n                  ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 144-147:\n  in listReverse (xxx n);;\n                  ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 144-147:\n  in listReverse (xxx n);;\n                  ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let rec digitsOfInt n = \nlet xxx n =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec xxx n =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"}]}
