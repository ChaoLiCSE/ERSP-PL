{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl);;\n", "out": "Characters 75-82:\n  | _ -> List.hd xs + sumList List.tl;;\n                              ^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + sumList List.tl\n| [] -> []", "min": "\nlet rec sumList xs =\n  match xs with | _ -> (List.hd xs) + (sumList List.tl) | [] -> [];;\n", "out": "Characters 64-71:\n  | _ -> List.hd xs + sumList List.tl\n                              ^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + List.tl sumList", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (List.tl sumList);;\n", "out": "Characters 75-82:\n  | _ -> List.hd xs + List.tl sumList;;\n                              ^^^^^^^\nError: This expression has type int list -> 'a list\n       but an expression was expected of type 'b list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "min": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> List.hd xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2", "min": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> (List.hd xs) + 2;;\n", "out": "Characters 54-68:\n  | _ -> List.hd xs + 2;;\n         ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + 2\n| [] -> []", "min": "\nlet rec sumList xs = match xs with | _ -> (List.hd xs) + 2 | [] -> [];;\n", "out": "Characters 66-68:\n  | [] -> [];;\n          ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "out": "Characters 68-75:\n  | _ -> List.hd xs + (sumList List.tl xs);;\n                       ^^^^^^^\nError: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "out": "Characters 67-74:\n  | _ -> List.hd xs + sumList List.tl xs;;\n                      ^^^^^^^\nError: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x + x", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x + x;;\n", "out": "Characters 60-65:\n  | (x::xs) -> x + x;;\n               ^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| xs -> List.hd xs + sumList List.tl xs", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "out": "Characters 68-75:\n  | xs -> List.hd xs + sumList List.tl xs;;\n                       ^^^^^^^\nError: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> List.hd xs + sumList List.tl xs", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "out": "Characters 67-74:\n  | xs -> List.hd xs + sumList List.tl xs;;\n                       ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "sumList [1]", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet _ = sumList [1];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> 5", "min": "\nlet rec digitsOfInt n = match n with | n -> 5;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| 0 -> []", "min": "\nlet rec digitsOfInt n = match n with | n -> 5 | 0 -> [];;\n", "out": "Characters 54-56:\n  | 0 -> [];;\n         ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: []", "min": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> [] :: ns\n| n -> n :: ns", "min": "\nlet rec digitsOfInt n = match n with | 0 -> [] :: ns | n -> n :: ns;;\n", "out": "Characters 51-53:\n  | 0 -> [] :: ns\n               ^^\nError: Unbound value ns\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: ns", "min": "\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n", "out": "Characters 50-52:\n  | n -> n :: ns;;\n              ^^\nError: Unbound value ns\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n :: ns", "min": "\nlet rec digitsOfInt n = match n with | n::ns -> n :: ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n", "min": "\nlet rec digitsOfInt n = match n with | n::ns -> n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)", "min": "\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n", "out": "Characters 49-51:\n  | n -> (n::ns);;\n             ^^\nError: Unbound value ns\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n::ns -> (n::ns)", "min": "\nlet rec digitsOfInt n = match n with | n::ns -> n :: ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)", "min": "\nlet ns = [];;\n\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n mod 10)::ns", "min": "\nlet ns = [];;\n\nlet rec digitsOfInt n = match n with | n -> (n mod 10) :: ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> (n mod 10)::ns", "min": "\nlet rec digitsOfInt n = let ns = [] in match n with | n -> (n mod 10) :: ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> (n mod 10)::ns", "min": "\nlet rec digitsOfInt n = let ns = [] in match n with | n -> (n mod 10) :: ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd (n mod 10)::ns", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (List.hd (n mod 10)) :: ns;;\n", "out": "Characters 69-79:\n  | n -> List.hd (n mod 10)::ns;;\n                 ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> List.hd ((n mod 10) :: ns);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n - List.hd ((n mod 10)::ns)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> digitsOfInt(n - List.hd ((n mod 10)::ns))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | n -> digitsOfInt (n - (List.hd ((n mod 10) :: ns)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> digitsOfInt(n - List.hd ((n mod 10)::ns))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | n -> digitsOfInt (n - (List.hd ((n mod 10) :: ns)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n - List.hd ((n mod 10)::ns)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n mod List.hd ((n mod 10)::ns)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n mod (List.hd ((n mod 10) :: ns));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> List.hd ((n mod 10) :: ns);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> ((n mod 10)::ns)", "min": "\nlet rec digitsOfInt n = let ns = [] in match n with | n -> (n mod 10) :: ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> ((n mod 10)::ns)\ndigitsOfInt n / 10", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (((n mod 10) :: ns) digitsOfInt n) / 10;;\n", "out": "Characters 61-77:\n  | n -> ((n mod 10)::ns)\n         ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": "Characters 70-106:\n  | n -> ((n mod 10)::(digitsOfInt (n / 10)));;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> ((n mod 10) :: (digitsOfInt (n / 10))) :: ns;;\n", "out": "Characters 70-110:\n  | n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns;;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10)::ns)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "out": "Characters 75-97:\n  | n -> ((digitsOfInt (n / 10))::(n mod 10)::ns);;\n          ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "out": "Characters 75-97:\n  | n -> ((digitsOfInt (n / 10))::((n mod 10)::ns));;\n          ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "out": "Characters 74-96:\n  | n -> (digitsOfInt (n / 10))::((n mod 10)::ns);;\n         ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "out": "Characters 74-96:\n  | n -> (digitsOfInt (n / 10))::((n mod 10)::ns);;\n         ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 75-97:\n  | n -> ((digitsOfInt (n / 10))::(n mod 10));;\n          ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 74-96:\n  | n -> (digitsOfInt (n / 10))::(n mod 10);;\n         ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 74-96:\n  | n -> (digitsOfInt (n / 10))::(n mod 10);;\n         ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt 222", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 222;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt 3124", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 3124;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n > 0\nthen ((n mod 10)::(digitsOfInt (n / 10)))\nelse []", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "digitsOfInt -5", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt - 5;;\n", "out": "Characters 0-11:\n  digitsOfInt -5;;\n  ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "digitsOfInt -5", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt - 5;;\n", "out": "Characters 0-11:\n  digitsOfInt -5;;\n  ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (-5)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt (-5);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (-1)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt (-1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (0)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (0)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt 123", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 123;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))\n| 0 -> ns", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10))\n  | 0 -> ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (0)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (-2)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt (-2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "digitsOfInt -2", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt - 2;;\n", "out": "Characters 0-11:\n  digitsOfInt -2;;\n  ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (-2)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt (-2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet n = (-2);;\n\nlet _ = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet n = (-234);;\n\nlet _ = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitalRoot n = \nsumList digitsOfInt n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "out": "Characters 25-32:\n  sumList digitsOfInt n;;\n  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nsumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = sumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = sumList (digitsOfInt (n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n = digitsOfInt n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digitalRoot n = digitsOfInt n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n = digitsOfInt n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digitalRoot n = digitsOfInt n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitsOfInt n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n", "out": "Characters 47-60:\n  else digitsOfInt n;;\n       ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitalRoot n =\nif n < 10\nthen n\nelse digitsOfInt n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n", "out": "Characters 46-59:\n  else digitsOfInt n;;\n       ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 20", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = digitsOfInt n;;\n\nlet _ = digitalRoot 20;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitalRoot n = \nsumList digitsOfInt n", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "out": "Characters 25-32:\n  sumList digitsOfInt n;;\n  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nsumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 9876", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 9876", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 9876;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 0", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 1", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 2", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 3", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 3;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 3", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 3;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 10", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 10;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 9876", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 9876;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 14", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 14;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 14", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 14;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nlet count = count + 1 in\nlet count = 0 in\nif n < 10\nthen count\nelse additivePersistence (digitalRoot n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec additivePersistence n =\n  let count = count + 1 in\n  let count = 0 in\n  if n < 10 then count else additivePersistence (digitalRoot n);;\n", "out": "Characters 44-49:\n  let count = count + 1 in\n              ^^^^^\nError: Unbound value count\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nlet count = count + 1 in\nif n < 10\nthen count\nelse additivePersistence (digitalRoot n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  let count = count + 1 in\n  if n < 10 then count else additivePersistence (digitalRoot n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nlet count = count + 1 in\nif n < 10\nthen count\nelse additivePersistence (digitalRoot n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  let count = count + 1 in\n  if n < 10 then count else additivePersistence (digitalRoot n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nlet count = count + 1 in\nif n < 10\nthen count\nelse additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  let count = count + 1 in\n  if n < 10 then count else additivePersistence (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nif (sumList (digitsOfInt n)) != digitalRoot n\nthen count = count + 1\nelse additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (sumList (digitsOfInt n)) != (digitalRoot n)\n  then count = (count + 1)\n  else additivePersistence (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nif (sumList (digitsOfInt n)) != digitalRoot n\nthen count + 1\nelse additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (sumList (digitsOfInt n)) != (digitalRoot n)\n  then count + 1\n  else additivePersistence (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) != digitalRoot n'\nthen count + 1\nelse additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  if (sumList (digitsOfInt n)) != (digitalRoot n')\n  then count + 1\n  else additivePersistence (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nlet count = count + 1 in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  let count = count + 1 in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else additivePersistence (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\ncount = count + 1 in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse additivePersistence (sumList (digitsOfInt n))", "min": "\nlet count = 3;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet n = (-234);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet _ =\n  let rec additivePersistence n =\n    let count = 0\n    and n' = n in count = (count + 1) in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else additivePersistence (sumList (digitsOfInt n));;\n", "out": "Error: Unbound value n'\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 124-126:\n  if (sumList (digitsOfInt n)) = digitalRoot n'\n                                             ^^\nError: Unbound value n'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else\n    (let count = count + 1 in additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else\n    (let count = count + 1 in additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l))", "min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | l -> (List.hd l) :: (listReverse (List.tl l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else\n    (let count = count + 1 in additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l'))", "min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | l -> (List.hd l) :: (listReverse (List.tl l'));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else\n    (let count = count + 1 in additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else\n    (let count = count + 1 in additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l))", "min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | l -> (List.hd l) :: (listReverse (List.tl l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (listReverse (List.tl l))::(List.hd l)", "min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | l -> (listReverse (List.tl l)) :: (List.hd l);;\n", "out": "Characters 71-96:\n  | l -> (listReverse (List.tl l))::(List.hd l);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| h::t -> (List.hd l)::(listReverse (List.tl l))", "min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | h::t -> (List.hd l) :: (listReverse (List.tl l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (List.hd l)::l' (List.tl l) in\nlr [] listReverse", "min": "\nlet rec listReverse l =\n  let rec lr l' =\n    match l with | [] -> l' | h::t -> (lr (List.hd l)) :: (l' (List.tl l)) in\n  lr [] listReverse;;\n", "out": "Characters 75-89:\n  | h::t -> lr (List.hd l)::l' (List.tl l) in\n            ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "min": "\nlet rec listReverse l =\n  let rec lr l' = match l with | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "out": "Characters 78-85:\n  | h::t -> lr (h::l') t in\n               ^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "min": "\nlet rec listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "out": "Characters 93-104:\n  lr [] listReverse;;\n        ^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | h::t -> (List.hd l) :: (listReverse (List.tl l));;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "out": "Characters 89-100:\n  lr [] listReverse;;\n        ^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nexplode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = explode w;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "palindrome \"hello\"", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = explode w;;\n\nlet _ = palindrome \"hello\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nexplode w = listReverse (explode w )", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "palindrome \"hello\"", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n\nlet _ = palindrome \"hello\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "palindrome \"racecar\"", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = failwith \"TBD: ...\"", "min": "\nlet rec additivePersistence n = failwith \"TBD: ...\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = \nlet rec count i =\nif n = digitalRoot n\nthen i\nelse (sumList (digitsOfInt n))\nin\ncount 0", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec count i =\n    if n = (digitalRoot n) then i else sumList (digitsOfInt n) in\n  count 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot(n)\nthen i\nelse helper n (sumList (digitsOfInt n)) (count + 1)\nin\nhelper n n 0", "min": "\nlet count = 3;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n)) (count + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot(n)\nthen i\nelse helper n (sumList (digitsOfInt n)) (i + 1)\nin\nhelper n n 0", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n)) (i + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": "Characters 60-71:\n  if n' = digitalRoot (n)\n          ^^^^^^^^^^^\nError: Unbound value digitalRoot\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": "Characters 60-71:\n  if n' = digitalRoot (n)\n          ^^^^^^^^^^^\nError: Unbound value digitalRoot\n"}, {"type": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 1111", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 1111;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 98765", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 98765;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 99999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 99999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 9999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 9999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 999999999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 999999999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 99999999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 99999999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 9999999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 9999999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 9999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 9999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 99999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 99999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 9999999999", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 9999999999;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 1", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 2", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 3", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 3;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 9", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 9;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 10", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 10;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 11", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 11;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 15", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 15;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 18", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 18;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 22", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 22;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 99", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 99;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 1010", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 1010;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "additivePersistence 981", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n\nlet _ = additivePersistence 981;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse (((n mod 10)::(digitsOfInt (n / 10))))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> listReverse ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> listReverse ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse (ns)\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> listReverse ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ((digitsOfInt (n / 10))) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) ) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) ) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse ( ((n mod 10) ::  ( digitsOfInt (n / 10)) ) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "out": "Characters 112-132:\n  else ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) );;\n                         ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [(n mod 10) :: (digitsOfInt (n / 10))];;\n", "out": "Characters 110-133:\n  else ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: [];;\n                       ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) )", "min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else\n        (let rev = listReverse ns' in (n mod 10) :: (digitsOfInt (n / 10)));;\n", "out": "Characters 115-118:\n  else let rev = listReverse ns' in\n                             ^^^\nError: Unbound value ns'\nHint: Did you mean ns?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else\n        (let rev = listReverse ns' in (n mod 10) :: (digitsOfInt (n / 10)));;\n", "out": "Characters 115-118:\n  else let rev = listReverse ns' in\n                             ^^^\nError: Unbound value ns'\nHint: Did you mean ns?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else (let rev = listReverse ns in (n mod 10) :: (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else (let rev = listReverse ns in (n mod 10) :: (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse ( ((n mod 10) ::  ( digitsOfInt (n / 10)) ) )", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| (h::t) -> listReverse ns\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | h::t -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": "Characters 83-84:\n  | 0 -> ns\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| _ -> listReverse ns\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | _ -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\n| _ -> listReverse ns", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10))\n  | _ -> listReverse ns;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot 14", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 14;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sumList = [1; 2; 3]", "min": "\nlet sumList = [1; 2; 3];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "(h::t) sumList", "min": "\nlet sumList = [1; 2; 3];;\n\nlet _ = (h :: t) sumList;;\n", "out": "Characters 1-2:\n  (h::t) sumList;;\n   ^\nError: Unbound value h\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "sumList", "min": "\nlet sumList = [1; 2; 3];;\n\nlet _ = sumList;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nlet this = listReverse n in\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this = listReverse n in\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": "Characters 68-69:\n  | 0 -> []\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet this = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  this listReverse n;;\n", "out": "Characters 134-138:\n  in this listReverse n;;\n     ^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "out": "Characters 141-144:\n  in listReverse (xxx n);;\n                  ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "out": "Characters 101-104:\n  else ((n mod 10) :: ( xxx (n / 10)))\n                        ^^^\nError: Unbound value xxx\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nlet rec xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "out": "Characters 105-108:\n  else ((n mod 10) :: ( xxx (n / 10)))\n                        ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "out": "Characters 144-147:\n  in listReverse (xxx n);;\n                  ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "out": "Characters 144-147:\n  in listReverse (xxx n);;\n                  ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "out": "Characters 144-147:\n  in listReverse (xxx n);;\n                  ^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet xxx n =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx n =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec xxx n =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx n =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx n =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet digitsOfInt n =\n  let rec xxx n =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "out": ""}]}
