{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then seen\nelse (h::seen) \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then b'\nelse wwhile (f,b')", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then b' else wwhile (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then b' else wwhile (f, b');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then wwhile (f,b')\nelse b'", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nif b = (f b) then b\nelse fixpoint (f, f b)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = if b = (f b) then b else fixpoint (f, (f b));;\n", "out": "Characters 57-58:\n  else fixpoint (f, f b);;\n                 ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "out": "Characters 68-69:\n  else fixpoint (f, y);;\n                 ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "out": "Characters 68-69:\n  else fixpoint (f, y);;\n                 ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet y = (f b) in\nif b = y then b\nelse fixpoint (f, y)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "out": "Characters 70-71:\n  else fixpoint (f, y);;\n                 ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| aPrime -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | aPrime -> if b = aPrime then b else fixpoint (f, aPrime);;\n", "out": "Characters 101-102:\n  else fixpoint (f, aPrime);;\n                 ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | (aPrime,_) -> if b = aPrime then b else fixpoint (f, aPrime);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | (aPrime,_) -> if b = aPrime then b else fixpoint (f, aPrime);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile( f,b)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nlet f' b = (f b, b != f b) in\nwwhile(f',b)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' b = ((f b), (b != (f b))) in wwhile (f', b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' b = ((f b), (b != (f b))) in wwhile (f', b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| Thresh (e1,e2,e3,e4)  ->\n\"(\" ^ exprToString e1 ^\n\"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^\n\":\" ^ exprToString e4 ^ \")\"\n| Times (e1,e2) ->\nexprToString e1 ^\n\"*\" ^ exprToString e2\n| Average (e1,e2) ->\n\"((\" ^ exprToString e1 ^\n\"+\" ^ exprToString e2 ^ \")/2)\"\n| Cosine (e1) ->\n\"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Sine (e1) ->\n\"sin(pi*\" ^ exprToString e1 ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2.0\n  | Cosine e1 -> cos (3.142 *. (eval (e1, x, y)))\n  | Sine e1 -> sin (3.142 *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": "Characters 216-254:\n  | Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (3.142 *. (eval (e1, x, y)))\n  | Sine e1 -> sin (3.142 *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (3.142 *. (eval (e1, x, y)))\n  | Sine e1 -> sin (3.142 *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "min": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Characters 403-504:\n  ...................buildThresh( build(rand, depth-1), build(rand, depth-1),\n  build(rand, depth-1), build(rand, depth-1) )..\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Characters 327-383:\n  else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) );;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Characters 403-503:\n  else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) );;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "out": "Characters 141-174:\n  if y = 2 then buildSine( build(rand, depth-1) );;\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let temp = rand(0,1) = 0 in\nif temp then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let temp = (rand (0, 1)) = 0 in if temp then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Characters 422-523:\n  ...................buildThresh( build(rand, depth-1), build(rand, depth-1),\n  build(rand, depth-1), build(rand, depth-1) )..\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Characters 403-504:\n  ...................buildThresh( build(rand, depth-1), build(rand, depth-1),\n  build(rand, depth-1), build(rand, depth-1) )..\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet _ = buildX ();;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> buildX ();;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> buildSine( build(rand, depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> buildSine (build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "out": "Characters 141-174:\n  if y = 2 then buildSine( build(rand, depth-1) );;\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "out": "Characters 143-176:\n  if (y = 2) then buildSine( build(rand, depth-1) );;\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in build (rand, (y - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in build (rand, (y - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Characters 405-506:\n  ...................buildThresh( build(rand, depth-1), build(rand, depth-1),\n  build(rand, depth-1), build(rand, depth-1) )..\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then buildX ();;\n", "out": "Characters 139-147:\n  if y = 2 then buildX();;\n                ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then buildX ();;\n", "out": "Characters 139-147:\n  if y = 2 then buildX();;\n                ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y == 2 then buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y == 2 then buildX ();;\n", "out": "Characters 140-148:\n  if y == 2 then buildX();;\n                 ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then 5", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then 5;;\n", "out": "Characters 139-140:\n  if y = 2 then 5;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\ny", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in y;;\n", "out": "Characters 125-126:\n  y;;\n  ^\nError: This expression has type int but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then y;;\n", "out": "Characters 141-142:\n  if (y = 2) then y;;\n                  ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif (y = 2) then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "out": "Characters 136-137:\n  if (y = 2) then y;;\n                  ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then buildX ());;\n", "out": "Characters 134-142:\n  if y = 2 then buildX();;\n                ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "out": "Characters 134-135:\n  if y = 2 then y;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\ny = 2", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in y = 2);;\n", "out": "Characters 120-125:\n  y = 2;;\n  ^^^^^\nError: This expression has type bool but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "out": "Characters 134-135:\n  if y = 2 then y;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "out": "Characters 134-135:\n  if y = 2 then y;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then VarX else VarY\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "out": "Characters 126-127:\n  if y = 2 then y;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then VarX else VarY\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "out": "Characters 128-129:\n  if y = 2 then y;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "out": "Characters 136-137:\n  if y = 2 then y;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "buildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet _ = buildX ();;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "if rand (0,1) = 0 then buildX() else buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rand (a,b) = if a < b then a else b;;\n\nlet _ = if (rand (0, 1)) = 0 then buildX () else buildY ();;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "out": "Characters 72-80:\n  if rand (0,1) = 0 then buildX() else buildY();;\n                         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rand (a,b) = if a < b then a else b;;\n\nlet _ =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "out": "Characters 3-8:\n  if depth = 0 then\n     ^^^^^\nError: Unbound value depth\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "out": "Characters 72-80:\n  if rand (0,1) = 0 then buildX() else buildY();;\n                         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "out": "Characters 138-139:\n  if y = 2 then y;;\n                ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "out": "Characters 74-82:\n  if (rand (0,1) = 0) then buildX() else buildY();;\n                           ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "out": "Characters 74-82:\n  if (rand (0,1) = 0) then buildX() else buildY();;\n                           ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 ->\nbuildX()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in match y with | 2 -> buildX ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (let y = rand (2, 6) in\n     match y with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) ) \n| _ -> failwith \"Unexpected output from rand\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (let y = rand (2, 6) in\n     match y with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> failwith \"Unexpected output from rand\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 ->\nif (rand (0,1) = 0) then buildX() else buildY()\n| _ ->\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) ) \n| _ -> failwith \"Unexpected output from rand\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      (match y with\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      (match y with\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 7) in\n      (match y with\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 7) in\n      (match y with\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 ->\nif (rand (0,2) = 0) then buildX() else buildY()\n| _ ->\nlet y =  2 * rand (2,7) in match y with\n| 4 | 5 -> buildSine( build(rand, depth-1) ) \n| 6 | 7 -> buildCosine( build(rand, depth-1) )\n| 8 | 9 | 10 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 11 | 12 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 13 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) ) \n| _ -> failwith \"Unexpected output from rand\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = 2 * (rand (2, 7)) in\n      (match y with\n       | 4|5 -> buildSine (build (rand, (depth - 1)))\n       | 6|7 -> buildCosine (build (rand, (depth - 1)))\n       | 8|9|10 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 11|12 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 13 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| MultDivPi(e1,e2,e3) ->\n( (eval (e1,x,y)) *. (eval (e2,x,y)) *. (eval (e3,x,y)) ) /. pi\n| Div7(e1) ->\n(eval (e1,x,y)) /. 7.0\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 ->\nif (rand (0,2) = 0) then buildX() else buildY()\n| _ ->\nlet y =  (10 * rand (2,9)) + rand(0,10) in match y with\n| 20 | 21 | 22 | 23 | 24\n| 25 | 26 | 27 | 28 | 29 -> buildSine( build(rand, depth-1) ) \n| 30 | 31 | 32 | 33 | 34\n| 35 | 36 | 37 | 38 | 39 \n| 40 | 41 | 42 | 43 | 44\n| 45 | 46 | 47 | 48 | 49 \n| 50 | 51 | 52 | 53 | 54\n-> buildCosine( build(rand, depth-1) )\n| 55 | 56 | 57 | 58 | 59\n| 60 | 61 | 62 | 63 | 64\n-> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 65 | 66 | 67 | 68 | 69\n| 70 | 71 | 72 | 73 | 74\n-> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 75 | 76 | 77 | 78 | 79\n-> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )\n| 80 | 81 | 82 | 83 | 84\n-> buildDiv7( build(rand, depth-1) )\n| 85 | 86 | 87 | 88 | 89\n-> buildMultDivPi( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1) )\n| _ -> failwith \"Unexpected output from rand\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDiv7 e = Div7 e;;\n\nlet buildMultDivPi (e1,e2,e3) = MultDivPi (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = (10 * (rand (2, 9))) + (rand (0, 10)) in\n      (match y with\n       | 20|21|22|23|24|25|26|27|28|29 ->\n           buildSine (build (rand, (depth - 1)))\n       | 30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52\n         |53|54 -> buildCosine (build (rand, (depth - 1)))\n       | 55|56|57|58|59|60|61|62|63|64 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 65|66|67|68|69|70|71|72|73|74 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 75|76|77|78|79 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 80|81|82|83|84 -> buildDiv7 (build (rand, (depth - 1)))\n       | 85|86|87|88|89 ->\n           buildMultDivPi\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> failwith \"Unexpected output from rand\");;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")/pi)\")))))\n  | Div7 e1 -> \"(\" ^ ((exprToString e1) ^ \"/7)\")\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
