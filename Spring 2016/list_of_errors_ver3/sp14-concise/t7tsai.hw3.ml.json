{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in \nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ", "min": "\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l));;\n", "out": "Characters 34-43:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ;;\n                               ^^^^^^^^^\nError: Unbound value sepConcat\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "\r\n(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*)\n\r\nlet _ = stringOfList str", "min": "\nlet _ = stringOfList str;;\n", "out": "Characters 13-25:\n  let _ = stringOfList str;;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = failwith \"to be implemented\"", "min": "\nlet rec clone x n = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "\n\r\nlet pipe fs =  \nlet f a x = x base in\nle", "min": "\nlet pipe fs = let f a x = x base in le;;\n", "out": "Characters 33-37:\n  let f a x = x base in\n                ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ", "min": "\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l));;\n", "out": "Characters 34-43:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ;;\n                               ^^^^^^^^^\nError: Unbound value sepConcat\n"}, {"type": "scope", "in": "let stringOfList f l = \"[\" ^ sepConcat \";", "min": "\nlet stringOfList f l = \"[\" ^ (sepConcat \";\");;\n", "out": "Characters 29-38:\n  let stringOfList f l = \"[\" ^ sepConcat \";\";;\n                               ^^^^^^^^^\nError: Unbound value sepConcat\n"}, {"type": "scope", "in": "\r\n(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*)\n\r\nlet _ = stringOfList str", "min": "\nlet _ = stringOfList str;;\n", "out": "Characters 13-25:\n  let _ = stringOfList str;;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]", "min": "\nlet _ = padZero [9; 9] [1; 0; 0; 2] let _ = padZero [1; 0; 0; 2] [9; 9];;\n", "out": "Characters 9-16:\n  let _ = padZero [9;9] [1;0;0;2]\n          ^^^^^^^\nError: Unbound value padZero\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]", "min": "\nlet _ = padZero [9; 9] [1; 0; 0; 2] let _ = padZero [1; 0; 0; 2] [9; 9];;\n", "out": "Characters 9-16:\n  let _ = padZero [9;9] [1;0;0;2]\n          ^^^^^^^\nError: Unbound value padZero\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t\nelse h :: removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then t\nelse  removeZero t\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then t else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in \nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in \nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a  x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)]", "min": "\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)];;\n", "out": "Characters 9-13:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)];;\n          ^^^^\nError: Unbound value pipe\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =  \nlet f a x = x a  in\nfun base -> \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec mulByDigit i l = \nmatch l with \n| [] -> []\n| h::t -> bigAdd [h1*i] (mulByDigit i t1)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h::t -> bigAdd [h1 * i] (mulByDigit i t1);;\n", "out": "Characters 69-71:\n  | h::t -> bigAdd [h1*i] (mulByDigit i t1);;\n                    ^^\nError: Unbound value h1\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse \nif i = 1 then l\nelse \nif i = 2 then bigAdd l l\nelse \nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-1) l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 1) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit 1 l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (mulByDigit (i - 2) l) (mulByDigit 1 l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit i-2 l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else bigAdd (mulByDigit (i - 2) l) ((mulByDigit i) - (2 l));;\n", "out": "Characters 98-110:\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit i-2 l);;\n                                    ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1 then l else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let x = bigAdd [9;9;9;9] [9;9;9;9]", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let y = bigAdd x x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let z = bigAdd y x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let t = bigAdd x z", "min": "\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let r = bigAdd t x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet t = bigAdd x z;;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet r = bigAdd t x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let e = bigAdd r x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet r = bigAdd t x;;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet e = bigAdd r x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let t = bigAdd x z", "min": "\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let d = bigAdd t x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet t = bigAdd x z;;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet d = bigAdd t x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let y = bigAdd x x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let z = bigAdd y x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let t = bigAdd x z", "min": "\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let d = bigAdd t x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet t = bigAdd x z;;\n\nlet x = [9; 9; 9; 9];;\n\nlet d = bigAdd t x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let 1 = bigAdd x x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 1 = bigAdd x x;;\n", "out": "Characters 8-18:\n  let 1 = bigAdd x x;;\n          ^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}, {"type": "type", "in": "let 2 = bigAdd 1 x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 2 = bigAdd 1 x;;\n", "out": "Characters 15-16:\n  let 2 = bigAdd 1 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}, {"type": "type", "in": "let 3 = bigAdd 2 x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 3 = bigAdd 2 x;;\n", "out": "Characters 15-16:\n  let 3 = bigAdd 2 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}, {"type": "type", "in": "let 4 = bigAdd 3 x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 4 = bigAdd 3 x;;\n", "out": "Characters 15-16:\n  let 4 = bigAdd 3 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}, {"type": "type", "in": "let 5 = bigAdd 4 x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 5 = bigAdd 4 x;;\n", "out": "Characters 15-16:\n  let 5 = bigAdd 4 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let y = bigAdd x x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let d = bigAdd c x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet c = bigAdd b x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet d = bigAdd c x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let e = bigAdd e x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n\nlet r = bigAdd t x;;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet e = bigAdd r x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet e = bigAdd e x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let e = bigAdd d x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet d = bigAdd c x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet e = bigAdd d x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f = bigAdd e x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet e = bigAdd d x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet f = bigAdd e x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g = bigAdd f x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet f = bigAdd e x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet g = bigAdd f x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let h = bigAdd g x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f = bigAdd e x", "min": "\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet e = bigAdd d x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet f = bigAdd e x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 2) l) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (mulByDigit x list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) -> ((mulByDigit x list1), (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x*10 list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, ((mulByDigit x) * (10 list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 71-83:\n  | (list1, res) -> (list1, mulByDigit x*10 list1) in\n                            ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\n                                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*(10**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 86-88:\n  | (list1, res) -> (list1, mulByDigit (x*(10**List.length res)) list1) in\n                                           ^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float float_of_int x*.(10.**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             ((int_of_float float_of_int x) *. (10. ** (List.length res)))\n             list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, mulByDigit (int_of_float float_of_int x*.(10.**List.length res)) list1) in\n                                        ^^^^^^^^^^^^\nError: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\n                                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*.10.**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x *. (10. ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 91-106:\n  | (list1, res) -> (list1, mulByDigit (x*.10.**List.length res) list1) in\n                                                ^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*(10 exp List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 exp List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 86-88:\n  | (list1, res) -> (list1, mulByDigit (x*(10 exp List.length res)) list1) in\n                                           ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit ((x * 10) * (List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 ** List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10 ** List.length res) list1) in\n                                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 int_of_float ** List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit (x * ((10 int_of_float) ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10 int_of_float ** List.length res) list1) in\n                                          ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             (int_of_float\n                ((float_of_int x) *. (10. ** (float_of_int List.length res))))\n             list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 122-134:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n                                                                               ^^^^^^^^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             (int_of_float\n                ((float_of_int x) *. (10. ** (float_of_int List.length res))))\n             list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 122-134:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n                                                                               ^^^^^^^^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             ((int_of_float (float_of_int x)) *.\n                (10. ** (float_of_int List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-112:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             ((int_of_float (float_of_int x)) *.\n                (10. ** (float_of_int (List.length res)))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-112:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             (int_of_float\n                ((float_of_int x) *.\n                   (10. ** (float_of_int (List.length res))))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*List.lengh res list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res ((mulByDigit x) * (List.lengh res list1)))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*List.lengh res list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res (mulByDigit (x * (List.lengh res)) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: Unbound value List.lengh\nHint: Did you mean length?\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 97-107:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\n                                                      ^^^^^^^^^^\nError: Unbound value List.lengh\nHint: Did you mean length?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res (mulByDigit (x * (List.length res)) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*10) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) -> (list1, (bigAdd res (mulByDigit (x * 10) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*int_of_float (10.**List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             ((mulByDigit x) *\n                (int_of_float (10. ** (List.length res)) list1)))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*int_of_float (10.**List.length res) list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*(int_of_float (10.**List.length res)) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             ((mulByDigit x) *\n                ((int_of_float (10. ** (List.length res))) list1)))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*(int_of_float (10.**List.length res)) list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit (x * (int_of_float (10. ** (List.length res))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 117-132:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\n                                                                          ^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit\n                (x * (int_of_float (10. ** (float_of_int List.length res))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 117-129:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\n                                                                          ^^^^^^^^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit\n                (x * (int_of_float (10. ** (float_of_int (List.length res)))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*power_10 (List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res ((mulByDigit x) * (power_10 (List.length res) list1)))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*power_10 (List.length res) list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) list1)) in\nlet base = (List.length l2,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) list1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: Unbound value list1\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 139-144:\n  | (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) list1)) in\n                                                                                                ^^^^^\nError: Unbound value list1\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) l1)) in\nlet base = (List.length l2,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) l1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
