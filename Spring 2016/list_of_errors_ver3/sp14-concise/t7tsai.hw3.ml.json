{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in \nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 34-43:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ;;\n                               ^^^^^^^^^\nError: Unbound value sepConcat\n", "min": "\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l));;\n", "in": "\r\n(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*)\n\r\nlet _ = stringOfList str"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = pipe [] 3;;\n          ^^^^\nError: Unbound value pipe\n", "min": "\nlet _ = pipe [] 3;;\n", "in": "\n\r\nlet _ = pipe [(fun x -> x+x);"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n          ^^^^\nError: Unbound value pipe\n", "min": "\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "in": "\n\r\nlet _ = pipe [(fun x -> x+x);"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n          ^^^^\nError: Unbound value pipe\n", "min": "\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "in": "let pipe fs =  \nlet f a x = x a in\nlet b"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 33-37:\n  let f a x = x base in\n                ^^^^\nError: Unbound value base\n", "min": "\nlet pipe fs = let f a x = x base in le;;\n", "in": "\n\r\nlet pipe fs =  \nlet f a x = x' (x a)  in"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n          ^^^^\nError: Unbound value pipe\n", "min": "\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "in": "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l ="}, {"type": "", "out": "", "min": "", "in": "\r\nlet _ = sepConcat \", \" ["}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = if n > 0 then x :: clone x ("}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "\r\n\n\r\nlet padZero l1 l2 = if Lis"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "\r\n\n\r\nlet padZero l1 l2 = if Lis"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 9-16:\n  let _ = padZero [9;9] [1;0;0;2]\n          ^^^^^^^\nError: Unbound value padZero\n", "min": "\nlet _ = padZero [9; 9] [1; 0; 0; 2] let _ = padZero [1; 0; 0; 2] [9; 9];;\n", "in": "\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t\nelse h :: removeZero t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then t\nelse  removeZero t\n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t\n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in \nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "\r\nlet _ = pipe [] 3\n\r\nlet _ ="}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 9-13:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)];;\n          ^^^^\nError: Unbound value pipe\n", "min": "\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)];;\n", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\n(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n*)\n\n\n\n\n\n*******************************************************************************"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs =  \nlet f a x = x a  in\nfun base -> \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with \n| [] -> []\n| h::t -> bigAdd [h1*i] (mulByDigit i t1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse \nif i = 1 then l\nelse \nif i = 2 then bigAdd l l\nelse \nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit i-2 l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-110:\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit i-2 l);;\n                                    ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else bigAdd (mulByDigit (i - 2) l) ((mulByDigit i) - (2 l));;\n", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let x = bigAdd [9;9;9;9] [9;9;9;9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let y = bigAdd x x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let z = bigAdd y x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let t = bigAdd x z"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let r = bigAdd t x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let e = bigAdd r x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let t = bigAdd x z"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let d = bigAdd t x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let y = bigAdd x x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let z = bigAdd y x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let t = bigAdd x z"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let d = bigAdd t x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let 1 = bigAdd x x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 15-16:\n  let 5 = bigAdd 4 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 5 = bigAdd 4 x;;\n", "in": "let y = bigAdd x x"}, {"type": "", "out": "", "min": "", "in": "let z = bigAdd y x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let d = bigAdd c x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let e = bigAdd e x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let e = bigAdd d x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f = bigAdd e x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g = bigAdd f x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let h = bigAdd g x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f = bigAdd e x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (mulByDigit x list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x*10 list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\n                                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*(10**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float float_of_int x*.(10.**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x*.(10.**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x)*.(10.**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*.10.**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*(10 exp List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 86-88:\n  | (list1, res) -> (list1, mulByDigit (x*(10 exp List.length res)) list1) in\n                                           ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 exp List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 ** List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10 ** List.length res) list1) in\n                                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 int_of_float ** List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 122-134:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n                                                                               ^^^^^^^^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             (int_of_float\n                ((float_of_int x) *. (10. ** (float_of_int List.length res))))\n             list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit ((int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-112:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             ((int_of_float (float_of_int x)) *.\n                (10. ** (float_of_int List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-112:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             ((int_of_float (float_of_int x)) *.\n                (10. ** (float_of_int (List.length res)))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*List.lengh res list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*List.lengh res list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res ((mulByDigit x) * (List.lengh res list1)))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value List.lengh\nHint: Did you mean length?\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 97-107:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\n                                                      ^^^^^^^^^^\nError: Unbound value List.lengh\nHint: Did you mean length?\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res (mulByDigit (x * (List.lengh res)) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*10) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*int_of_float (10.**List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*(int_of_float (10.**List.length res)) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*(int_of_float (10.**List.length res)) list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             ((mulByDigit x) *\n                ((int_of_float (10. ** (List.length res))) list1)))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 117-132:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\n                                                                          ^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit (x * (int_of_float (10. ** (List.length res))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 117-129:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\n                                                                          ^^^^^^^^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit\n                (x * (int_of_float (10. ** (float_of_int List.length res))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*power_10 (List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) list1)) in\nlet base = (List.length l2,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) l1)) in\nlet base = (List.length l2,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
