{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,(n,v)::t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (n,v)::t -> if n = k then v else assoc (d, k, ((n, v) :: t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if List.mem h t then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = failwith \"to be written\"", "min": "\nlet rec wwhile (f,b) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x in (xx, xx < 1000) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = x * x in (xx, (xx < 1000)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x in (xx, xx < 100000) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = x * x in (xx, (xx < 100000)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let f x = let xx = x*x in (xx, xx < 100000) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = x * x in (xx, (xx < 100000)) in wwhile (f, 2);;\n", "out": "Characters 47-53:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( let fb  = f b in\n(fb,fb=b) ,b)", "min": "\nlet fixpoint (f,b) = wwhile (let fb = f b in ((fb, (fb = b)), b));;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( let fb  = f b in\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((  let fb  = f b in\n(fb,fb=b)) ,b)", "min": "\nlet fixpoint (f,b) = wwhile ((let fb = f b in (fb, (fb = b))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((  let fb  = f b in\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in \n(fb,fb=b) in f b) ,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let w b = let fb = f b in (fb, (fb = b)) in f b), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in \n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b) ,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b') ,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b'), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b) ,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = let w b' = let fb  = f b' in \n(fb,fb=b') in  wwhile ( w ,b)", "min": "\nlet fixpoint (f,b) =\n  let w b' = let fb = f b' in (fb, (fb = b')) in wwhile (w, b);;\n", "out": "Characters 66-72:\n  (fb,fb=b') in  wwhile ( w ,b);;\n                 ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n(fb,fb=b') in  w ,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let w b' = let fb = f b' in (fb, (fb = b')) in (w, b));;\n", "out": "Characters 22-28:\n  let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n                        ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n(fb,fb<>b') in  w ,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let w b' = let fb = f b' in (fb, (fb <> b')) in (w, b));;\n", "out": "Characters 22-28:\n  let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n                        ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString y ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString y) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi* eval (a,x,y) )\n| Cosine a         -> cos(pi* eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) + eval (b,x,y))/2)\n| Times (a,b)      -> eval (a,x,y) * eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 125-127:\n  | Sine a           -> sin(pi* eval (a,x,y) )\n                            ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) + eval (b,x,y))/2)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 216-228:\n  | Average (a,b)    -> (( eval (a,x,y) + eval (b,x,y))/2)\n                           ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/2)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 214-245:\n  | Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/2)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 247-248:\n  | Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2)\n                                                          ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = buildThresh(a,b,a_less,b_less) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| 5 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand 1 2 in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = buildThresh (a, b, a_less, b_less) in\n     match rand 1 5 with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": "Characters 129-130:\n  let b = buildThresh(a,b,a_less,b_less) in \n                      ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| 5 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand 1 2 in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand 1 5 with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand 1 2 in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand 1 5 with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 5) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 5) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 5) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| 5 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 5) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,1) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 5) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,6) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 6) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,6) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 6) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 5) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,6) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 6) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 6) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,6) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 6) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (1, 6) with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,1) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,5) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 5) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,5) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 5) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,5) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 5) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 5) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,4) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 4) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": "Characters 83-89:\n  buildX()\n  ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Sigmoid  of expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1.- exp (-1*.a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. - (exp ((-1) *. a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 208-210:\n  | Sigmoid a        -> 1./.(1.- exp (-1*.a))\n                             ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1.- exp (-1*.a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. - (exp ((-1) *. a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 208-210:\n  | Sigmoid a        -> 1./.(1.- exp (-1*.a))\n                             ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-1*.a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1) *. a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 219-221:\n  | Sigmoid a        -> 1./.(1. -. exp (-1*.a))\n                                        ^^\nError: This expression has type int but an expression was expected of type\n         float\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp (- a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 220-221:\n  | Sigmoid a        -> 1./.(1. -. exp (-a))\n                                         ^\nError: This expression has type expr but an expression was expected of type\n         int\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp (- (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 220-232:\n  | Sigmoid a        -> 1./.(1. -. exp (-eval (a,x,y)))\n                                         ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 6) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Sigmoid x -> \"sigmoid(\" ^ ((exprToString x) ^ \")\")\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Sigmoid  of expr \n| Tanh     of expr * expr * expr", "min": "\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Sigmoid x        -> \"sigmoid(\" ^ exprToString x ^ \")\"\n| Tanh (x,y,z)     -> \"tanh(pi*(\" ^ exprToString x ^\"+\" ^ exprToString y ^\n\")/\"^ exprToString z \")\"\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "min": "\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Sigmoid x        -> \"sigmoid(\" ^ exprToString x ^ \")\"\n| Tanh (x,y,z)     -> \"tanh(pi*(\" ^ exprToString x ^\"+\" ^ exprToString y ^\n\")/\"^ exprToString z ^ \")\"\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "min": "\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(pi*.( eval (a,x,y) +. eval (b,x,y))/.(eval (c,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y)))", "min": "\nlet _ = tanh ((-0.5) +. 0.9);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Sigmoid x        -> \"sigmoid(\" ^ exprToString x ^ \")\"\n| Tanh (x,y,z)     -> \"tanh((\" ^ exprToString x ^\"+\" ^ exprToString y ^\n\")/(1+\"^ exprToString z ^ \"))\"\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "min": "\nlet timeout = 300;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y))/.(0.1.+.eval (c,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\nlet max = ref 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y))/.(0.1+.eval (c,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\nlet score = ref 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y))/.(1.01+.eval (c,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "min": "\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Sigmoid x        -> \"sigmoid(\" ^ exprToString x ^ \")\"\n| Tanh (x,y,z)     -> \"tanh((\" ^ exprToString x ^\"+\" ^ exprToString y ^\n\")/(1.01+\"^ exprToString z ^ \"))\"\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "min": "\nexception ErrorCode of string;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,6) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 9 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet prefix130 = \"130\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,6) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 9 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet key = \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\ntype test = unit -> string;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Tanh (a,b,c) ->\n      tanh\n        (((eval (a, x, y)) +. (eval (b, x, y))) /. (1.01 +. (eval (c, x, y))))\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTanh (e1,e2,e3) = Tanh (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 7) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | 5 ->\n         buildTanh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Sigmoid x -> \"sigmoid(\" ^ ((exprToString x) ^ \")\")\n  | Tanh (x,y,z) ->\n      \"tanh((\" ^\n        ((exprToString x) ^\n           (\"+\" ^\n              ((exprToString y) ^ (\")/(1.01+\" ^ ((exprToString z) ^ \"))\")))))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet score = ref 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet score = ref 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet timeout = 300;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet timeout = 300;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet timeout = 300;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet max = ref 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet timeout = 300;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet max = ref 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet max = ref 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h::seen \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Tanh (a,b,c) ->\n      tanh\n        (((eval (a, x, y)) +. (eval (b, x, y))) /. (1.01 +. (eval (c, x, y))))\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTanh (e1,e2,e3) = Tanh (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 7) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | 5 ->\n         buildTanh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Sigmoid x -> \"sigmoid(\" ^ ((exprToString x) ^ \")\")\n  | Tanh (x,y,z) ->\n      \"tanh((\" ^\n        ((exprToString x) ^\n           (\"+\" ^\n              ((exprToString y) ^ (\")/(1.01+\" ^ ((exprToString z) ^ \"))\")))))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  Printf.printf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  Printf.printf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  Printf.printf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  Printf.printf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  Printf.printf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  \nPrintf.printf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)  (exprToString y) (exprToString z)\n| Thresh (x,y,z,w) ->  \nPrintf.printf \"(%s<%s?%s:%s)\" (exprToString x)  (exprToString y) (exprToString z)  (exprToString w)", "min": "\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  sprintf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  \nsprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)  (exprToString y) (exprToString z)\n| Thresh (x,y,z,w) ->  \nsprintf \"(%s<%s?%s:%s)\" (exprToString x)  (exprToString y) (exprToString z)  (exprToString w)", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  \nPrintf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)  (exprToString y) (exprToString z)\n| Thresh (x,y,z,w) ->  \nPrintf.sprintf \"(%s<%s?%s:%s)\" (exprToString x)  (exprToString y) (exprToString z)  (exprToString w)", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  \nPrintf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)  (exprToString y)\n(exprToString z)\n| Thresh (x,y,z,w) ->  \nPrintf.sprintf \"(%s<%s?%s:%s)\" (exprToString x)  (exprToString y) (exprToString z)  (exprToString w)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile (let w b' = let fb = f b' in (fb, (fb <> b')) in (w, b));;\n\nlet _ = fixpoint (collatz, 48);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  Printf.sprintf \"tanh((%s+%s)/(1.01+%s))\" \n(exprToString x)  (exprToString y) (exprToString z)\n| Thresh (x,y,z,w) ->  Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) \n(exprToString y) (exprToString z)  (exprToString w)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Tanh (a,b,c) ->\n      tanh\n        (((eval (a, x, y)) +. (eval (b, x, y))) /. (1.01 +. (eval (c, x, y))))\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTanh (e1,e2,e3) = Tanh (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 7) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | 5 ->\n         buildTanh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Sigmoid x -> Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n  | Tanh (x,y,z) ->\n      Printf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)\n        (exprToString y) (exprToString z)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Tanh (a,b,c) ->\n      tanh\n        (((eval (a, x, y)) +. (eval (b, x, y))) /. (1.01 +. (eval (c, x, y))))\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTanh (e1,e2,e3) = Tanh (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 7) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | 5 ->\n         buildTanh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Sigmoid x -> Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n  | Tanh (x,y,z) ->\n      Printf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)\n        (exprToString y) (exprToString z)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Tanh (a,b,c) ->\n      tanh\n        (((eval (a, x, y)) +. (eval (b, x, y))) /. (1.01 +. (eval (c, x, y))))\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTanh (e1,e2,e3) = Tanh (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 7) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | 5 ->\n         buildTanh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Sigmoid x -> Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n  | Tanh (x,y,z) ->\n      Printf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)\n        (exprToString y) (exprToString z)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Tanh (a,b,c) ->\n      tanh\n        (((eval (a, x, y)) +. (eval (b, x, y))) /. (1.01 +. (eval (c, x, y))))\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTanh (e1,e2,e3) = Tanh (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 7) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | 5 ->\n         buildTanh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Sigmoid x -> Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n  | Tanh (x,y,z) ->\n      Printf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)\n        (exprToString y) (exprToString z)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Tanh (a,b,c) ->\n      tanh\n        (((eval (a, x, y)) +. (eval (b, x, y))) /. (1.01 +. (eval (c, x, y))))\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTanh (e1,e2,e3) = Tanh (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 7) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | 5 ->\n         buildTanh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Sigmoid x -> Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n  | Tanh (x,y,z) ->\n      Printf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)\n        (exprToString y) (exprToString z)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. +. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Tanh (a,b,c) ->\n      tanh\n        (((eval (a, x, y)) +. (eval (b, x, y))) /. (1.01 +. (eval (c, x, y))))\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr\n  | Tanh of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSigmoid e = Sigmoid e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTanh (e1,e2,e3) = Tanh (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand (0, 7) with\n     | 0 -> buildSine b\n     | 1 -> buildCosine b\n     | 2 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 4 -> buildSigmoid b\n     | 5 ->\n         buildTanh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Sigmoid x -> Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n  | Tanh (x,y,z) ->\n      Printf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)\n        (exprToString y) (exprToString z)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
