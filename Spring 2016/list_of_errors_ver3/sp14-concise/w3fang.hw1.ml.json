{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n|[]->0\n|x :: xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n = if n <= 0 then [] else explode (string_of_int n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n = if n <= 0 then [] else explode (string_of_int n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n<=0 then []\nelse int_of_char explode (string_of_int n)", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else int_of_char explode (string_of_int n);;\n", "out": "Characters 46-57:\n  else int_of_char explode (string_of_int n);;\n       ^^^^^^^^^^^\nError: This function has type char -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n|[]->0\n|x :: xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = sumList digitOfInt n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList digitOfInt n;;\n", "out": "Characters 32-39:\n  let rec additivePersistence n = sumList digitOfInt n;;\n                                  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \n\nsumList (digitOfInt n)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList (digitOfInt n);;\n", "out": "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 43-53:\n  sumList (digitOfInt n);;\n           ^^^^^^^^^^\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \n\nsumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nif n<10 then n\nelse  n=sumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then n else n = (sumList (digitsOfInt n));;\n", "out": "Characters 54-79:\n  else  n=sumList (digitsOfInt n);;\n        ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nif n<10 then n\nelse  n=sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    if n < 10 then n else n = (sumList (digitsOfInt n)) in\n  match n with | 0 -> 0 | _ -> n;;\n", "out": "Characters 54-79:\n  else  n=sumList (digitsOfInt n) in \n        ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nif n<10 then n\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    if n < 10 then n else sumList (digitsOfInt n) in\n  match n with | 0 -> 0 | _ -> n;;\n", "out": "Characters 88-89:\n  match n with \n        ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n a= \nif n<10 then a\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n a =\n    if n < 10 then a else sumList (digitsOfInt n) in\n  match n with | 0 -> 0 | _ -> n;;\n", "out": "Characters 89-90:\n  match n with \n        ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))", "min": "\nlet a = int_of_char '3';;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then a else additivePersistence (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n<10 then n\nelse  additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then n else additivePersistence (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n<10 then n\nelse  digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n<10 then n\nelse  digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet c=0 in\nlet rec break(num,count)=\nif num>9 then\nbreak(sumList(digitsOfInt(num)),(count+1))\nelse\ncount\nin\nbreak(n,c)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let c = 0 in\n  let rec break (num,count) =\n    if num > 9\n    then break ((sumList (digitsOfInt num)), (count + 1))\n    else count in\n  break (n, c);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n<=0 then[]\nelse let rec loop n a =\nif n=0 then a\nelse loop(n/10)(n mod 10::a)in\nmatch n with\n|0->[0]\n|_->loop n[]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] list", "min": "\nlet rec listReverse l =\n  let rec a acc = function | [] -> acc | h::t -> a (h :: acc) t in a [] list;;\n", "out": "Characters 87-91:\n  a [] list;;\n       ^^^^\nError: Unbound value list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] l", "min": "\nlet rec listReverse l =\n  let rec a acc = function | [] -> acc | h::t -> a (h :: acc) t in a [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec a acc = function | [] -> acc | h::t -> a (h :: acc) t in a [] l;;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "out": ""}]}
