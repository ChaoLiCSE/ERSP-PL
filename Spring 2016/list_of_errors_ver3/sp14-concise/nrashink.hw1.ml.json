{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 52-60:\n  n mod 10;;\n  ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else n mod 10;;\n", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-60:\n  n mod 10\n        ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod (10 n)];;\n", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10\nn::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-80:\n  (n mod 10) :: [digitsOfInt n];;\n                 ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10; digitsOfInt n];;\n", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: [digitsOfInt n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-79:\n  (n mod 10) :: digitsOfInt n :: [];;\n                ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10; digitsOfInt n];;\n", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: digitsOfInt n :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-79:\n  n mod 10 @myList;;\n  ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) @ myList;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 @myList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-64:\n  then [];;\n       ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-64:\n  then [];;\n       ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-77:\n  n mod 10 :: myList;;\n           ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then ([] mod 10) :: myList;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\n\nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-64:\n  then [];;\n       ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-64:\n  then [];;\n       ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-63:\n  if (n <= 0) then [];;\n                   ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-76:\n  n mod 10 :: myList;;\n           ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then ([] mod 10) :: myList;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\n\nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-63:\n  if (n <= 0) then [];;\n                   ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-87:\n  n mod 10 :: myList\n              ^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else (n mod 10) :: ((myList n) mod 100) :: myList;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList\nn mod 100 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\n(n mod 10 :: myList) :: digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-87:\n  n = n - (n mod 10);\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else n = (n - (n mod 10)); (n :: myList) :: digitsOfInt;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn = n - (n mod 10);\n(n :: myList) :: digitsOfInt"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-106:\n  (n mod 10 :: myList) :: digitsOfInt\n                          ^^^^^^^^^^^\nError: This expression has type int -> int list list\n       but an expression was expected of type int list list\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-105:\n  (n mod 10 :: myList) :: digitsOfInt;;\n                          ^^^^^^^^^^^\nError: This expression has type int -> int list list\n       but an expression was expected of type int list list\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - (n mod 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n / 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-53:\n  rev (n mod 10 :: digitsOfInt (n / 10));;\n  ^^^\nError: Unbound value rev\nHint: Did you mean ref?\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else rev ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nrev (n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-71:\n  (n mod 10 :: List.rev digitsOfInt (n / 10));;\n               ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 50-84:\n  (n mod 10 :: digitsOfInt (n / 10))\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((n mod 10) :: (digitsOfInt (n / 10))) List.rev;;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))\nList.rev"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev(n mod 10 :: digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-71:\n  (n mod 10 :: List.rev digitsOfInt (n / 10));;\n               ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-72:\n  (n mod 10 :: (List.rev digitsOfInt (n / 10)));;\n                ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: (List.rev digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev (digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: List.rev (digitsOfInt (n / 10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \ndigitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n(digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| (h::t) -> 1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-87:\n  | (h::t) -> h + t;;\n                  ^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | h::t -> h + t;;\n", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| (h::t) -> h + t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-84:\n  | _ -> sumList digitsOfInt n;;\n         ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-85:\n  | _ -> sumList digitsOfInt n;;\n         ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0;\n| _ -> sumList digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-84:\n  | _ -> sumList digitsOfInt n;;;\n         ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n;"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (sumList (digitsOfInt n) > 9) then digitalRoot (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-108:\n  count = count + 1;;\n  ^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = 1 in if (sumList (digitsOfInt n)) > 9 then count = (count + 1);;\n", "in": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount = count + 1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-95:\n  1::count\n   ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "in": "let rec additivePersistence n = \nlet count = [] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-96:\n  1::count\n   ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-101:\n  1::count\n     ^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-101:\n  1::count\n     ^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-101:\n  1::count\n     ^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen (\n1::count\nadditivePersistence (sumList (digitsOfInt n)))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 106-119:\n  else sumList count;;\n       ^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9 then 1 :: count else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-95:\n  1::count & additivePersistence (sumList (digitsOfInt n))\n   ^^\nError: This variant expression is expected to have type bool\n       The constructor :: does not belong to type bool\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) & (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count & additivePersistence (sumList (digitsOfInt n))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-95:\n  1::count && additivePersistence (sumList (digitsOfInt n))\n   ^^\nError: This variant expression is expected to have type bool\n       The constructor :: does not belong to type bool\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) && (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count && additivePersistence (sumList (digitsOfInt n))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 101-104:\n  1::count &&& additivePersistence (sumList (digitsOfInt n))\n           ^^^\nError: Unbound value &&&\nHint: Did you mean &&?\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) &&& (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count &&& additivePersistence (sumList (digitsOfInt n))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 90-91:\n  x + 1\n      ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then x + (1 additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nx + 1\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 152-157:\n  else sumList count;;\n               ^^^^^\nError: Unbound value count\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = 1 in x + 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-96:\n  1::x\n     ^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (x additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1 :: x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nsumList x\nend\nelse sumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1::x;\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [1] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1::x;\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [1] in\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [1] in\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 33-34:\n  1@x;\n  ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  1 @ x;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n", "in": "let rec additivePersistence n = \n1@x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::[2];\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \n-1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \n-23"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \n1::x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 147-156:\n  sumList x;;;\n  ^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else 1 :: x;\n  sumList x;;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n1::x;\nsumList x;"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [1;2];\nend"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 162-163:\n  sumList [x];\n           ^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList [x]);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [x];\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = failwith \"TBD\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nexplode l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse \"nikhil\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 25-32:\n  explode l\n  ^^^^^^^\nError: This function has type string -> char list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = explode l listReverse \"nikhil\";;\n", "in": "let rec listReverse l = \nexplode l\n\nlistReverse \"nikhil\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse \"nikhil\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nexplode l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n[] -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> [1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse [\"a\";\"b\";\"c\"]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse [\"a\";\"b\";\"c\"]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse [\"a\"; \"b\"; \"c\"]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-76:\n  |(h::t) -> h::(listReverse t);;\n             ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1 -> [h1] | h::t -> h :: (listReverse t);;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h1) -> h1::[]\n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse [\"a\"; \"b\"; \"c\"]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-76:\n  |(h::t) -> t::(listReverse t);;\n             ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1::[] -> [h1] | h::t -> t :: (listReverse t);;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> t::(listReverse t)"}, {"type": "", "out": "", "min": "", "in": "listReverse [\"a\"; \"b\"; \"c\"]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse [\"a\"; \"b\"; \"c\"]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|_ -> []\n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-74:\n  |(h::t) -> (listReverse t)::h;;\n             ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> (listReverse t)::h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-58:\n  |(h::t)::t -> [];;\n           ^\nError: Variable t is bound several times in this matching\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | (h::t)::t -> [];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t)::t -> []"}, {"type": "", "out": "", "min": "", "in": "listReverse [\"a\";\"b\"]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  |(h::(h::t)) -> [];;\n        ^\nError: Variable h is bound several times in this matching\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::h::t -> [];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::(h::t)) -> []"}, {"type": "", "out": "", "min": "", "in": "listReverse [\"a\";\"b\"]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse [\"a\";\"b\"]"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  |[] -> h::[]\n         ^\nError: Unbound value h\n", "min": "\nlet rec listReverse l = match l with | [] -> [h] | h::t -> listReverse t;;\n", "in": "let rec listReverse l = match l with \n|[] -> h::[]\n|(h::t) -> listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 79-80:\n  |_ -> h::[];;\n        ^\nError: Unbound value h\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse t | _ -> [h];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t\n|_ -> h::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-70:\n  |(h::t) -> listReverse t\n             ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t h];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t\nh::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-74:\n  |(h::t) -> (listReverse t)\n             ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [(listReverse t) h];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> (listReverse t)\nh::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> begin\n(listReverse t);\nh::[]\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "listReverse [\"a\";\"b\"]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = failwith \"TBD\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"hi\";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-91:\n  print_string \"going into then\" print_newline();\n  ^^^^^^^^^^^^\nError: This function has type string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\" print_newline ();\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\" print_newline();\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-109:\n  print_string \"going into then\" /print_newline();\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    ((print_string \"going into then\") / (print_newline ());\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\" /print_newline();\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 181-193:\n  print_String \"going into else\";\n  ^^^^^^^^^^^^\nError: Unbound value print_String\nHint: Did you mean print_string?\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\";\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_String \"going into else\"; 1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_String \"going into else\";\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 116-121:\n  x.print;\n    ^^^^^\nError: Unbound record field print\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     x.print;\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\nx.print;\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 114-124:\n  List.print x;\n  ^^^^^^^^^^\nError: Unbound value List.print\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     List.print x;\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\nList.print x;\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 114-124:\n  print_list x\n  ^^^^^^^^^^\nError: Unbound value print_list\nHint: Did you mean print_int?\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     print_list x (1 :: x);\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\nprint_list x\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [] in \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = [] in \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 41-42:\n  let x = x + 1 in\n          ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  let x = x + 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; sumList x);;\n", "in": "let rec additivePersistence n = \nlet x = x + 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 41-42:\n  let x = x + 1 in\n          ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  let x = x + 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; x);;\n", "in": "let rec additivePersistence n = \nlet x = x + 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nx\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 234-235:\n  sumList x\n          ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; sumList x);;\n", "in": "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (sumList (digitsOfInt n) > 9) then digitalRoot (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nList.rev l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-49:\n  if (explode w = listReverse w) then true\n                              ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = List.rev l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "in": "let palindrome w = \nif (explode w = listReverse w) then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet explosion = explode w in\nif (explosion = listReverse explosion) then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = failwith \"TBD\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = failwith \"TBD\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (sumList (digitsOfInt n) > 9) then digitalRoot (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 28-33:\n  count;;\n  ^^^^^\nError: Unbound value count\n", "min": "\nlet additivePersistence n = count;;\n", "in": "let additivePersistence n =\ncount"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = n + 1"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-39:\n  let additivePersistence n a = n + a + b;;\n                                        ^\nError: Unbound value b\n", "min": "\nlet additivePersistence n a = (n + a) + b;;\n", "in": "let additivePersistence n a = n + a + b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n a = n + a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-122:\n  then additivePersistence (sumList (digitsOfInt n)) (a + 1);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec listReverse l = List.rev l;;\n\nlet additivePersistence n a = n + a;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet additivePersistence n a =\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n)) (a + 1);;\n", "in": "let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse 9"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec apCalc n a = \nif (sumList (digitsOfInt n) > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = apCalc n 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec apCalc n a = \nif (sumList (digitsOfInt n) > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = apCalc n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec apCalc n a = \nif (sumList (digitsOfInt n) > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec apCalc n a = \nif (n > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = apCalc n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec apCalc n a = \nif (n > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-97:\n  | (h::t) -> myListReverse t h::newList;;\n              ^^^^^^^^^^^^^\nError: Unbound value myListReverse\nHint: Did you mean mylistReverse?\n", "min": "\nlet rec mylistReverse origList newList =\n  match origList with | [] -> [] | h::t -> (myListReverse t h) :: newList;;\n", "in": "let rec mylistReverse origList newList = match origList with\n| [] -> []\n| (h::t) -> myListReverse t h::newList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = myListReverse l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1"}]}
