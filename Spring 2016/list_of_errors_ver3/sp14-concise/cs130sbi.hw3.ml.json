{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match x with\n|[] -> a\n|h::t -> h*h\nin\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> h * h in\n  let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x\nin\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a\nin\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 1 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 1 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x(a) in\nlet base = f 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x(a) in\nlet base = f in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x(a) in\nlet base = [] in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 46-47:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a -> 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base a = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a s-> a*s in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = x a in let base a s = a * s in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a-> a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a-> a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y-> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y-> 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base y = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = fun a -> a in\nList.fold_left f base fs", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a in\nlet base = fun a -> a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = a in let base a = a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a x -> x a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = x a in let base a x = x a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a-> f a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base a = f a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = fun a-> f a in\nList.fold_left f base fs", "out": "Characters 75-76:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base a = f a in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun z -> a (x z) in\nlet base = fun a-> f a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x z = a (x z) in let base a = f a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun z -> a (x z) in\nlet base = fun a-> a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x z = a (x z) in let base a = a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun a-> a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x z = x (a z) in let base a = a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun a -> a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x z = x (a z) in let base a = a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  \"\" in\nlet l =  h in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  f in\nList.fold_left f base l", "out": "Characters 154-155:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string -> string -> string\n       but an expression was expected of type string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = f in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = h in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = h in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l", "out": "Characters 155-156:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = \"\" in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep t in let l = h in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l", "out": "Characters 152-153:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep t in let l = \"\" in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep [] in\nlet l =  \"\" in\nList.fold_left f base l", "out": "Characters 153-154:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep [] in let l = \"\" in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  \"\" in\nlet l =  \"\" in\nList.fold_left f base l", "out": "Characters 139-140:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = h in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ sep in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  sepConcat sep t in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = sepConcat sep t in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  \"\" in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep^a in\nlet base =  \"\" in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t then \"\" else \"a\" in\nlet l =  sl in\nList.fold_left f base l", "out": "Characters 104-105:\n  let base =  if t then \"\" else \"a\" in\n                 ^\nError: This expression has type 'a list\n       but an expression was expected of type bool\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t then \"\" else \"a\" in\n      let l = sl in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else \"\" in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t = [] then \"A\" else \"\" in\n      let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else t in\nlet l =  sl in\nList.fold_left f base l", "out": "Characters 123-124:\n  let base =  if t=[] then \"A\" else t in\n                                    ^\nError: This expression has type 'a list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t = [] then \"A\" else t in\n      let l = sl in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t = [] then \"A\" else h in\n      let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep^x in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = if t = [] then \"A\" else h in\n      let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = if t = [] then \"A\" else h in\n      let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=sep then sep else h^sep in\nlet l =  sl in\nList.fold_left f base l", "out": "Characters 122-125:\n  let base =  if t=sep then sep else h^sep in\n                                       ^^^\nError: This expression has type string list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h ^ sep in\n      let l = sl in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=sep then sep else h in\nlet l =  sl in\nList.fold_left f base l", "out": "Characters 120-121:\n  let base =  if t=sep then sep else h in\n                                     ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=\"\" then sep else h in\nlet l =  sl in\nList.fold_left f base l", "out": "Characters 102-104:\n  let base =  if t=\"\" then sep else h in\n                   ^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = \"\" then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=[] then sep else h in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=[] then sep else h^sep in\nlet l =  sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h ^ sep in\n      let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  \"\"  in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h  in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map sepConcat f l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map sepConcat f l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map sepConcat f l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map sepConcat l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map sepConcat l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map sepConcat l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (sepConcat \"\") l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (sepConcat \"\") l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \"\") l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (sepConcat \" \") l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (sepConcat \" \") l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \" \") l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (sepConcat \" \") (l)", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (sepConcat \" \") (l);;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \" \") l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map ~ l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map ~ l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map ~l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (fun x-> sepConcat \"\" x) l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (fun x-> sepConcat \"\" x) l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (fun x  -> sepConcat \"\" x) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (fun x-> x^x) l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (fun x-> x^x) l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map (fun x  -> x ^ x) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (fun x-> x) l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (fun x-> x) l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map (fun x  -> x) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (fun x-> \"\") l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (fun x-> \"\") l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (fun x-> \"\") l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (fun x-> \"\") l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (fun x-> \"\") l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (fun x-> \"\") l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map (fun x-> x) (l)", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map (fun x-> x) (l);;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map (fun x  -> x) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith List.map asd l", "out": "Characters 32-40:\n  let stringOfList f l = failwith List.map asd l;;\n                                  ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = failwith List.map asd l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map asd l", "out": "Error: Unbound value asd\nHint: Did you mean asd_ or asr?\nError: Unbound value asd\nHint: Did you mean asr?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 32-35:\n  let stringOfList f l = List.map asd l;;\n                                  ^^^\nError: Unbound value asd\nHint: Did you mean asd_ or asr?\n", "min": "\nlet stringOfList f l = List.map asd l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (sepConcat \"\") l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\") l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (sepConcat \" \") l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \" \") l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (sepConcat \" \") l.string", "out": "Characters 50-56:\n  let stringOfList f l = List.map (sepConcat \" \") l.string;;\n                                                    ^^^^^^\nError: Unbound record field string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \" \") l.string;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (sepConcat \"\") l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\") l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (fun x-> sepConcat x []) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun x  -> sepConcat x []) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (fun x-> sepConcat x.string []) l", "out": "Characters 53-59:\n  let stringOfList f l = List.map (fun x-> sepConcat x.string []) l;;\n                                                       ^^^^^^\nError: Unbound record field string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun x  -> sepConcat x.string []) l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (fun x->x) l", "out": "", "min": "\nlet stringOfList f l = List.map (fun x  -> x) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (fun x-> Printf.sprintf \"%s\" x) l", "out": "", "min": "\nlet stringOfList f l = List.map (fun x  -> Printf.sprintf \"%s\" x) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (fun x-> Printf.sprintf \"%d\" x) l", "out": "", "min": "\nlet stringOfList f l = List.map (fun x  -> Printf.sprintf \"%d\" x) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (sepConcat f) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (f) l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet acc = [] in\nif x=0\nthen acc\nelse acc::clone x n-1", "out": "Characters 62-71:\n  else acc::clone x n-1;;\n            ^^^^^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let acc = [] in if x = 0 then acc else acc :: ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1", "out": "Characters 57-64:\n  else clone x::acc n-1;;\n       ^^^^^^^\nError: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n", "min": "\nlet rec clone x n =\n  let acc = [] in if n = 0 then acc else (clone x) :: ((acc n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1", "out": "Characters 57-64:\n  else clone x::acc n-1;;\n       ^^^^^^^\nError: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n", "min": "\nlet rec clone x n =\n  let acc = [] in if n = 0 then acc else (clone x) :: ((acc n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1", "out": "Characters 56-65:\n  else clone x n-1;;\n       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else (clone x n) - 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x ne", "out": "Characters 64-66:\n  else clone x ne;;\n               ^^\nError: Unbound value ne\n", "min": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x ne;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n", "out": "", "min": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1", "out": "Characters 56-65:\n  else clone x n-1;;\n       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else (clone x n) - 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x (n-1)", "out": "", "min": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x (n - 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x::accum (n-1)", "out": "Characters 56-63:\n  else clone x::accum (n-1);;\n       ^^^^^^^\nError: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n", "min": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else (clone x) :: (accum (n - 1));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone (x::accum) (n-1)", "out": "Characters 63-64:\n  else clone (x::accum) (n-1);;\n              ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else clone (x :: accum) (n - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone (x::accum) (n-1)", "out": "Characters 63-64:\n  else clone (x::accum) (n-1);;\n              ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else clone (x :: accum) (n - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nlet helper x n =\nif n<1\nthen accum\nelse (x::accum) in\nhelper x (n-1)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let helper x n = if n < 1 then accum else x :: accum in helper x (n - 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nlet helper accum n=\nif n<1\nthen accum\nelse (x::accum) in\nhelper accum (n-1)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let helper accum n = if n < 1 then accum else x :: accum in\n  helper accum (n - 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nlet rec helper accum n=\nif n<1\nthen accum\nelse (x::accum) in\nhelper accum (n-1)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n = if n < 1 then accum else x :: accum in\n  helper accum (n - 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nlet rec helper accum n=\nif n<1\nthen accum\nelse helper (x::accum)(n-1) in\nhelper accum n", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = match (l1,l2) with\n| ([],[]) -> []", "out": "", "min": "\nlet padZero l1 l2 = match (l1, l2) with | ([],[]) -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = (l1,l2)", "out": "", "min": "\nlet padZero l1 l2 = (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = ((clone 0 2)::l1,l2)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 = (((clone 0 2) :: l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = ((clone (clone 0 1)::l1 2),l2)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 = (((clone (clone 0 1)) :: (l1 2)), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = ((clone 0::l1 2),l2)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 = (((clone 0) :: (l1 2)), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1 else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen ((List.append (clone 0 (b-a)) l1),l2)\nelse if(b<a)\nthen (l1,(List.append (clone 0 (a-b)) l2))", "out": "Characters 134-171:\n  then (l1,(List.append (clone 0 (a-b)) l2));;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "out": "Characters 129-161:\n  then (List.append (clone 0 (a-b)) l2);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "out": "Characters 129-161:\n  then (List.append (clone 0 (a-b)) l2);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen List.append (clone 0 (a-b)) l2", "out": "Characters 129-159:\n  then List.append (clone 0 (a-b)) l2;;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)", "out": "Characters 78-110:\n  then (List.append (clone 0 (b-a)) l1);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1", "out": "Characters 78-108:\n  then List.append (clone 0 (b-a)) l1;;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 b-a) l1", "out": "Characters 91-100:\n  then List.append (clone 0 b-a) l1;;\n                    ^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append ((clone 0 b) - a) l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 1) l1", "out": "Characters 78-104:\n  then List.append (clone 0 1) l1;;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 1) l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(1)\nthen List.append (clone 0 1) l1", "out": "Characters 67-70:\n  if(1)\n    ^^^\nError: This expression has type int but an expression was expected of type\n         bool\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if 1 then List.append (clone 0 1) l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append (clone 0 1) l1", "out": "Characters 79-105:\n  then List.append (clone 0 1) l1;;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append (clone 0 1) l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append l1 l1", "out": "Characters 79-96:\n  then List.append l1 l1;;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append l1 l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "out": "", "min": "\nlet padZero l1 l2 = let (a,b) = ((List.length l1), (List.length l2)) in a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen a", "out": "Characters 78-79:\n  then a;;\n       ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then a;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen 1", "out": "Characters 78-79:\n  then 1;;\n       ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen 1", "out": "Characters 78-79:\n  then 1;;\n       ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen \"\"", "out": "Characters 78-80:\n  then \"\";;\n       ^^\nError: This expression has type string but an expression was expected of type\n         unit\n", "min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then \"\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = List.length l1", "out": "", "min": "\nlet padZero l1 l2 = List.length l1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let a = List.length l1 in\na", "out": "", "min": "\nlet padZero l1 l2 = let a = List.length l1 in a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (a<b)\nthen a", "out": "Characters 85-86:\n  then a;;\n       ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if a < b then a;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1", "out": "Characters 85-86:\n  then 1;;\n       ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen clone 0 1", "out": "Characters 85-94:\n  then clone 0 1;;\n       ^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then clone 0 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "out": "", "min": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1 else 2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen ((List.append (clone 0 (b-a)) l1),l2)\nelse if(b<a)\nthen (l1,(List.append (clone 0 (a-b)) l2))\nelse \n(l1,l2)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h=0 then removeZero t else l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (f) l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith \"to be implemented\"", "out": "", "min": "\nlet stringOfList f l = failwith \"to be implemented\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = failwith \"to be implemented\"", "out": "", "min": "\nlet stringOfList f l = failwith \"to be implemented\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (f) l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat(\" \" (List.map (f) l))", "out": "Characters 33-36:\n  let stringOfList f l = sepConcat(\" \" (List.map (f) l));;\n                                   ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" (List.map f l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \",\" (List.map (f) l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"\" (List.map (f) l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \";\" (List.map (f) l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"[;\" (List.map (f) l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[;\" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l =  t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.append \"[\"::(sepConcat \";\" (List.map (f) l)) \"]\"", "out": "Characters 35-38:\n  let stringOfList f l = List.append \"[\"::(sepConcat \";\" (List.map (f) l)) \"]\";;\n                                     ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (List.append \"[\") ::\n  ((sepConcat \";\" (List.map f l)) \"]\");;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\"::(sepConcat \";\" (List.map (f) l))", "out": "Characters 28-60:\n  let stringOfList f l = \"[\"::(sepConcat \";\" (List.map (f) l));;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" :: (sepConcat \";\" (List.map f l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = (sepConcat \";\" (List.map (f) l))", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet accum=[] in\nlet rec helper accum n=\nif n<1\nthen accum\nelse helper (x::accum)(n-1) in\nhelper accum n", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 112-138:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 139-143:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 135-139:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = ([],[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(t,(h+x))::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 76-88:\n  a=(t,(h+x))::a\n    ^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list * 'c\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ((t, (h + x)) :: a) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(l1,(h+x))\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 168-169:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list * int -> int -> bool\n       but an expression was expected of type\n         int list * int -> int -> int list * int\n       Type bool is not compatible with type int list * int \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = (l1, (h + x)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\nx+h\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 159-160:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list * 'a -> int -> int\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int is not compatible with type int list * 'a \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in x + h in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(x+h,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 164-165:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list * 'a -> int -> int * 'b list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ((x + h), []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([h],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([h], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(0,0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 81-82:\n  (0,0)::a\n         ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in (0, 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 77-78:\n  0::a\n     ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in 0 :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[0;0]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 81-82:\n  [0;0]::a\n         ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type int list list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [0; 0] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[[0];[0]]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 85-86:\n  [[0];[0]]::a\n             ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type int list list list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [[0]; [0]] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 83-84:\n  ([],[])::a\n           ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * 'd list) list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 82-83:\n  ([],0)::a\n          ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * int) list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[([],0)]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 84-85:\n  [([],0)]::a\n            ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * int) list list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [([], 0)] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[],0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 80-81:\n  [],0::a\n        ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], (0 :: a)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 78-79:\n  []::a\n      ^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type 'c list list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 168-169:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list * int list -> int -> bool\n       but an expression was expected of type\n         int list * int list -> int -> int list * int list\n       Type bool is not compatible with type int list * int list \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 163-164:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list * 'b -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b -> 'c -> 'a list * 'b\n       Type bool is not compatible with type 'a list * 'b \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, b) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 165-166:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 165-166:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(l1,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 165-166:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (l1, []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in (t, (x :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in (t, (x :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,x+h::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 124-136:\n  (asd,padZero(asd,x+h::b))\n              ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then let asd = (x / h) :: t in (asd, (padZero (asd, ((x + h) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,(x+h::b)))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 124-138:\n  (asd,padZero(asd,(x+h::b)))\n              ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then let asd = (x / h) :: t in (asd, (padZero (asd, ((x + h) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3,asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 166-177:\n  (asd3,padZero(asd3,asd2))\n               ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3, asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3 asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 167-171:\n  (asd3,padZero(asd3 asd2))\n                ^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3 asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 172-176:\n  (asd3,padZero asd3 asd2)\n                     ^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 asd2))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2::b)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 172-176:\n  (asd3,padZero asd3 asd2::b)\n                     ^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, ((padZero asd3 asd2) :: b))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 191-197:\n  (t,x+h::b)\n     ^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list * int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 (asd2 :: b)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 191-199:\n  (t,(x+h)::b)\n     ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list * int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 (asd2 :: b)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 0)\nthen\nlet asd= 1 in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 0\n      then\n        let asd = 1 in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet asd3=1::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let asd3 = 1 :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet asd3=1::t in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in let asd3 = 1 :: t in (asd3, (asd2 :: b))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[])\nthen\nlet asd2=x+h-10 in\nlet asd3=t in\nlet asd3=h2+1::t2 in\n([],asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 225-227:\n  let asd3=h2+1::t2 in\n           ^^\nError: Unbound value h2\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if t = []\n        then\n          (let asd2 = (x + h) - 10 in\n           let asd3 = t in let asd3 = (h2 + 1) :: t2 in ([], (asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] & (x+h)>9)\nthen\nlet asd2=x+h-10 in\nlet asd3=asd2::b in\n([],1::asd3)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) & ((x + h) > 9)\n        then\n          (let asd2 = (x + h) - 10 in\n           let asd3 = asd2 :: b in ([], (1 :: asd3)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\nlet asd3=asd2::b in\n([],1::asd3)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then\n          (let asd2 = (x + h) - 10 in\n           let asd3 = asd2 :: b in ([], (1 :: asd3)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev 0::l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 272-273:\n  let base = (List.rev 0::l1,[]) in\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = (((List.rev 0) :: l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::5::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: 5 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,5::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (5 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,5::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (5 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([1],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([1], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([1;1;1],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([1; 1; 1], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b))\n         else\n           (let asd2 = (x + h) - 10 in\n            let h2::t2 = t in\n            let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (1::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b))\n         else\n           (let asd2 = (x + h) - 10 in\n            let h2::t2 = t in\n            let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev (1 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (1::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b))\n         else\n           (let asd2 = (x + h) - 10 in\n            let h2::t2 = t in\n            let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev (1 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b))\n         else\n           (let asd2 = (x + h) - 10 in\n            let h2::t2 = t in\n            let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if((t=[]) && ((x+h)>9))\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif((t=[]) && ((x+h)>9))\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if (t = []) && ((x + h) > 9)\n         then let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b))\n         else\n           (let asd2 = (x + h) - 10 in\n            let h2::t2 = t in\n            let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper i l accum = \nif(i ~=0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper", "out": "Characters 77-79:\n  if(i ~=0)\n       ^^\nError: Unbound value ~=\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper i l accum =\n    if i (~= 0)\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper i l accum = \nif(i != 0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper", "out": "Characters 111-115:\n  | h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\n            ^^^^\nError: Unbound value list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper i l accum =\n    if i != 0\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "out": "Characters 87-95:\n  helper x-1 l (bigAdd l accum)\n  ^^^^^^^^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then (helper x) - (1 l (bigAdd l accum)) else accum in\n  mulByDigit (helper i l accum);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "out": "Characters 144-162:\n  mulByDigit (helper i l accum);;\n             ^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit (helper i l accum);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\n(helper i l accum)", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nhelper i l accum", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 145-146:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list * 'a -> int -> int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int list is not compatible with type int list * 'a \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in mulByDigit x q in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 148-149:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list * 'a -> int -> int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int list is not compatible with type int list * 'a \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in mulByDigit x q in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((mulByDigit x q), []) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(l1,mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (l1, (mulByDigit x q)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(l1,mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (l1, (mulByDigit x q)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n((+)1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 152-153:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list * 'a -> int -> (int -> int) * int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int -> int is not compatible with type int list \n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 67-68:\n  (q+1,mulByDigit x q) in \n                    ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x l1) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x l1)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit (x*q) l1) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit (x * q) l1)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit (x*q) l1) in \nlet base = (1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit (x * q) l1)) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q*10,mulByDigit (x*q) l1) in \nlet base = (1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q * 10), (mulByDigit (x * q) l1)) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q*10,(bigAdd w (mulByDigit (x*q) l1))) in \nlet base = (1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q * 10), (bigAdd w (mulByDigit (x * q) l1))) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
