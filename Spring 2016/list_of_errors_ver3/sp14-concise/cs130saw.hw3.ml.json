{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 36-37:\n  let f a x = fun y -> f (x a) in\n                       ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x y = f (x a) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun y -> f (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs"}, {"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y + 3 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-82:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x = 3 + a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = 3 + a in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-82:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x = 3 + a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = 3 + a in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun g -> a x in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 89-93:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x g = g (x a) in let base g = g in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> g (x a) in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-88:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x g = (a x) g in let base g = g in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> (a x) g in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 90-94:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet pipe fs =\n  let f a x g = g (a x) in let base g = g in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> g (a x)  in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 90-94:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x g = g (x a) in let base g = g in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> g (x a)  in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 88-89:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x g = (g x) a in let base g = g in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> (g x) a  in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 88-89:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x g = (g a) x in let base g = g in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> (g a) x  in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-88:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x g = (a x) g in let base g = g in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> (a x) g in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun g -> g in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ \"a\" in\nlet base = failwith \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = failwith \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = failwith \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 39-42:\n  let stringOfList f l = sepConcat \"; \" (map f l);;\n                                         ^^^\nError: Unbound value map\nHint: Did you mean max?\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (map f l);;\n", "in": "let stringOfList f l = sepConcat \"; \" (map f l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \"; \" (List.map f l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^  (sepConcat \"; \" (List.map f l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone _ 0 = []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone _ 0 = []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x 0 = []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let clone x 0 = []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x :: clone x (n - 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> if n > 0 \nthen x :: clone x (n - 1)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-100:\n  in ((clone 0 (l2 - l1)) @ l1, (clone 0 (l1 - l2)) @ l2);;\n                            ^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let l1 = List.length l1 in\n  let l2 = List.length l2 in\n  (((clone 0 (l2 - l1)) @ l1), ((clone 0 (l1 - l2)) @ l2));;\n", "in": "let padZero l1 l2 = \nlet l1 = List.length l1\nin let l2 = List.length l2\nin ((clone 0 (l2 - l1)) @ l1, (clone 0 (l1 - l2)) @ l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet ll1 = List.length l1\nin let ll2 = List.length l2\nin ((clone 0 (ll2 - ll1)) @ l1, (clone 0 (ll1 - ll2)) @ l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| h :: t -> if h == 0\nthen removeZero t\nelse h :: t\n| [] -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet ll1 = List.length l1\nin let ll2 = List.length l2\nin ((clone 0 (ll2 - ll1)) @ l1, (clone 0 (ll1 - ll2)) @ l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> if n > 0 \nthen x :: clone x (n - 1)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet ll1 = List.length l1\nin let ll2 = List.length l2\nin ((clone 0 (ll2 - ll1)) @ l1, (clone 0 (ll1 - ll2)) @ l2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 229-250:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) = ((((c + x1) + x2) / 10), (((c + x1) + x2) mod 10)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| h :: t -> if h == 0\nthen removeZero t\nelse h :: t\n| [] -> []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 229-250:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) = ((((c + x1) + x2) / 10), (((c + x1) + x2) mod 10)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 203-207:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (1, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10 + 1, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 143-155:\n  let args = List.reverse (List.combine l1 l2) in\n             ^^^^^^^^^^^^\nError: Unbound value List.reverse\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) = ((((c + x1) + x2) / 10), (((c + x1) + x2) :: ds)) in\n    let base = (0, []) in\n    let args = List.reverse (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.reverse (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2) / 10]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2)/10]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2)/1]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2)/2]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = (2, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = (0, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = (1, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10 + 1, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2), ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + 1), ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + 1), ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c), ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c), (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, [1]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 115-117:\n  then (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\n                ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      if (List.length ds) = (List.length x1)\n      then (0, ((((c + x1) + x2) / 10) :: (((c + x1) + x2) mod 10) :: ds))\n      else ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length x1 \nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length l1 \nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length l1 - 1\nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 81-82:\n  let f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd 0 (clone l2 x)) @ indent) in\n                                                               ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      if (List.length ds) = ((List.length l1) - 1)\n      then (0, ((((c + x1) + x2) / 10) :: (((c + x1) + x2) mod 10) :: ds))\n      else ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet bigMul l1 l2 =\n  let f (indent,acc) x =\n    ((0 :: indent), ((List.fold_left bigAdd 0 (clone l2 x)) @ indent)) in\n  let base = ([], []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd 0 (clone l2 x)) @ indent) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd [] (clone l2 x)) @ indent) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f (indent, acc) x = (0 :: indent, bigAdd acc ((List.fold_left bigAdd [] (clone l2 x)) @ indent)) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = List.fold_left bigAdd [] (clone l i)"}]}
