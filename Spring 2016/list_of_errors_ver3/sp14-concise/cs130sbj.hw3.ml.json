{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-34:\n  let f a x = a^2::x  in\n                ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n", "min": "\nlet sqsum xs =\n  let f a x = a ^ (2 :: x) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a^2::x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-32:\n  let f a x = (a^2)::x  in\n                 ^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet sqsum xs =\n  let f a x = (a ^ 2) :: x in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = (a^2)::x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-33:\n  let f a x = (a^2.)::x  in\n                 ^^\nError: This expression has type float but an expression was expected of type\n         string\n", "min": "\nlet sqsum xs =\n  let f a x = (a ^ 2.) :: x in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = (a^2.)::x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-73:\n  List.fold_left f base xs;;\n                 ^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n", "min": "\nlet sqsum xs =\n  let f a x = (a * a) :: x in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = (a*a)::x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (1)+ x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (a)+ x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+ 1  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a*a + x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs n= \nlet f a x = x a  in\nlet base = n in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-47:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = a in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-49:\n  let base = f a in\n               ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = f a in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 76-78:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n       The type variable 'a occurs inside\n       ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n", "min": "\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = f fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-79:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n       The type variable 'a occurs inside\n       ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n", "min": "\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = f fs  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x   in\nlet base = f   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = 0   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs n = \nlet f a x = x a  in\nlet base = n  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs  = \nlet f a x = x   in\nlet base = 0   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs  = \nlet f a x = x   in\nlet base = f   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs  = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe2 fs = function \n| n -> \nlet rec helper res = function\n| [] ->  res\n| x::xs' -> helper (x res) xs'\nin helper n fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs  = \nlet f a x = x a  in\nlet base = function y ->y  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe2 fs = function \n| n -> \nlet rec helper res = function\n| [] ->  res\n| x::xs' -> helper (x res) xs'\nin helper n fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-34:\n  let f a x = a^2::x  in\n                ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n", "min": "\nlet sqsum xs =\n  let f a x = a ^ (2 :: x) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a^2::x  in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 87-89:\n  List.fold_left f base xs;;\n                        ^^\nError: Unbound value xs\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base xs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = function y -> y  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = function y -> y  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = function y -> y  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 3  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun y -> 3  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun y -> y  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-49:\n  let stringOfList f l = \"[\" ^ (sepConcat \"; \" (map f l)) ^ \"]\";;\n                                                ^^^\nError: Unbound value map\nHint: Did you mean max?\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (map f l)) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (map f l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet rec helper x n acc =\nif n<= 0 then\nacc\nelse\nhelper x (n-1) (x::acc) \nin\nhelper x n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-129:\n  ((clone 0 (len1-len2)) @ len2),len1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ len2), len1);;\n", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n((clone 0 (len1-len2)) @ len2),len1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nl1\nelse\nl2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-125:\n  ((clone 0 (len1-len2)) @ l2),l1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ l2), l1);;\n", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n((clone 0 (len1-len2)) @ l2),l1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nlen1\nelse\nlen2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 122-153:\n  ((clone 0 (len2-len1)) @ l1),l2;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then clone 0 (len1 - len2)\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n((clone 0 (len2-len1)) @ l1),l2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) @ l2\nelse\n(clone 0 (len2-len1)) @ l1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n((clone 0 (len1-len2)) @ l2 , l1)\nelse\n((clone 0 (len2-len1)) @ l1 ,l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(l1,(clone 0 (len1-len2)) @ l2)\nelse\n((clone 0 (len2-len1)) @ l1 ,l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| []   -> []\n| 0::t -> removeZero t\n| h::t -> t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| []   -> []\n| 0::t -> removeZero t\n| t -> t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(1,(10-xx)::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(0,xx::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(1,(xx-10)::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 203-204:\n  let args = List.combine 0::(List.rev l1) 0::(List.rev l2) in\n                          ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = (List.combine 0) :: ((List.rev l1) 0) :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(1,(xx-10)::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine 0::(List.rev l1) 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(1,(xx-10)::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine (0::(List.rev l1)) (0::(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 213-214:\n  let args = List.combine (List.rev 0::l1) (0::(List.rev l2)) in\n                                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) (0 :: (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(1,(xx-10)::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine (List.rev 0::l1) (0::(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(1,(xx-10)::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc s =\nlet l2 = List.rev l in\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin helper i l [] 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc s =\nlet l2 = List.rev l in\nmatch l with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin helper i l [] 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 117-118:\n  let shift= mulByDigit ac a in \n                           ^\nError: This expression has type int * 'a\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit ac a in ((ac * 10), (bigAdd mul shift)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac a in \n(ac*10,bigAdd mul shift)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,l2)) l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 114-117:\n  let shift= mulByDigit mul ac in \n                        ^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit mul ac in ((ac * 10), (bigAdd shift la)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, (List.rev l2))) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit mul ac in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac mul in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac mul in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,l2)) l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac mul in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,l2)) (l1) in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc s =\nlet l2 = List.rev l in\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin helper i l [] 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc s =\nlet l2 = List.rev l in\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin helper i l [] 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc s =\nlet l2 = List.rev l in\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t (n::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin helper i l [] 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc s =\nlet l2 = List.rev l in\nmatch l2 with\n| []   -> \n(s,0)::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n,n/10)::acc) (n/10) \nelse\nhelper i t ((n,0)::acc) 0\nin helper i l [] 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc s =\nlet l2 = List.rev l in\nmatch l2 with\n| []   -> \n(s,[])::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n,t)::acc) (n/10) \nelse\nhelper i t ((n,t)::acc) 0\nin helper i l [] 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l2 acc s =\nmatch l2 with\n| []   -> \n(s,[])::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n,t)::acc) (n/10) \nelse\nhelper i t ((n,t)::acc) 0\nin helper i (List.rev l) [] 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l2 acc s =\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin helper i (List.rev l) [] 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l2 acc s =\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin removeZero (helper i (List.rev l) [] 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac mul in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,l2)) (l1) in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\n\n(ac*10,bigAdd mul la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,l2)) (l1) in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\n\n(0::ac,bigAdd (List.append mul ac) la)\nin\nlet base = ([],[]) in\nlet args = List.map (fun x -> (x,l2)) (l1) in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (sft,la)=a in\nlet mul= mulByDigit v l in\nlet shift = List.append mul sft in \n(0::sft,bigAdd shift la)\nin\nlet base = ([],[]) in\nlet args = List.map (fun x -> (x,l2)) (l1) in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (sft,la)=a in\nlet mul= mulByDigit v l in\nlet shift = List.append mul sft in \n(0::sft,bigAdd shift la)\nin\nlet base = ([],[]) in\nlet args = List.map (fun x -> (x,l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun y -> y+0  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs n= \nlet f a x = x(a) in\nlet base = n  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = function y ->y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-47:\n  let base = y in\n             ^\nError: Unbound value y\n", "min": "\nlet pipe fs = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = function [] -> 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = function _ -> 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-85:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = function | _ -> x a in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function _ ->x(a) in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  x(a) in\nlet base = function y ->y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 97-98:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x = function | f' -> f' x a in\n  let base = function | y -> y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function f' -> f' x(a) in\nlet base = function y ->y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 97-98:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x = function | f' -> x (f' a) in\n  let base = function | y -> y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function f'->  x(f' a) in\nlet base = function y ->y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function v ->  x (a v) in\nlet base = function y ->y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function v ->  x (a v) in\nlet base = function y ->y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec multByDigit i l =\nlet rec helper i l2 acc s =\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin \nremoveZero (helper i (List.rev l) [] 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (sft,la)=a in\nlet mul= mulByDigit v l in\nlet shift = List.append mul sft in \n(0::sft,bigAdd shift la)\nin\nlet base = ([],[]) in\nlet args = List.map (fun x -> (x,l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
