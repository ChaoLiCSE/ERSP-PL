{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nfailwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nfailwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> sum = sum + hd :: sumLists tl", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | hd::tl -> sum = ((sum + hd) :: (sumLists tl));;\n", "out": "Characters 58-61:\n  | hd::tl -> sum = sum + hd :: sumLists tl;;\n              ^^^\nError: Unbound value sum\n"}, {"type": "", "in": "failwith \"TBD:sumList\"", "min": "\nlet _ = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "failwith \"TBD:sumList\"", "min": "\nlet _ = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "failwith \"TBD:sumList\"", "min": "\nlet _ = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> sum  = sum + hd :: sumLists tl", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | hd::tl -> sum = ((sum + hd) :: (sumLists tl));;\n", "out": "Characters 58-61:\n  | hd::tl -> sum  = sum + hd :: sumLists tl;;\n              ^^^\nError: Unbound value sum\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "out": "Characters 63-75:\n  | hd::tl -> hd + (sumList tl);;\n                   ^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}, {"type": "", "in": "failwith \"TBD:sumList\"", "min": "\nlet _ = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList (1:xs): int =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList (1 : xs) =\n  (match xs with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "out": "Characters 19-21:\n  let rec sumList (1:xs): int =\n                     ^^\nError: Unbound type constructor xs\n"}, {"type": "", "in": "failwith \"TBD:sumList\"", "min": "\nlet _ = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList (1:int xs): int =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList (1 : int xs) =\n  (match xs with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "out": "Characters 19-25:\n  let rec sumList (1:int xs): int =\n                     ^^^^^^\nError: Unbound type constructor xs\n"}, {"type": "", "in": "failwith \"TBD:sumList\"", "min": "\nlet _ = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sumList (1 : int list): int =\nmatch 1 with\n[] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList (1 : int list) =\n  (match 1 with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "out": "Characters 17-18:\n  let rec sumList (1 : int list): int =\n                   ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type int list\n"}, {"type": "", "in": "failwith \"TBD:sumList\"", "min": "\nlet _ = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList (l : int list): int =\nmatch l with\n[] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList (l : int list) =\n  (match l with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList (l : int list): int =\nmatch l with\n[] -> 0\n| hd::tl -> hd + (sumList tl)\nfailwith \"TBD:sumList\"", "min": "\nlet rec sumList (l : int list) =\n  (match l with\n   | [] -> 0\n   | hd::tl -> hd + ((sumList tl) failwith \"TBD:sumList\") : int);;\n", "out": "Characters 76-88:\n  | hd::tl -> hd + (sumList tl)\n                   ^^^^^^^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList (l : int list): int =\nmatch l with\n[] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList (l : int list) =\n  (match l with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList (l : int list): int =\nmatch l with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList (l : int list) =\n  (match l with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList (hd::tl) =\nmatch hd with\n| [] -> 0\n| hd -> hd + (sumList tl)", "min": "\nlet rec sumList (hd::tl) = match hd with | [] -> 0 | hd -> hd + (sumList tl);;\n", "out": "Characters 59-61:\n  | hd -> hd + (sumList tl);;\n          ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "min": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "min": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "min": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "min": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "min": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n acc", "min": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n acc;;\n", "out": "Characters 134-137:\n  | _ -> loop n acc;;\n                ^^^\nError: Unbound value acc\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]", "min": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [7];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [7];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [7];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> []", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nsumList (digits n)", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n = sumList (digits n);;\n", "out": "Characters 32-39:\n  sumList (digits n);;\n  ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nif (n < 10) then n\nelse sumList (digits n)", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n = if n < 10 then n else sumList (digits n);;\n", "out": "Characters 56-63:\n  else sumList (digits n);;\n       ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nif (n < 10) then n\nelse additivePersistence (sumList (digits n))", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  if n < 10 then n else additivePersistence (sumList (digits n));;\n", "out": "Characters 77-84:\n  else additivePersistence (sumList (digits n));;\n                            ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n =\nif (n < 10) then n\nelse additivePersistence (sumList (digits n))", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else additivePersistence (sumList (digits n));;\n", "out": "Characters 48-67:\n  else additivePersistence (sumList (digits n));;\n       ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n =\nif (n < 10) then n\nelse digitalRoot (sumList (digits n))", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "out": "Characters 61-68:\n  else digitalRoot (sumList (digits n));;\n                    ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper sumList(digits n) (i+1) in \nn", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  let rec aPHelper n i =\n    if n < 10 then i else aPHelper sumList (digits n) (i + 1) in\n  n;;\n", "out": "Characters 88-95:\n  else aPHelper sumList(digits n) (i+1) in \n                ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \nn", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  let rec aPHelper n i =\n    if n < 10 then i else aPHelper (sumList (digits n)) (i + 1) in\n  n;;\n", "out": "Characters 89-96:\n  else aPHelper (sumList(digits n)) (i+1) in \n                 ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \ni", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  let rec aPHelper n i =\n    if n < 10 then i else aPHelper (sumList (digits n)) (i + 1) in\n  i;;\n", "out": "Characters 89-96:\n  else aPHelper (sumList(digits n)) (i+1) in \n                 ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \n9", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  let rec aPHelper n i =\n    if n < 10 then i else aPHelper (sumList (digits n)) (i + 1) in\n  9;;\n", "out": "Characters 89-96:\n  else aPHelper (sumList(digits n)) (i+1) in \n                 ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \naPHelpher n 0", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  let rec aPHelper n i =\n    if n < 10 then i else aPHelper (sumList (digits n)) (i + 1) in\n  aPHelpher n 0;;\n", "out": "Characters 89-96:\n  else aPHelper (sumList(digits n)) (i+1) in \n                 ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \naPHelper n 0", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  let rec aPHelper n i =\n    if n < 10 then i else aPHelper (sumList (digits n)) (i + 1) in\n  aPHelper n 0;;\n", "out": "Characters 89-96:\n  else aPHelper (sumList(digits n)) (i+1) in \n                 ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n =\nif (n < 10) then n\nelse digitalRoot (sumList (digits n))", "min": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "out": "Characters 61-68:\n  else digitalRoot (sumList (digits n));;\n                    ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then hd\nelse listReverse tl", "min": "\nlet rec listReverse n =\n  match n with | hd::tl -> if tl = [] then hd else listReverse tl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then n\nelse listReverse tl", "min": "\nlet rec listReverse n =\n  match n with | hd::tl -> if tl = [] then n else listReverse tl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then [tl::hd]\nelse listReverse tl", "min": "\nlet rec listReverse n =\n  match n with | hd::tl -> if tl = [] then [tl :: hd] else listReverse tl;;\n", "out": "Characters 72-74:\n  if (tl = []) then [tl::hd]\n                         ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then (tl::hd)\nelse listReverse tl", "min": "\nlet rec listReverse n =\n  match n with | hd::tl -> if tl = [] then tl :: hd else listReverse tl;;\n", "out": "Characters 72-74:\n  if (tl = []) then (tl::hd)\n                         ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then (tl::hd)\nelse listReverse tl", "min": "\nlet rec listReverse n =\n  match n with | hd::tl -> if tl = [] then tl :: hd else listReverse tl;;\n", "out": "Characters 72-74:\n  if (tl = []) then (tl::hd)\n                         ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then n\nelse ((listReverse tl)::hd)", "min": "\nlet rec listReverse n =\n  match n with | hd::tl -> if tl = [] then n else (listReverse tl) :: hd;;\n", "out": "Characters 75-91:\n  else ((listReverse tl)::hd);;\n        ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then n\nelse (listReverse tl::hd)", "min": "\nlet rec listReverse n =\n  match n with | hd::tl -> if tl = [] then n else (listReverse tl) :: hd;;\n", "out": "Characters 75-89:\n  else (listReverse tl::hd);;\n        ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\nif (tl = []) then n\nelse (listReverse tl::hd)", "min": "\nlet rec listReverse n =\n  match n with\n  | [] -> []\n  | hd::tl -> if tl = [] then n else (listReverse tl) :: hd;;\n", "out": "Characters 86-100:\n  else (listReverse tl::hd);;\n        ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\nif (tl = []) then n\nelse (listReverse tl::hd)", "min": "\nlet rec listReverse n =\n  match n with\n  | [] -> []\n  | hd::tl -> if tl = [] then n else (listReverse tl) :: hd;;\n", "out": "Characters 86-100:\n  else (listReverse tl::hd);;\n        ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\nif (tl = []) then (n)\nelse (listReverse tl::hd)", "min": "\nlet rec listReverse n =\n  match n with\n  | [] -> []\n  | hd::tl -> if tl = [] then n else (listReverse tl) :: hd;;\n", "out": "Characters 88-102:\n  else (listReverse tl::hd);;\n        ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then n\nelse ((listReverse tl)::hd)", "min": "\nlet rec listReverse n =\n  match n with | hd::tl -> if tl = [] then n else (listReverse tl) :: hd;;\n", "out": "Characters 75-91:\n  else ((listReverse tl)::hd);;\n        ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\n(listReverse tl) @ (hd)", "min": "\nlet rec listReverse n =\n  match n with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\n(listReverse tl) @ [hd]", "min": "\nlet rec listReverse n =\n  match n with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl -> (listReverse tl) :: [hd]", "min": "\nlet rec listReverse n =\n  match n with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "out": "Characters 60-76:\n  | hd::tl -> (listReverse tl) :: [hd];;\n              ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nlet rec concat x y = (x::y)\nin\nmatch n with\n| [] -> []\n| hd::tl -> concat (listReverse tl) [hd]", "min": "\nlet rec listReverse n =\n  let rec concat x y = x :: y in\n  match n with | [] -> [] | hd::tl -> concat (listReverse tl) [hd];;\n", "out": "Characters 91-119:\n  | hd::tl -> concat (listReverse tl) [hd];;\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl -> (listReverse tl)::[hd]", "min": "\nlet rec listReverse n =\n  match n with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "out": "Characters 60-76:\n  | hd::tl -> (listReverse tl)::[hd];;\n              ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl -> listReverse tl::[hd]", "min": "\nlet rec listReverse n =\n  match n with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "out": "Characters 60-74:\n  | hd::tl -> listReverse tl::[hd];;\n              ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse n =\nlet rec insert_at_end l i =\nmatch l with\n[] -> [i]\n| h :: t -> h :: (insert_at_end t i) in\nmatch n with\n| [] -> []\n| hd::tl -> insert_at_end (listReverse tl) [hd]", "min": "\nlet rec listReverse n =\n  let rec insert_at_end l i =\n    match l with | [] -> [i] | h::t -> h :: (insert_at_end t i) in\n  match n with | [] -> [] | hd::tl -> insert_at_end (listReverse tl) [hd];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse n =\nlet rec insert_at_end l i =\nmatch l with\n[] -> [i]\n| h :: t -> h :: (insert_at_end t i) in\nmatch n with\n| [] -> []\n| hd::tl -> insert_at_end (listReverse tl) hd", "min": "\nlet rec listReverse n =\n  let rec insert_at_end l i =\n    match l with | [] -> [i] | h::t -> h :: (insert_at_end t i) in\n  match n with | [] -> [] | hd::tl -> insert_at_end (listReverse tl) hd;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse n =\nlet rec add_to_end l i =\nmatch l with\n[] -> [i]\n| h :: t -> h :: (add_to_end t i) in\nmatch n with\n| [] -> []\n| hd::tl -> add_to_end (listReverse tl) hd", "min": "\nlet rec listReverse n =\n  let rec add_to_end l i =\n    match l with | [] -> [i] | h::t -> h :: (add_to_end t i) in\n  match n with | [] -> [] | hd::tl -> add_to_end (listReverse tl) hd;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w =\nif explode w = listReverse (explode w) then true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse n =\n  let rec add_to_end l i =\n    match l with | [] -> [i] | h::t -> h :: (add_to_end t i) in\n  match n with | [] -> [] | hd::tl -> add_to_end (listReverse tl) hd;;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
