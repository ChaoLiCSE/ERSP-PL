{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun y -> y in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base y = y in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-diff)) @ l1, l2)\nelse\n(l1, ((clone 0 diff) @ l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - diff)) @ l1), l2)\n    else (l1, ((clone 0 diff) @ l2));;\n", "out": "Characters 134-138:\n  ((clone 0 (0-diff)) @ l1, l2)\n               ^^^^\nError: Unbound value diff\nHint: Did you mean dif?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-dif)) @ l1, l2)\nelse\n(l1, ((clone 0 dif) @ l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if (h = 0) then removeZero t else l", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let (_,_) = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet (_,_) = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n", "out": "Characters 12-46:\n  let (_,_) = sepConcat \", \" [\"foo\";\"bar\";\"baz\"];;\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (list.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (list.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 237-241:\n  let args = List.combine (list.rev l1) (List.rev l2) in\n                           ^^^^\nError: Unbound value list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet rec mulHelper l' = match l' with\n| [] -> (0,[])\n| h :: t -> let (carry, rest) = mulHelper t in\nlet prod = i * h + carry in\n(prod/10, (prod mod 10) :: rest) in\nlet (_, ans) = mulHelper (List.rev (0::l)) in\nans", "min": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (List.rev (0 :: l)) in ans;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet rec mulHelper l' = match l' with\n| [] -> (0,[])\n| h :: t -> let (carry, rest) = mulHelper t in\nlet prod = i * h + carry in\n(prod/10, (prod mod 10) :: rest) in\nlet (_, ans) = mulHelper (List.rev (0::0::l)) in\nans", "min": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (List.rev (0 :: 0 :: l)) in ans;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet rec mulHelper l' = match l' with\n| [] -> (0,[])\n| h :: t -> let (carry, rest) = mulHelper t in\nlet prod = i * h + carry in\n(prod/10, (prod mod 10) :: rest) in\nlet (_, ans) = mulHelper (List.rev (l)) in\nans", "min": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (List.rev l) in ans;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = \nlet rec mulHelper l' = match l' with\n| [] -> (0,[])\n| h :: t -> let (carry, rest) = mulHelper t in\nlet prod = i * h + carry in\n(prod/10, (prod mod 10) :: rest) in\nlet (_, ans) = mulHelper 0::(List.rev (l)) in\nans", "min": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = (mulHelper 0) :: (List.rev l) in ans;;\n", "out": "Characters 204-231:\n  let (_, ans) = mulHelper 0::(List.rev (l)) in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet rec mulHelper l' = match l' with\n| [] -> (0,[])\n| h :: t -> let (carry, rest) = mulHelper t in\nlet prod = i * h + carry in\n(prod/10, (prod mod 10) :: rest) in\nlet (_, ans) = mulHelper (0::(List.rev (l))) in\nans", "min": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: (List.rev l)) in ans;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet rec mulHelper l' = match l' with\n| [] -> (0,[])\n| h :: t -> let (carry, rest) = mulHelper t in\nlet prod = i * h + carry in\n(prod/10, (prod mod 10) :: rest) in\nlet (_, ans) = mulHelper (0::l) in\nans", "min": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: l) in ans;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet rec mulHelper l' = match l' with\n| [] -> (0,[])\n| h :: t -> let (carry, rest) = mulHelper t in\nlet prod = i * h + carry in\n(prod/10, (prod mod 10) :: rest) in\nlet (_, ans) = mulHelper (0::l) in\nremoveZero ans", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: l) in removeZero ans;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = bigAdd (a) ((mulByDigit x l1)@[0]) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: l) in removeZero ans;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a ((mulByDigit x l1) @ [0]) in\n  let base = [] in\n  let args = List.rev l2 in let res = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = bigAdd (a) ((mulByDigit x l1)) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: l) in removeZero ans;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a (mulByDigit x l1) in\n  let base = [] in\n  let args = List.rev l2 in let res = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = (bigAdd (a) ((mulByDigit x l1)))@[0] in\nlet base = [] in\nlet args = List.rev l2 in\nlet (res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: l) in removeZero ans;;\n\nlet bigMul l1 l2 =\n  let f a x = (bigAdd a (mulByDigit x l1)) @ [0] in\n  let base = [] in\n  let args = List.rev l2 in let res = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = let (append, acc) = a in\n(0::append, (bigAdd (acc) ((mulByDigit x l1)@append))) in\nlet base = ([],[]) in\nlet args = List.rev l2 in\nlet (_,res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: l) in removeZero ans;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (append,acc) = a in\n    ((0 :: append), (bigAdd acc ((mulByDigit x l1) @ append))) in\n  let base = ([], []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
