{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "min": "\nlet rec sumList xs = List.fold_left (fun sum  -> fun x  -> sum + x) 0 xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsofInt(n/10)", "min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (n mod 10) :: (digitsofInt (n / 10));;\n", "out": "Characters 59-70:\n  else n mod 10 :: digitsofInt(n/10);;\n                   ^^^^^^^^^^^\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsOfInt(n/10)", "min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse digitsOfInt(n/10)::n mod 10", "min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 47-64:\n  else digitsOfInt(n/10)::n mod 10;;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse digitsOfInt(n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse digitsOfInt(n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "min": "\nlet rec sumList xs = List.fold_left (fun sum  -> fun x  -> sum + x) 0 xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet count = 0 in\nif digitsOfInt(n).length = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (digitsOfInt n.length) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "out": "Characters 68-74:\n  if digitsOfInt(n).length = 1 then \n                    ^^^^^^\nError: Unbound record field length\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet count = 0 in\nif List.length digitsOfInt(n) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length digitsOfInt n) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "out": "Characters 53-64:\n  if List.length digitsOfInt(n) = 1 then \n     ^^^^^^^^^^^\nError: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length digitsOfInt(n)) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length digitsOfInt n) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "out": "Characters 54-65:\n  if (List.length digitsOfInt(n)) = 1 then \n      ^^^^^^^^^^^\nError: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "out": "Characters 132-143:\n  additivePersistence(addList(digitsofInt(n)));;\n                              ^^^^^^^^^^^\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "out": "Characters 132-143:\n  additivePersistence(addList(digitsofInt(n)));;\n                              ^^^^^^^^^^^\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\ninc count\nadditivePersistence(addList(digitsOfInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else inc count additivePersistence (addList (digitsOfInt n));;\n", "out": "Characters 104-107:\n  inc count\n  ^^^\nError: Unbound value inc\nHint: Did you mean incr?\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr count\nadditivePersistence(addList(digitsOfInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "out": "Characters 104-108:\n  incr count\n  ^^^^\nError: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "out": "Characters 104-108:\n  incr(count)\n  ^^^^\nError: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse (\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))\n)", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "out": "Characters 106-110:\n  incr(count)\n  ^^^^\nError: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \nincr(count)", "min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1 then count else incr count;;\n", "out": "Characters 109-116:\n  incr(count);;\n      ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int ref\n"}, {"type": "scope", "in": "additivePersistence(addList(digitsOfInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = additivePersistence (addList (digitsOfInt n));;\n", "out": "Error: Unbound value n\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 39-42:\n  additivePersistence(addList(digitsOfInt(n)));;\n                                         ^^^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \ncount = count + 1\nadditivePersistence(addList(digitsOfInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else count = (count + (1 additivePersistence (addList (digitsOfInt n))));;\n", "out": "Characters 121-122:\n  count = count + 1\n                  ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "additivePersistence addList digitsOfInt n", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = additivePersistence addList digitsOfInt n;;\n", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 0-19:\n  additivePersistence addList digitsOfInt n;;\n  ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "addList digitsOfInt 5", "min": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList digitsOfInt 5;;\n", "out": "Characters 0-7:\n  addList digitsOfInt 5;;\n  ^^^^^^^\nError: This function has type 'a * int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "addList digitsOfInt 5", "min": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList digitsOfInt 5;;\n", "out": "Characters 0-7:\n  addList digitsOfInt 5;;\n  ^^^^^^^\nError: This function has type 'a * int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "addList (digitsOfInt,5)", "min": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList (digitsOfInt, 5);;\n", "out": "Characters 21-22:\n  addList (digitsOfInt,5);;\n                       ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "addList (digitsOfInt,5)", "min": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList (digitsOfInt, 5);;\n", "out": "Characters 21-22:\n  addList (digitsOfInt,5);;\n                       ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec addNum = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum = if n < 10 then n else addList (digitsOfInt n);;\n", "out": "Characters 21-22:\n  if n < 10 then n\n     ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \naddNum n", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n\nlet rec digitalRoot n = addNum n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = addNum n", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n\nlet rec digitalRoot n = addNum n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse\ndigitalRoot(addList(digitsOfInt(n)))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (addList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse l @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse l) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nlet l = explode s in\nif listReverse(l) = l then\ntrue\nelse\nfalse", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let l = explode s in if (listReverse l) = l then true else false;;\n", "out": "Characters 36-37:\n  let l = explode s in\n                  ^\nError: Unbound value s\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet l = explode w in\nif listReverse(l) = l then\ntrue\nelse\nfalse", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let l = explode w in if (listReverse l) = l then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet l = explode w in\nif listReverse(l) = l then\ntrue\nelse\nfalse", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let l = explode w in if (listReverse l) = l then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "min": "\nlet rec sumList xs = List.fold_left (fun sum  -> fun x  -> sum + x) 0 xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "min": "\nlet rec sumList xs = List.fold_left (fun sum  -> fun x  -> sum + x) 0 xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \naddHelp(0, n)", "min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n\nlet rec addHelp (count,n) =\n  if n < 10 then count else addHelp ((count + 1), (addNum n));;\n\nlet rec additivePersistence n = addHelp (0, n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "min": "\nlet rec sumList xs = List.fold_left (fun sum  -> fun x  -> sum + x) 0 xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "min": "\nlet rec sumList xs = List.fold_left (fun sum  -> fun x  -> sum + x) 0 xs;;\n", "out": ""}]}
