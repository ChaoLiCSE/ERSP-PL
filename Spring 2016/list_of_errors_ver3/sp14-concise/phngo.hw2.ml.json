{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written 1\" in\nlet rest' = failwith \"to be written 2\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-74:\n  | (f', b') -> if b' then wwhile (f, f')\n                                      ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match b with | (f',b') -> if b' then wwhile (f, f') else f';;\n", "in": "let rec wwhile (f,b) = match b with\n| (f', b') -> if b' then wwhile (f, f')\nelse f'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (f', x') -> if x' then wwhile (f, f')\nelse f'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-31:\n  let rec wwhile (f,b) = match me b with\n                               ^^\nError: Unbound value me\n", "min": "\nlet rec wwhile (f,b) =\n  match me b with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n", "in": "let rec wwhile (f,b) = match me b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f,b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 55-57:\n  wwhile (me, 2);;\n          ^^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let me x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (me, 2);;\n", "in": "let me x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (me, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((if f b = b && f (f x) then f b else fixpoint (f,f b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value x\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 49-50:\n  let fixpoint (f,b) = wwhile ((if f b = b && f (f x) then f b else fixpoint (f,f b)),b);;\n                                                   ^\nError: Unbound value x\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f x)) then f b else fixpoint (f, (f b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((if f b = b && f (f b) then f b else fixpoint (f,f b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 57-60:\n  let fixpoint (f,b) = wwhile ((if f b = b && f (f b) then f b else fixpoint (f,f b)),b);;\n                                                           ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f b)) then f b else fixpoint (f, (f b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((if f b = b && f (f b) then (f b) else fixpoint (f,f b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 57-62:\n  let fixpoint (f,b) = wwhile ((if f b = b && f (f b) then (f b) else fixpoint (f,f b)),b);;\n                                                           ^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f b)) then f b else fixpoint (f, (f b))), b);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-100:\n  let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper,b);;\n                                                                                                ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "in": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-100:\n  let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b);;\n                                                                                                ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "in": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true)\nelse (f b, false)\nin helper,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-100:\n  in helper,b);;\n     ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "in": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (b',c') -> if c' then wwhile (f,b')\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 18-19:\n  let _ = fixpoint (f, 1);;;\n                    ^\nError: Unbound value f\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper b = if b = (f b) then ((f b), false) else ((f b), true) in\n      helper), b);;\n\nlet _ = fixpoint (f, 1);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nfixpoint (f, 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi*\" ^ (exprToString e) ^ \")\"\n| Cosine e -> \"cos(pi*\" ^ (exprToString e) ^ \")\"\n| Average (e1,e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")/2)\"\n| Times (e1,e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1,e2,e3,e4) -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^\n(exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX\t\t      -> \"x\"\n| VarY\t\t\t-> \"y\"\n| Sine e\t\t-> \"sin(pi*\" ^ (exprToString e) ^ \")\"\n| Cosine e\t\t-> \"cos(pi*\" ^ (exprToString e) ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")/2)\"\n| Times (e1,e2)\t        -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^\n(exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This expression has type expr/2315\n       but an expression was expected of type expr/2519\nError: This expression has type expr/2573\n       but an expression was expected of type expr/2593\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: This expression has type expr/2315\n       but an expression was expected of type expr/2519\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. (eval(e,x,y)))\n| Cosine e -> cos(pi *. (eval(e,x,y)))\n| Average (e1,e2) -> (((eval(e1,x,y)) +. (eval(e2,x,y))) /. (2.0))\n| Times (e1,e2) -> (eval(e1,x,y)) *. (eval(e2,x,y))\n| Thresh (e1,e2,e3,e4) -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y)) else (eval(e4,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. (eval(e,x,y)))\n| Cosine e -> cos(pi *. (eval(e,x,y)))\n| Average (e1,e2) -> (((eval(e1,x,y)) +. (eval(e2,x,y))) /. (2.0))\n| Times (e1,e2) -> (eval(e1,x,y)) *. (eval(e2,x,y))\n| Thresh (e1,e2,e3,e4) -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y))\nelse (eval(e4,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value buildMax\nHint: Did you mean build, buildY or buildX?\nError: Unbound value buildMax\nHint: Did you mean build, buildX or buildY?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 369-377:\n  |5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))\n        ^^^^^^^^\nError: Unbound value buildMax\nHint: Did you mean build, buildY or buildX?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 7) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildMax ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildCubic\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,5) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|_ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (b',c') -> if c' then wwhile (f,b')\nelse b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|_ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Divide   of expr * expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Custom2  of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Divide   of expr * expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Hello    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This expression has type expr/2731\n       but an expression was expected of type expr/2799\nError: This expression has type expr/2843\n       but an expression was expected of type expr/2853\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 21-32:\n  let _ = exprToString sampleExpr4;;\n                       ^^^^^^^^^^^\nError: This expression has type expr/2731\n       but an expression was expected of type expr/2799\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Divide of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello1 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Hello2 of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Hello1 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e1) ^ \")\")))))))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Hello2 (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e4) ^ (\":\" ^ ((exprToString e3) ^ \")\")))))));;\n\nlet sampleExpr4 = Hello (VarX, VarY, (Cosine VarY));;\n\nlet _ = exprToString sampleExpr4;;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t      -> x\n| VarY\t\t\t-> y\n| Sine e\t\t-> sin(pi *. (eval(e,x,y)))\n| Cosine e\t\t-> cos(pi *. (eval(e,x,y)))\n| Average (e1,e2)       -> (((eval(e1,x,y)) +. (eval(e2,x,y))) /. (2.0))\n| Times (e1,e2)\t\t-> (eval(e1,x,y)) *. (eval(e2,x,y))\n| Hello1 (e1,e2,e3)     -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y))\nelse (eval(e1,x,y)))\n| Thresh (e1,e2,e3,e4)  -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y))\nelse (eval(e4,x,y)))\n| Hello2 (e1,e2,e3,e4)  -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e4,x,y))\nelse (eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine        of expr\n| Cosine      of expr\n| Fourth      of expr\n| Average     of expr * expr\n| Times       of expr * expr\n| ThreeTimes  of expr * expr * expr\n| Thresh      of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 167-169:\n  | Fourth e\t\t-> ((eval(e1,x,y)) /. (4.0))\n                        ^^\nError: Unbound value e1\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ThreeTimes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Fourth e -> (eval (e1, x, y)) /. 4.0\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | ThreeTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t      -> x\n| VarY\t\t\t-> y\n| Sine e\t\t-> sin(pi *. (eval(e,x,y)))\n| Cosine e\t\t-> cos(pi *. (eval(e,x,y)))\n| Fourth e\t\t-> ((eval(e,x,y)) /. (4.0))\n| Average (e1,e2)       -> (((eval(e1,x,y)) +. (eval(e2,x,y))) /. (2.0))\n| Times (e1,e2)\t\t-> (eval(e1,x,y)) *. (eval(e2,x,y))\n| ThreeTimes (e1,e2,e3) -> ((eval(e1,x,y)) *. (eval(e2,x,y)) *. (eval(e3,x,y)))\n| Thresh (e1,e2,e3,e4)  -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y))\nelse (eval(e4,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,8) with\n| 0 -> build(rand,(depth - 1))\n| 1 -> buildSine(build(rand,(depth - 1))) \n| 2 -> buildCosine(build(rand, (depth - 1)))\n| 3 -> buildFourth(build(rand, (depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 6 -> buildThreeTimes(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth -1)))\n| _ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,8) with\n| 0 -> build(rand,(depth - 1))\n| 1 -> buildSine(build(rand,(depth - 1))) \n| 2 -> buildCosine(build(rand, (depth - 1)))\n| 99 -> buildFourth(build(rand, (depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 6 -> buildThreeTimes(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth -1)))\n| _ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,8) with\n| 0 -> build(rand,(depth - 1))\n| 1 -> buildSine(build(rand,(depth - 1))) \n| 2 -> buildCosine(build(rand, (depth - 1)))\n| 3 -> buildFourth(build(rand, (depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 6 -> buildHello(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth -1)))\n| _ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"}]}
