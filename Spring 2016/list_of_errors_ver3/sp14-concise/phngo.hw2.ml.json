{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = failwith \"to be written\"", "out": "", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> (match h with | (s,i) -> s);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> i", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> (match h with | (s,i) -> i);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> (match h with | (s,i) -> d);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written 1\" in\nlet rest' = failwith \"to be written 2\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written 1\" in\n        let rest' = failwith \"to be written 2\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match b with\n| (f', b') -> if b' then wwhile (f, f')\nelse f'", "out": "Characters 72-74:\n  | (f', b') -> if b' then wwhile (f, f')\n                                      ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match b with | (f',b') -> if b' then wwhile (f, f') else f';;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match (f b) with\n| (f', x') -> if x' then wwhile (f, f')\nelse f'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (f',x') -> if x' then wwhile (f, f') else f';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (f',x') -> if x' then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (f',x') -> if x' then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match me b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "out": "Characters 29-31:\n  let rec wwhile (f,b) = match me b with\n                               ^^\nError: Unbound value me\n", "min": "\nlet rec wwhile (f,b) =\n  match me b with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f,b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let me x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (me, 2)", "out": "Characters 55-57:\n  wwhile (me, 2);;\n          ^^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let me x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (me, 2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 3);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 1)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((if f b = b && f (f x) then f b else fixpoint (f,f b)),b)", "out": "Error: Unbound value x\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 49-50:\n  let fixpoint (f,b) = wwhile ((if f b = b && f (f x) then f b else fixpoint (f,f b)),b);;\n                                                   ^\nError: Unbound value x\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f x)) then f b else fixpoint (f, (f b))), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((if f b = b && f (f b) then f b else fixpoint (f,f b)),b)", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 57-60:\n  let fixpoint (f,b) = wwhile ((if f b = b && f (f b) then f b else fixpoint (f,f b)),b);;\n                                                           ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f b)) then f b else fixpoint (f, (f b))), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((if f b = b && f (f b) then (f b) else fixpoint (f,f b)),b)", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 57-62:\n  let fixpoint (f,b) = wwhile ((if f b = b && f (f b) then (f b) else fixpoint (f,f b)),b);;\n                                                           ^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f b)) then f b else fixpoint (f, (f b))), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper,b)", "out": "Characters 94-100:\n  let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper,b);;\n                                                                                                ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b)", "out": "Characters 94-100:\n  let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b);;\n                                                                                                ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true)\nelse (f b, false)\nin helper,b)", "out": "Characters 94-100:\n  in helper,b);;\n     ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match (f b) with\n| (b',c') -> if c' then wwhile (f,b')\nelse b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper b = if b = (f b) then ((f b), false) else ((f b), true) in\n      helper), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper b = if b = (f b) then ((f b), false) else ((f b), true) in\n      helper), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nfixpoint (f, 1)", "out": "Characters 56-57:\n  fixpoint (f, 1);;\n            ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type int -> int\n       Type int * bool is not compatible with type int \n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper b = if b = (f b) then ((f b), false) else ((f b), true) in\n      helper), b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in fixpoint (f, 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper b = if b = (f b) then ((f b), false) else ((f b), true) in\n      helper), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi*\" ^ (exprToString e) ^ \")\"\n| Cosine e -> \"cos(pi*\" ^ (exprToString e) ^ \")\"\n| Average (e1,e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")/2)\"\n| Times (e1,e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1,e2,e3,e4) -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^\n(exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\nVarX\t\t      -> \"x\"\n| VarY\t\t\t-> \"y\"\n| Sine e\t\t-> \"sin(pi*\" ^ (exprToString e) ^ \")\"\n| Cosine e\t\t-> \"cos(pi*\" ^ (exprToString e) ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")/2)\"\n| Times (e1,e2)\t        -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^\n(exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. (eval(e,x,y)))\n| Cosine e -> cos(pi *. (eval(e,x,y)))\n| Average (e1,e2) -> (((eval(e1,x,y)) +. (eval(e2,x,y))) /. (2.0))\n| Times (e1,e2) -> (eval(e1,x,y)) *. (eval(e2,x,y))\n| Thresh (e1,e2,e3,e4) -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y)) else (eval(e4,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. (eval(e,x,y)))\n| Cosine e -> cos(pi *. (eval(e,x,y)))\n| Average (e1,e2) -> (((eval(e1,x,y)) +. (eval(e2,x,y))) /. (2.0))\n| Times (e1,e2) -> (eval(e1,x,y)) *. (eval(e2,x,y))\n| Thresh (e1,e2,e3,e4) -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y))\nelse (eval(e4,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,7) with\n|0 -> build(rand, (depth-1))\n|1 -> buildSine(build(rand, (depth-1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))\n|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))\n|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))\n|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))\n|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))", "out": "Error: Unbound value buildMax\nHint: Did you mean build, buildY or buildX?\nError: Unbound value buildMax\nHint: Did you mean build, buildX or buildY?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 369-377:\n  |5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))\n        ^^^^^^^^\nError: Unbound value buildMax\nHint: Did you mean build, buildY or buildX?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 7) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildMax ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildCubic\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,5) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 5) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 6) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|_ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 6) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 6) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match (f b) with\n| (b',c') -> if c' then wwhile (f,b')\nelse b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper b = if b = (f b) then ((f b), false) else ((f b), true) in\n      helper), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|_ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 6) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Divide   of expr * expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Custom2  of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Divide of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Custom2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Divide   of expr * expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Hello    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Divide of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\nVarX\t\t      -> x\n| VarY\t\t\t-> y\n| Sine e\t\t-> sin(pi *. (eval(e,x,y)))\n| Cosine e\t\t-> cos(pi *. (eval(e,x,y)))\n| Average (e1,e2)       -> (((eval(e1,x,y)) +. (eval(e2,x,y))) /. (2.0))\n| Times (e1,e2)\t\t-> (eval(e1,x,y)) *. (eval(e2,x,y))\n| Hello1 (e1,e2,e3)     -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y))\nelse (eval(e1,x,y)))\n| Thresh (e1,e2,e3,e4)  -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y))\nelse (eval(e4,x,y)))\n| Hello2 (e1,e2,e3,e4)  -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e4,x,y))\nelse (eval(e3,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello1 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Hello2 of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Hello1 (e1,e2,e3) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e1, x, y)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Hello2 (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e4, x, y)\n      else eval (e3, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine        of expr\n| Cosine      of expr\n| Fourth      of expr\n| Average     of expr * expr\n| Times       of expr * expr\n| ThreeTimes  of expr * expr * expr\n| Thresh      of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ThreeTimes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ThreeTimes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ThreeTimes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\nVarX\t\t      -> x\n| VarY\t\t\t-> y\n| Sine e\t\t-> sin(pi *. (eval(e,x,y)))\n| Cosine e\t\t-> cos(pi *. (eval(e,x,y)))\n| Fourth e\t\t-> ((eval(e,x,y)) /. (4.0))\n| Average (e1,e2)       -> (((eval(e1,x,y)) +. (eval(e2,x,y))) /. (2.0))\n| Times (e1,e2)\t\t-> (eval(e1,x,y)) *. (eval(e2,x,y))\n| ThreeTimes (e1,e2,e3) -> ((eval(e1,x,y)) *. (eval(e2,x,y)) *. (eval(e3,x,y)))\n| Thresh (e1,e2,e3,e4)  -> (if (eval(e1,x,y)) < (eval(e2,x,y)) then (eval(e3,x,y))\nelse (eval(e4,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ThreeTimes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Fourth e -> (eval (e, x, y)) /. 4.0\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | ThreeTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,8) with\n| 0 -> build(rand,(depth - 1))\n| 1 -> buildSine(build(rand,(depth - 1))) \n| 2 -> buildCosine(build(rand, (depth - 1)))\n| 3 -> buildFourth(build(rand, (depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 6 -> buildThreeTimes(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth -1)))\n| _ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ThreeTimes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFourth e = Fourth e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThreeTimes (e1,e2,e3) = ThreeTimes (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 8) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildFourth (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThreeTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,8) with\n| 0 -> build(rand,(depth - 1))\n| 1 -> buildSine(build(rand,(depth - 1))) \n| 2 -> buildCosine(build(rand, (depth - 1)))\n| 99 -> buildFourth(build(rand, (depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 6 -> buildThreeTimes(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth -1)))\n| _ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ThreeTimes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFourth e = Fourth e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThreeTimes (e1,e2,e3) = ThreeTimes (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 8) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 99 -> buildFourth (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThreeTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,2) = 0 then buildX()\nelse buildY()\nelse match rand(0,8) with\n| 0 -> build(rand,(depth - 1))\n| 1 -> buildSine(build(rand,(depth - 1))) \n| 2 -> buildCosine(build(rand, (depth - 1)))\n| 3 -> buildFourth(build(rand, (depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n| 6 -> buildHello(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth -1)))\n| _ -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFourth e = Fourth e;;\n\nlet buildHello (e1,e2,e3) = Hello (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 8) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildFourth (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildHello\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,i) -> if s = k then i else assoc (d, k, t));;\n", "type": ""}]}
