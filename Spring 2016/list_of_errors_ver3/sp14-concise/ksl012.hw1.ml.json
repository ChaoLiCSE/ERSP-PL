{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch 1 with\n| [] -> 0\n| h::t -> h+sumList t", "out": "Characters 37-39:\n  | [] -> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch 1 with\n| [] -> 0\n| h::t -> h+sumList t", "out": "Characters 37-39:\n  | [] -> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch 1 with\n| []-> 0\n| h::t -> h+sumList t", "out": "Characters 37-39:\n  | []-> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": "other"}, {"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| []-> 1\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 1 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| []-> 1\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 1 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| []-> 2\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 2 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif( h % 2) = 0 \nthen [] \nelse tail", "out": "Characters 31-32:\n  if( h % 2) = 0 \n        ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n = if (h % 2) = 0 then [] else tail;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif( h mod 2) = 0 \nthen [] \nelse tail", "out": "Characters 29-30:\n  if( h mod 2) = 0 \n      ^\nError: Unbound value h\n", "min": "\nlet rec digitsOfInt n = if (h mod 2) = 0 then [] else tail;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif( head mod 2) = 0 \nthen [] \nelse tail", "out": "Characters 29-33:\n  if( head mod 2) = 0 \n      ^^^^\nError: Unbound value head\n", "min": "\nlet rec digitsOfInt n = if (head mod 2) = 0 then [] else tail;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif( hd mod 2) = 0 \nthen [] \nelse tl", "out": "Characters 29-31:\n  if( hd mod 2) = 0 \n      ^^\nError: Unbound value hd\n", "min": "\nlet rec digitsOfInt n = if (hd mod 2) = 0 then [] else tl;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n < 0) then []", "out": "Characters 41-43:\n  if (n < 0) then [];;\n                  ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n| [] -> []\n| h::t -> if (n < 0) then []", "out": "Characters 66-67:\n  | h::t -> if (n < 0) then [];;\n                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = match n with | [] -> [] | h::t -> if n < 0 then [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n| [] -> []\n| _ -> if n < 0 then []", "out": "Characters 62-63:\n  | _ -> if n < 0 then [];;\n                ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = match n with | [] -> [] | _ -> if n < 0 then [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n| _ -> if n < 0 then []", "out": "Characters 58-60:\n  | _ -> if n < 0 then [];;\n                       ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = match n with | _ -> if n < 0 then [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n < 0 with\n| true -> []", "out": "", "min": "\nlet rec digitsOfInt n = match n < 0 with | true  -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = match n < 0 with\n| true -> []", "out": "", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = match n < 0 with\n| true -> []\n| false -> [0]", "out": "", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [0];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = match n < 0 with\n| true -> []\n| false -> [0,1]", "out": "", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nif n < 0 \nthen []\nelse digitsOfInt (n mod 10) :: []", "out": "", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n mod 10)", "out": "Characters 71-93:\n  digitsOfInt (n mod 10);;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list list\n       but an expression was expected of type int list\n       Type (int * int) list is not compatible with type int \n", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n / 10)", "out": "Characters 71-91:\n  digitsOfInt (n / 10);;\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list list\n       but an expression was expected of type int list\n       Type (int * int) list is not compatible with type int \n", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n/10)::[]", "out": "", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "out": "", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]", "out": "Characters 66-76:\n  digitsOfInt (n/10) @ (n mod 10)::[];;\n                       ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         (int * int) list list list list list\n", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) ::[]", "out": "Characters 49-67:\n  digitsOfInt (n/10) ::[];;\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10)::[]", "out": "Characters 49-67:\n  digitsOfInt (n/10)::[];;\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "out": "Characters 49-71:\n  digitsOfInt (n mod 10)::[];;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]::[]", "out": "Characters 49-71:\n  digitsOfInt (n mod 10)::[]::[];;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10); []];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "out": "Characters 68-90:\n  digitsOfInt (n mod 10)::[];;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt n mod 10::[]", "out": "Characters 68-81:\n  digitsOfInt n mod 10::[];;\n  ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else [(digitsOfInt n) mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: []", "out": "Characters 68-90:\n  digitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: [];;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else [digitsOfInt (n mod 10); digitsOfInt (n / 10)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [num]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []", "out": "Characters 84-87:\n  then [num]\n        ^^^\nError: Unbound value num\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [num] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\nn mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else if n < 10 then [n] else [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nn mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [] else [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nn mod 10 :: myList", "out": "", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: [] :: digitsOfInt (n / 10)", "out": "Characters 61-63:\n  n mod 10 :: [] :: digitsOfInt (n / 10);;\n              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt (n / 10) :: []", "out": "Characters 61-81:\n  n mod 10 :: digitsOfInt (n / 10) :: [];;\n              ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: [digitsOfInt (n / 10)] :: []", "out": "Characters 61-83:\n  n mod 10 :: [digitsOfInt (n / 10)] :: [];;\n              ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; [digitsOfInt (n / 10)]];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n / 10) :: []", "out": "Characters 49-68:\n  digitsOfInt(n / 10) :: [];;\n  ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\n( digitsOfInt(n / 10), n mod 10) :: []", "out": "Characters 51-70:\n  ( digitsOfInt(n / 10), n mod 10) :: [];;\n    ^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [((digitsOfInt (n / 10)), (n mod 10))];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: [] :: digitsOfInt( n / 10)", "out": "Characters 61-63:\n  n mod 10 :: [] :: digitsOfInt( n / 10);;\n              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 100 :: []", "out": "", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 100];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n / 10) @ n mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n / 10) @ n mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen [0]\nelse\ndigitsOfInt(n / 10) @ n mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [0] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n / 10) @ n mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n|0 -> []\n|_ -> n mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | _ -> [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n|0 -> []\n|_ -> (n mod 10 :: [], digitsOfInt( n /10))", "out": "Characters 52-89:\n  |_ -> (n mod 10 :: [], digitsOfInt( n /10));;\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> ([n mod 10], (digitsOfInt (n / 10)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n|0 -> []\n|_ -> n mod 10 :: [digitsOfInt(n/10)]", "out": "Characters 65-82:\n  |_ -> n mod 10 :: [digitsOfInt(n/10)];;\n                     ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> [n mod 10; digitsOfInt (n / 10)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n|0 -> []\n|_ -> digitsOfInt(n/10) :: [n mod 10]", "out": "Characters 52-69:\n  |_ -> digitsOfInt(n/10) :: [n mod 10];;\n        ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> [digitsOfInt (n / 10); n mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt(n/10);", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l;\n|h::t -> listReverse(h::l)", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse (h :: l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: h", "out": "Characters 57-71:\n  |h::t -> listReverse(t) :: h;;\n           ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l", "out": "Characters 57-71:\n  |h::t -> listReverse(t) :: l;;\n           ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t)", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l", "out": "Characters 57-71:\n  |h::t -> listReverse(t) :: l;;\n           ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h :: listReverse(t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: [h]", "out": "Characters 57-71:\n  |h::t -> listReverse(t) :: [h];;\n           ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h :: listReverse(t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt(n/10);", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::l listReverse(t)", "out": "Characters 60-61:\n  |h::t -> h::l listReverse(t);;\n              ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (l listReverse t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h:: listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::l listReverse t", "out": "Characters 60-61:\n  |h::t -> h::l listReverse t;;\n              ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (l listReverse t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ h", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ []", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t :: [h]", "out": "Characters 57-70:\n  |h::t -> listReverse t :: [h];;\n           ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l;\n|h::t -> listReverse(h::l)", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse (h :: l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l;\n|h::t -> listReverse(h::l) t", "out": "Characters 56-67:\n  |h::t -> listReverse(h::l) t;;\n           ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> listReverse (h :: l) t;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt(n/10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l;\n|h::t -> listReverse(h::t)", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse (h :: t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(h::t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (h :: t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::t", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> h :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::[2;2]", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [h; 2; 2];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h:: [listReverse t]", "out": "Characters 62-75:\n  |h::t -> h:: [listReverse t];;\n                ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [h; listReverse t];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t :: [h]", "out": "Characters 57-70:\n  |h::t -> listReverse t :: [h];;\n           ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [h];\n|h::t -> listReverse t :: [h]", "out": "Characters 45-46:\n  |[] -> [h];\n          ^\nError: Unbound value h\n", "min": "\nlet rec listReverse l = match l with | [] -> [h] | h::t -> [listReverse t; h];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [l];\n|h::t -> listReverse t :: [h]", "out": "Characters 58-71:\n  |h::t -> listReverse t :: [h];;\n           ^^^^^^^^^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [l] | h::t -> [listReverse t; h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [l];\n|h::t -> h :: listReverse t", "out": "Characters 58-59:\n  |h::t -> h :: listReverse t;;\n           ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [l] | h::t -> h :: (listReverse t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> [l];\n|h::t -> [h] :: listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [l] | h::t -> [h] :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|h::t -> [h] :: listReverse t\n|[] -> [l]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | h::t -> [h] :: (listReverse t) | [] -> [l];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|h::t -> h :: listReverse t\n|[] -> []", "out": "", "min": "\nlet rec listReverse l =\n  match l with | h::t -> h :: (listReverse t) | [] -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|h::t -> h :: l listReverse t\n|[] -> []", "out": "Characters 51-52:\n  |h::t -> h :: l listReverse t\n                ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec listReverse l =\n  match l with | h::t -> h :: (l listReverse t) | [] -> [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|h::t -> h :: l listReverse t\n|[] -> l", "out": "Characters 51-52:\n  |h::t -> h :: l listReverse t\n                ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec listReverse l =\n  match l with | h::t -> h :: (l listReverse t) | [] -> l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h::listReverse t", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h::listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h @ listReverse t", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> h @ (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ h", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ l", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t :: [h]", "out": "Characters 56-69:\n  |h::t -> listReverse t :: [h];;\n           ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t.hd :: [h]", "out": "Characters 70-72:\n  |h::t -> listReverse t.hd :: [h];;\n                         ^^\nError: Unbound record field hd\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> [listReverse t.hd; h];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h::listReverse l", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h :: (listReverse l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h::listReverse t", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h", "out": "Characters 55-56:\n  |h::t -> h;;\n           ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h", "out": "Characters 55-56:\n  |h::t -> h;;\n           ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> [h]", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = failwith \"TBD\"", "out": "", "min": "\nlet rec additivePersistence n = failwith \"TBD\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> listReverse t\n|h::t -> h::l", "out": "Characters 56-57:\n  |[] -> listReverse t\n                     ^\nError: Unbound value t\n", "min": "\nlet rec listReverse l = match l with | [] -> listReverse t | h::t -> h :: l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> listReverse []\n|h::t -> h::l", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> listReverse [] | h::t -> h :: l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h::l", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> h :: l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse (n mod 10 :: digitsOfInt(n/10))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse n mod 10 :: listReverse(digitsOfInt(n/10))", "out": "Characters 61-62:\n  listReverse n mod 10 :: listReverse(digitsOfInt(n/10));;\n              ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else ((listReverse n) mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: listReverse digitsOfInt(n/10)", "out": "Characters 61-72:\n  n mod 10 :: listReverse digitsOfInt(n/10);;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse digitsOfInt (n / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: listReverse(digitsOfInt(n/10))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen listReverse []\nelse\nn mod 10 :: listReverse(digitsOfInt(n/10))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then listReverse []\n  else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen  []\nelse\nn mod 10 :: listReverse(digitsOfInt(n/10))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen  []\nelse if n > 9\nthen n mod 10 :: digitsOfInt(n/10)", "out": "Characters 73-75:\n  then n mod 10 :: digitsOfInt(n/10);;\n                ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else if n > 9 then (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: listReverse digitsOfInt(n/10)", "out": "Characters 61-72:\n  n mod 10 :: listReverse digitsOfInt(n/10);;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse digitsOfInt (n / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: listReverse(digitsOfInt(n/10))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse(n mod 10 :: digitsOfInt(n/10))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse(n mod 10 :: listReverse(digitsOfInt(n/10)))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \ndigitsOfInt(n)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec additivePersistence n = digitsOfInt n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nsumList(digitsOfInt(n))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen 1", "out": "Characters 69-70:\n  then 1;;\n       ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if (sumList (digitsOfInt n)) > 9 then 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen 2", "out": "Characters 69-70:\n  then 2;;\n       ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if (sumList (digitsOfInt n)) > 9 then 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen 20", "out": "Characters 69-71:\n  then 20;;\n       ^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if (sumList (digitsOfInt n)) > 9 then 20;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(n))", "out": "Characters 69-92:\n  then sumList(digitsOfInt(n));;\n       ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then sumList (digitsOfInt n);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList [1;2]", "out": "Characters 69-82:\n  then sumList [1;2];;\n       ^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then sumList [1; 2];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen 0\nelse 1", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then 0 else 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(n))\nelse 1", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then sumList (digitsOfInt n) else 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(sumList(digitsOfInt(digitsOfInt(n))))\nelse 1", "out": "Characters 96-112:\n  then sumList(sumList(digitsOfInt(digitsOfInt(n))))\n                                  ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (sumList (digitsOfInt (digitsOfInt n)))\n  else 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 1", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)))\n  else 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 1", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)))\n  else 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 1", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)))\n  else 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))", "out": "Characters 61-106:\n  then sumList(digitsOfInt(sumList(digitsOfInt(n))));;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 0", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)))\n  else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse n", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)))\n  else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse n", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n > 9 then sumList (digitsOfInt (sumList (digitsOfInt n))) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 1", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then sumList (digitsOfInt (sumList (digitsOfInt n))) else 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = failwith \"tbd\"", "out": "", "min": "\nlet additivePersistence n = failwith \"tbd\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse n", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n > 9 then sumList (digitsOfInt (sumList (digitsOfInt n))) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif listReverse explode w  = explode w \nthen true\nelse false", "out": "Characters 23-34:\n  if listReverse explode w  = explode w \n     ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif listReverse(explode w)  = explode w \nthen true\nelse false", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (sumList(digitsOfInt(n)) + 1)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then additivePersistence ((sumList (digitsOfInt n)) + 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (sumList(digitsOfInt(n)) + 1)\nelse 0", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then additivePersistence ((sumList (digitsOfInt n)) + 1) else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (1 + sumList(digitsOfInt(n)))\nelse 0", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then additivePersistence (1 + (sumList (digitsOfInt n))) else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif (n > 9) then (1 + additivePersistence (sumList(digitsOfInt(n)))) else 0", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then 1 + (additivePersistence (sumList (digitsOfInt n))) else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (sumList(digitsOfInt(n))) + 1\nelse 0", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then (additivePersistence (sumList (digitsOfInt n))) + 1 else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n > 9\nthen digitalRoot(sumList(digitsOfInt n))\n(*then sumList(digitsOfInt(sumList(digitsOfInt(n)))) *)\nelse n", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n > 9 then digitalRoot (sumList (digitsOfInt n)) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence sumList(digitsOfInt(n)) + 1\nelse 0", "out": "Characters 66-73:\n  then additivePersistence sumList(digitsOfInt(n)) + 1\n                           ^^^^^^^\nError: This expression has type int list -> int\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then (additivePersistence sumList (digitsOfInt n)) + 1 else 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (sumList(digitsOfInt(n))) + 1\nelse 0", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then (additivePersistence (sumList (digitsOfInt n))) + 1 else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n > 9\nthen digitalRoot(sumList(digitsOfInt n))\nelse n", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n > 9 then digitalRoot (sumList (digitsOfInt n)) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence(sumList(digitsOfInt(n))) + 1\nelse 0", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then (additivePersistence (sumList (digitsOfInt n))) + 1 else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse (listreverse t)", "out": "Characters 69-80:\n  |h::t -> listReverse (listreverse t);;\n                        ^^^^^^^^^^^\nError: Unbound value listreverse\nHint: Did you mean listReverse?\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (listreverse t);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse (listReverse t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h:: listReverse (listReverse t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse (listReverse t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h:: listReverse (listReverse h)", "out": "Characters 85-86:\n  |h::t -> h:: listReverse (listReverse h);;\n                                        ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse (listReverse h));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h:: listReverse (listReverse l)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse (listReverse l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h:: listReverse (listReverse l)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> h :: (listReverse (listReverse l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h:: listReverse (listReverse t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> h :: (listReverse (listReverse t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h :: listReverse (t)", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> listReverse(l)\n|h::t -> h :: listReverse (t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> listReverse l | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> listReverse(l)\n|h::t -> h :: listReverse (t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> listReverse l | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append listReverse(t) [h]", "out": "Characters 56-62:\n  |h::t -> append listReverse(t) [h];;\n           ^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append (listReverse(t) [h])", "out": "Characters 64-75:\n  |h::t -> append (listReverse(t) [h]);;\n                   ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t [h]);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse(t) @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t), [h])", "out": "Characters 62-83:\n  |h::t -> append(listReverse(t), [h]);;\n                 ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append ((listReverse t), [h]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t) [h])", "out": "Characters 63-74:\n  |h::t -> append(listReverse(t) [h]);;\n                  ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t [h]);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t) ; [h])", "out": "Characters 56-84:\n  |h::t -> append(listReverse(t) ; [h]);;\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t; [h]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append listReverse(t) [h]", "out": "Characters 56-62:\n  |h::t -> append listReverse(t) [h];;\n           ^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append [h] [h]", "out": "", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append [h] [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append t [h]", "out": "", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append t [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append listReverse(t) [h]", "out": "Characters 56-62:\n  |h::t -> append listReverse(t) [h];;\n           ^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n(*|h::t -> append listReverse(t) [h]*)\n|h::t -> listReverse(t) @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t)) [h]", "out": "", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t)) [h]", "out": "", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse(n mod 10 :: listReverse(digitsOfInt(n/10)))", "out": "", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n > 9\nthen digitalRoot(sumList(digitsOfInt n))\nelse n", "out": "", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n > 9 then digitalRoot (sumList (digitsOfInt n)) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n|[]    -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence(sumList(digitsOfInt(n))) + 1\nelse 0", "out": "", "min": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then (additivePersistence (sumList (digitsOfInt n))) + 1 else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n|[]    -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
