{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-39:\n  | [] -> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = \nmatch 1 with\n| [] -> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-39:\n  | [] -> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = \nmatch 1 with\n| [] -> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-39:\n  | []-> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = \nmatch 1 with\n| []-> 0\n| h::t -> h+sumList t"}, {"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| []-> 1\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| []-> 1\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| []-> 2\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 31-32:\n  if( h % 2) = 0 \n        ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n = if (h % 2) = 0 then [] else tail;;\n", "in": "let rec digitsOfInt n = \nif( h % 2) = 0 \nthen [] \nelse tail"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-30:\n  if( h mod 2) = 0 \n      ^\nError: Unbound value h\n", "min": "\nlet rec digitsOfInt n = if (h mod 2) = 0 then [] else tail;;\n", "in": "let rec digitsOfInt n = \nif( h mod 2) = 0 \nthen [] \nelse tail"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-33:\n  if( head mod 2) = 0 \n      ^^^^\nError: Unbound value head\n", "min": "\nlet rec digitsOfInt n = if (head mod 2) = 0 then [] else tail;;\n", "in": "let rec digitsOfInt n = \nif( head mod 2) = 0 \nthen [] \nelse tail"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-31:\n  if( hd mod 2) = 0 \n      ^^\nError: Unbound value hd\n", "min": "\nlet rec digitsOfInt n = if (hd mod 2) = 0 then [] else tl;;\n", "in": "let rec digitsOfInt n = \nif( hd mod 2) = 0 \nthen [] \nelse tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 41-43:\n  if (n < 0) then [];;\n                  ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "in": "let rec digitsOfInt n = \nif (n < 0) then []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-67:\n  | h::t -> if (n < 0) then [];;\n                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = match n with | [] -> [] | h::t -> if n < 0 then [];;\n", "in": "let rec digitsOfInt n = match n with\n| [] -> []\n| h::t -> if (n < 0) then []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-63:\n  | _ -> if n < 0 then [];;\n                ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = match n with | [] -> [] | _ -> if n < 0 then [];;\n", "in": "let rec digitsOfInt n = match n with\n| [] -> []\n| _ -> if n < 0 then []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-60:\n  | _ -> if n < 0 then [];;\n                       ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = match n with | _ -> if n < 0 then [];;\n", "in": "let rec digitsOfInt n = match n with\n| _ -> if n < 0 then []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = match n < 0 with\n| true -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = match n < 0 with\n| true -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = match n < 0 with\n| true -> []\n| false -> [0]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = match n < 0 with\n| true -> []\n| false -> [0,1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 \nthen []\nelse digitsOfInt (n mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-93:\n  digitsOfInt (n mod 10);;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list list\n       but an expression was expected of type int list\n       Type (int * int) list is not compatible with type int \n", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;\n", "in": "let digitsOfInt n = \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-91:\n  digitsOfInt (n / 10);;\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list list\n       but an expression was expected of type int list\n       Type (int * int) list is not compatible with type int \n", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;\n", "in": "let digitsOfInt n = \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n / 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n/10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-76:\n  digitsOfInt (n/10) @ (n mod 10)::[];;\n                       ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         (int * int) list list list list list\n", "min": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "in": "let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-67:\n  digitsOfInt (n/10) ::[];;\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) ::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-67:\n  digitsOfInt (n/10)::[];;\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-71:\n  digitsOfInt (n mod 10)::[];;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-71:\n  digitsOfInt (n mod 10)::[]::[];;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10); []];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-90:\n  digitsOfInt (n mod 10)::[];;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-81:\n  digitsOfInt n mod 10::[];;\n  ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else [(digitsOfInt n) mod 10];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt n mod 10::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-90:\n  digitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: [];;\n  ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else [digitsOfInt (n mod 10); digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-87:\n  then [num]\n        ^^^\nError: Unbound value num\n", "min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [num] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [num]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\nn mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nn mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nn mod 10 :: myList"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-63:\n  n mod 10 :: [] :: digitsOfInt (n / 10);;\n              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: [] :: digitsOfInt (n / 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-81:\n  n mod 10 :: digitsOfInt (n / 10) :: [];;\n              ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt (n / 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-83:\n  n mod 10 :: [digitsOfInt (n / 10)] :: [];;\n              ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; [digitsOfInt (n / 10)]];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: [digitsOfInt (n / 10)] :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-68:\n  digitsOfInt(n / 10) :: [];;\n  ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n / 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 51-70:\n  ( digitsOfInt(n / 10), n mod 10) :: [];;\n    ^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [((digitsOfInt (n / 10)), (n mod 10))];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\n( digitsOfInt(n / 10), n mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-63:\n  n mod 10 :: [] :: digitsOfInt( n / 10);;\n              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: [] :: digitsOfInt( n / 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 100 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n / 10) @ n mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n / 10) @ n mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen [0]\nelse\ndigitsOfInt(n / 10) @ n mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n / 10) @ n mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = match n with\n|0 -> []\n|_ -> n mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 52-89:\n  |_ -> (n mod 10 :: [], digitsOfInt( n /10));;\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> ([n mod 10], (digitsOfInt (n / 10)));;\n", "in": "let rec digitsOfInt n = match n with\n|0 -> []\n|_ -> (n mod 10 :: [], digitsOfInt( n /10))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-82:\n  |_ -> n mod 10 :: [digitsOfInt(n/10)];;\n                     ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> [n mod 10; digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = match n with\n|0 -> []\n|_ -> n mod 10 :: [digitsOfInt(n/10)]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 52-69:\n  |_ -> digitsOfInt(n/10) :: [n mod 10];;\n        ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n = match n with\n|0 -> []\n|_ -> digitsOfInt(n/10) :: [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt(n/10);"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l;\n|h::t -> listReverse(h::l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: h"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = listReverse [1; 2; 3; 4];;\n          ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = listReverse [1; 2; 3; 4];;\n          ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h :: listReverse(t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h :: listReverse(t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|listReverse(t):: h;"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = digitsOfInt 3124;;\n          ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt(n/10);"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::l listReverse(t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::[] listReverse(t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h:: listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::l listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::listReverse(t) -> h::l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::listReverse t -> h::l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t :: [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l;\n|h::t -> listReverse(h::l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l;\n|h::t -> listReverse(h::l) t"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = listReverse [1; 2; 3; 4];;\n          ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l;\n|h::t -> listReverse(h::t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(h::t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h::[2;2]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [h; 2; 2];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h:: [listReverse t]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t :: [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [h];\n|h::t -> listReverse t :: [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [l];\n|h::t -> listReverse t :: [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [l];\n|h::t -> h :: listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> [l];\n|h::t -> [h] :: listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|h::t -> [h] :: listReverse t\n|[] -> [l]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|h::t -> h :: listReverse t\n|[] -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|h::t -> h :: l listReverse t\n|[] -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|h::t -> h :: l listReverse t\n|[] -> l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h::listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h::listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h @ listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> h @ (listReverse t);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t :: [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t.hd :: [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h::listReverse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h::listReverse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = failwith \"TBD\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> listReverse t\n|h::t -> h::l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> listReverse []\n|h::t -> h::l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h::l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlet _ = n mod 10 :: digitsOfInt(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlet _ = n mod 10 :: digitsOfInt(n/10) in\nlistReverse _"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse (n mod 10 :: digitsOfInt(n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse n mod 10 :: listReverse(digitsOfInt(n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: listReverse digitsOfInt(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: listReverse(digitsOfInt(n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen listReverse []\nelse\nn mod 10 :: listReverse(digitsOfInt(n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen  []\nelse\nn mod 10 :: listReverse(digitsOfInt(n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen  []\nelse if n > 9\nn mod 10 :: digitsOfInt(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen  []\nelse if n > 9\nthen n mod 10 :: digitsOfInt(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: listReverse digitsOfInt(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: listReverse(digitsOfInt(n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse(n mod 10 :: digitsOfInt(n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse(n mod 10 :: listReverse(digitsOfInt(n/10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \ndigitsOfInt(n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nsumList(digitsOfInt(n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet sumList(digitsOfInt(n)) sum in\nif sum < 10\nthen 5"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen 20"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList [1;2]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen 0\nelse 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(n))\nelse 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(sumList(digitsOfInt(digitsOfInt(n))))\nelse 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif sumList(digitsOfInt(n)) > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet count = 0 in\nlet rec helper n =\nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse count + 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet count = 0 in\nlet rec helper n =\nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse count"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet count = 0 in\nlet rec helper n =\nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet count = 0 in\nlet rec helper n =\nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet count = 0 in\nlet rec helper n =\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet inc = fun x -> x + 1 in\nlet count = 0 in\nlet rec helper n =\nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet inc = fun x -> x + 1 in\nlet count = 0 in\nlet rec helper n =\nif n > 9\nthen 1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = \nlet inc = fun x -> x + 1 in\nlet count = 0 in\nlet rec helper n =\nif n > 9\nthen 1\nelse"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = failwith \"tbd\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n > 9\nthen sumList(digitsOfInt(sumList(digitsOfInt(n))))\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nif listReverse explode w  = explode w \nthen true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nif listReverse(explode w)  = explode w \nthen true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (sumList(digitsOfInt(n)) + 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (sumList(digitsOfInt(n)) + 1)\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (1 + sumList(digitsOfInt(n)))\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n > 9) then (1 + additivePersistence (sumList(digitsOfInt(n)))) else 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (sumList(digitsOfInt(n))) + 1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n > 9\nthen digitalRoot(sumList(digitsOfInt n))\n(*then sumList(digitsOfInt(sumList(digitsOfInt(n)))) *)\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence sumList(digitsOfInt(n)) + 1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence (sumList(digitsOfInt(n))) + 1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n > 9\nthen digitalRoot(sumList(digitsOfInt n)\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n > 9\nthen digitalRoot(sumList(digitsOfInt n))\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence(sumList(digitsOfInt(n))) + 1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse (listreverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse (listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h:: listReverse (listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h:: listReverse (listReverse h)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> h:: listReverse (listReverse l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h:: listReverse (listReverse l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h:: listReverse (listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> l\n|h::t -> h :: listReverse (t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> listReverse(l)\n|h::t -> h :: listReverse (t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> listReverse(l)\n|h::t -> h :: listReverse (t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> \n|h::t -> append t [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append listReverse(t) [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append (listReverse(t) [h])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse(t) @ [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t), [h])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t) [h])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t) ; [h])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append listReverse(t) [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append [h] [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append t [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append listReverse(t) [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n(*|h::t -> append listReverse(t) [h]*)\n|h::t -> listReverse(t) @ [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t)) [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[] -> []\n|h::t -> append(listReverse(t)) [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n|[]-> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nlistReverse(n mod 10 :: listReverse(digitsOfInt(n/10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n > 9\nthen digitalRoot(sumList(digitsOfInt n))\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n|[]    -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n > 9\nthen additivePersistence(sumList(digitsOfInt(n))) + 1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n|[]    -> 0\n| h::t -> h + sumList t"}]}
