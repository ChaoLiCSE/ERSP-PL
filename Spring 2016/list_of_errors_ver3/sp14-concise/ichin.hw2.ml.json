{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = failwith \"to be written\"", "out": "", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = failwith \"to be written\"", "out": "", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nif f b = false then [] \nelse []", "out": "", "min": "\nlet rec wwhile (f,b) = if (f b) = false then [] else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f b')\nelse c'", "out": "Characters 71-77:\n  if c' = true then wwhile (f b')\n                           ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f b') else c';;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = failwith \"to be written\"", "out": "", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse c'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else c';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse c'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else c';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else c';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = failwith \"to be written\"", "out": "", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f (neg b)),b)", "out": "Characters 33-36:\n  let fixpoint (f,b) = wwhile ((f (neg b)),b);;\n                                   ^^^\nError: Unbound value neg\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f (neg b)), b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool -> bool * bool\n       Type int is not compatible with type bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f (not b)), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ( (f b),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ( (f b),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ( (f b) <> b,b)", "out": "Characters 30-40:\n  let fixpoint (f,b) = wwhile ( (f b) <> b,b);;\n                                ^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ( let ans = f b in (ans, ans <> b) ,b)", "out": "Characters 47-62:\n  let fixpoint (f,b) = wwhile ( let ans = f b in (ans, ans <> b) ,b);;\n                                                 ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let ans = f b in ((ans, (ans <> b)), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ( let ans = f b in (ans, ans <> b),b)", "out": "Characters 47-62:\n  let fixpoint (f,b) = wwhile ( let ans = f b in (ans, ans <> b),b);;\n                                                 ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let ans = f b in ((ans, (ans <> b)), b));;\n", "type": "type"}, {"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> VarX\n| VarY -> VarY\n| Sine (e1) -> exprToString e1\n| Cosine (e1) -> exprToString e1\n| Average (e1, e2) -> exprToString e1 ^ exprToString e2\n| Times (e1, e2) -> exprToString e1 ^ exprToString e2\n|Thresh (e1, e2, e3, e4) -> exprToString e1 ^ exprToString e2 ^ exprToString e3 ^ exprToString e4", "out": "Characters 155-170:\n  | Average (e1, e2) -> exprToString e1 ^ exprToString e2\n                        ^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"\"\n| VarY -> \"\"\n| Sine (e1) -> exprToString e1\n| Cosine (e1) -> exprToString e1\n| Average (e1, e2) -> exprToString e1 ^ exprToString e2\n| Times (e1, e2) -> exprToString e1 ^ exprToString e2\n|Thresh (e1, e2, e3, e4) -> exprToString e1 ^ exprToString e2 ^ exprToString e3 ^ exprToString e4", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\"\n  | VarY  -> \"\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY ->  \"y\"\n| Sine (e1) -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine (e1) -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1, e2) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2\"\n| Times (e1, e2) -> \"Times\" ^ exprToString e1 ^ exprToString e2\n|Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ exprToString e2 ^ exprToString e3 ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> \"Times\" ^ ((exprToString e1) ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           ((exprToString e2) ^\n              ((exprToString e3) ^ ((exprToString e4) ^ \")\"))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY ->  \"y\"\n| Sine (e1) -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine (e1) -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1, e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> exprToString e1 ^ \"*\" ^exprToString e2\n|Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ exprToString e2 ^ exprToString e3 ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           ((exprToString e2) ^\n              ((exprToString e3) ^ ((exprToString e4) ^ \")\"))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY ->  \"y\"\n| Sine (e1) -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine (e1) -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1, e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> exprToString e1 ^ \"*\" ^exprToString e2\n|Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| _ -> eval(buildX(), buildY(), y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | _ -> eval ((buildX ()), (buildY ()), y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "eval(Sine(VarX), 1,1)", "out": "Error: This expression has type int but an expression was expected of type\n         expr\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 17-18:\n  eval(Sine(VarX), 1,1);;\n                   ^\nError: This expression has type int but an expression was expected of type\n         expr\n", "min": "\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | _ -> eval ((buildX ()), (buildY ()), y);;\n\nlet _ = eval ((Sine VarX), 1, 1);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| _ -> eval(buildX(), x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | _ -> eval ((buildX ()), x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "eval(Sine(VarX), 11,22)", "out": "", "min": "\nlet buildX () = VarX;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | _ -> eval ((buildX ()), x, y);;\n\nlet _ = eval ((Sine VarX), 11, 22);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi* eval(e1,x,y))", "out": "Characters 78-80:\n  | Sine(e1) -> sin(pi* eval(e1,x,y));;\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "type": "type"}, {"in": "eval(Sine(VarX), 1,22)", "out": "", "min": "\nlet buildX () = VarX;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | _ -> eval ((buildX ()), x, y);;\n\nlet _ = eval ((Sine VarX), 1, 22);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x *. 1.0\n| VarY -> y *. 1.0\n| Sine(e1) -> sin(pi* eval(e1,x,y))", "out": "Characters 92-94:\n  | Sine(e1) -> sin(pi* eval(e1,x,y));;\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x *. 1.0\n  | VarY  -> y *. 1.0\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "type": "type"}, {"in": "eval(Sine(VarX), 1,22)", "out": "", "min": "\nlet buildX () = VarX;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | _ -> eval ((buildX ()), x, y);;\n\nlet _ = eval ((Sine VarX), 1, 22);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> 1.0\n| VarY -> 1.0\n| Sine(e1) -> sin(pi* eval(e1,x,y))", "out": "Characters 82-84:\n  | Sine(e1) -> sin(pi* eval(e1,x,y));;\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0\n  | VarY  -> 1.0\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> 1.0\n| VarY -> 1.0\n| Sine(e1) -> sin(2* eval(e1,x,y))", "out": "Characters 85-97:\n  | Sine(e1) -> sin(2* eval(e1,x,y));;\n                       ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0\n  | VarY  -> 1.0\n  | Sine e1 -> sin (2 * (eval (e1, x, y)));;\n", "type": "type"}, {"in": "eval(Sine(VarX), 1,22)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | _ -> eval ((buildX ()), x, y);;\n\nlet _ = eval ((Sine VarX), 1, 22);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi* eval(e1,x,y))", "out": "Characters 78-80:\n  | Sine(e1) -> sin(pi* eval(e1,x,y));;\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(eval(e1,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi * eval(e1,x,y))", "out": "Characters 78-80:\n  | Sine(e1) -> sin(pi * eval(e1,x,y));;\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "type": "type"}, {"in": "eval(Sine(VarX), 1.0 ,22.0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n\nlet _ = eval ((Sine VarX), 1.0, 22.0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi * eval(e1,x,y))", "out": "Characters 78-80:\n  | Sine(e1) -> sin(pi * eval(e1,x,y));;\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "type": "type"}, {"in": "eval(Sine(VarY), 11.0 ,0)", "out": "Characters 23-24:\n  eval(Sine(VarY), 11.0 ,0);;\n                         ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n\nlet _ = eval ((Sine VarY), 11.0, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(eval(e1,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "eval(Sine(VarY), 11.0 ,0.0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n\nlet _ = eval ((Sine VarY), 11.0, 0.0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "eval(Sine(VarY), 1.0 ,0.0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n\nlet _ = eval ((Sine VarY), 1.0, 0.0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi*eval(e1,x,y))", "out": "Characters 78-80:\n  | Sine(e1) -> sin(pi*eval(e1,x,y));;\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "type": "type"}, {"in": "eval(Sine(VarY), 1.0 ,0.0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n\nlet _ = eval ((Sine VarY), 1.0, 0.0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(a < b) then eval(a_less, x, y)\nelse eval(b_less, x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if a < b then eval (a_less, x, y) else eval (b_less, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(a < b) then begin Printf.snprintf \"hi\"; eval(a_less, x, y); end\nelse eval(b_less, x, y)", "out": "Characters 311-326:\n  if(a < b) then begin Printf.snprintf \"hi\"; eval(a_less, x, y); end\n                       ^^^^^^^^^^^^^^^\nError: Unbound value Printf.snprintf\nHint: Did you mean sprintf?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if a < b\n      then (Printf.snprintf \"hi\"; eval (a_less, x, y))\n      else eval (b_less, x, y);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(a < b) then begin Printf.sprintf \"hi\"; eval(a_less, x, y); end\nelse eval(b_less, x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if a < b\n      then (Printf.sprintf \"hi\"; eval (a_less, x, y))\n      else eval (b_less, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then eval(a_less, x, y)\nelse eval(b_less, x, y);", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(a_less, x, y);\nend", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (a_less, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let x = sin(pi *. eval(e1,x,y)) in Print.sprintf \"sine is %d \" x\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 109-122:\n  | Sine(e1) -> let x = sin(pi *. eval(e1,x,y)) in Print.sprintf \"sine is %d \" x\n                                                   ^^^^^^^^^^^^^\nError: Unbound module Print\nHint: Did you mean Printf?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let x = sin (pi *. (eval (e1, x, y))) in Print.sprintf \"sine is %d \" x\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let x = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %d \" x\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 138-139:\n  | Sine(e1) -> let x = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %d \" x\n                                                                                ^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let x = sin (pi *. (eval (e1, x, y))) in Printf.sprintf \"sine is %d \" x\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %d \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 140-143:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %d \" ans\n                                                                                  ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %d \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 111-143:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" ans\n                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %lf \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 141-144:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %lf \" ans\n                                                                                   ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %lf \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" 2.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 111-143:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" 2.0\n                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is %f \" 2.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 111-142:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is %f \" 2.0\n                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.printf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.fprintf \"sine is %f \" 2.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 126-139:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.fprintf \"sine is %f \" 2.0\n                                                                    ^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         out_channel\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.fprintf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.fprintf \"sine is %f \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 126-139:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.fprintf \"sine is %f \" ans\n                                                                    ^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         out_channel\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.fprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 111-143:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" ans\n                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 111-135:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n                                                     ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.printf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 111-136:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is \"\n                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.sprintf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 111-135:\n  | Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n                                                     ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.printf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "Characters 76-79:\n  | Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n                  ^^^\nError: This expression has type int but an expression was expected of type\n         bool\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      if 1 then (sin (pi *. (eval (e1, x, y))); Printf.printf \"sine is \")\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match rand with\n|_ -> 1.0", "out": "", "min": "\nlet rec build (rand,depth) = match rand with | _ -> 1.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match rand with\n|1 -> 1\n|2 -> 2\n|3->3\n|_ -> 4", "out": "", "min": "\nlet rec build (rand,depth) =\n  match rand with | 1 -> 1 | 2 -> 2 | 3 -> 3 | _ -> 4;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "out": "Characters 37-38:\n  let rec build (rand, depth) = match (r,d)  with\n                                       ^\nError: Unbound value r\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (r, d) with\n  | (_,0) -> if (r mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "out": "Characters 69-70:\n  |(_,0) -> if((r mod 2) == 0) then buildY()\n                ^\nError: Unbound value r\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (r mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "out": "Characters 257-283:\n  | (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build (rand * 3)), (depth - 1)),\n          (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "out": "Characters 257-281:\n  | (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )\n                          ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build rand), (depth - 1)), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n(*| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )*)\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "out": "Characters 300-370:\n  buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )", "out": "Characters 257-281:\n  | (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) );;\n                          ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build rand), (depth - 1)), (build ((rand + 1), (depth - 1))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "out": "Characters 380-450:\n  buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuild(rand + 1, depth - 1)\nelse \nbuild(rand + 1, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine( build(rand + 1, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine(build(rand + 1, depth - 1))\nelse if (depth = 8) then\nbuildCosine(build(rand + 2, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine(build(rand + 1, depth - 1))\nelse if (depth = 8) then\nbuildCosine(build(rand + 2, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = failwith \"to be implemented\"", "out": "", "min": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = failwith \"to be implemented\"", "out": "", "min": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nmatch (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine(build(rand + 1, depth - 1))\nelse if (depth = 8) then\nbuildCosine(build(rand + 2, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX()\n| 1 ->  buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) \nthen \nbegin \nPrintf.printf \"HIIIIIIIII!!!!!!!\";\nbuildSine( build(rand, depth - 1) )\nend\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "Characters 135-170:\n  buildSine( build(rand, depth - 1) )\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.printf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) \nthen \nbegin \nPrintf.printf \"HIIIIIIIII!!!!!!!\";\nbuildSine( build(rand, depth - 1) );\nend\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "Characters 135-171:\n  buildSine( build(rand, depth - 1) );\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.printf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) \nthen \nbegin \nPrintf.sprintf \"HIIIIIIIII!!!!!!!\";\nbuildSine( build(rand, depth - 1) );\nend\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "Characters 136-172:\n  buildSine( build(rand, depth - 1) );\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.sprintf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "Characters 91-126:\n  | 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\n                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> if rand > 1 then buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\nelse buildSine( build(rand + 1, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then buildSine (build (rand, (depth - 1)))\n      else buildSine (build ((rand + 1), (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then buildSine (build (rand, (depth - 1)))\n      else buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(1, 2) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      let x = rand (1, 2) in\n      if x > 1\n      then buildCosine (build (rand, (depth - 1)))\n      else buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build(rand, depth) = match rand with\n| (x,y) -> buildX()\n| (_,_) -> buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with | (x,y) -> buildX () | (_,_) -> buildY ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(1, 2) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      let x = rand (1, 2) in\n      if x > 1\n      then buildCosine (build (rand, (depth - 1)))\n      else buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = 2 in rand(1,z)", "out": "", "min": "\nlet rec build (rand,depth) = match depth with | 0 -> let z = 2 in rand (1, z);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = 2 in rand", "out": "", "min": "\nlet rec build (rand,depth) = match depth with | 0 -> let z = 2 in rand;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in rand", "out": "", "min": "\nlet rec build (rand,depth) = match depth with | 0 -> let z = rand in rand;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in rand in \nif( z > 1) then buildX()\nelse buildY()", "out": "Characters 83-84:\n  if( z > 1) then buildX()\n      ^\nError: Unbound value z\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) = match depth with | 0 -> let z = rand in rand in\n  if z > 1 then buildX () else buildY ();;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))\n| _ -> buildX()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 5) in\n      if num > 3\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | _ -> buildX ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))\n| _ -> buildX()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 5) in\n      if num > 3\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | _ -> buildX ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth) )\nelse buildCosine( build(rand, depth) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, depth))\n      else buildCosine (build (rand, depth))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, depth))\n      else buildCosine (build (rand, depth))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))", "out": "Characters 488-550:\n  | 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)));;\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        (buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))\n| _ -> buildTimes( build(rand, depth), build(rand, depth) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (build (rand, (depth - 1))))\n  | _ -> buildTimes ((build (rand, depth)), (build (rand, depth)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))\n| _ -> buildTimes( build(rand, depth), build(rand, depth) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (build (rand, (depth - 1))))\n  | _ -> buildTimes ((build (rand, depth)), (build (rand, depth)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 5) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> buildTimes( build(rand, depth), build(rand, depth) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 5) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ -> buildTimes ((build (rand, depth)), (build (rand, depth)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 5) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> buildTimes( build(rand, depth - 1), build(rand, depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 5) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 5) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> buildTimes( build(rand, depth - 1), build(rand, depth - 1) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 5) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 5) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 5) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> buildTime(build(rand, depth - 1 ), build(rand, depth - 1))", "out": "Characters 1292-1301:\nError: Unbound value buildTime\nHint: Did you mean buildTimes?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> buildTime ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": "scope"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> buildTimes(build(rand, depth - 1 ), build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> buildTimes(build(rand, depth - 1 ), build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "out": "Characters 1302-1364:\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        (buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(rand, depth - 1))\n\n\n| _ -> build(rand, depth - 1 )", "out": "Characters 1375-1392:\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildTimes(build(rand, depth - 1), buildCosine(rand, depth - 1) ))\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(rand, depth - 1) ))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "out": "Characters 247-264:\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildCosine (rand, (depth - 1)))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildCosine(rand, depth - 1)  )\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(rand, depth - 1) ))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "out": "Characters 212-229:\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (buildCosine (rand, (depth - 1)))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildTimes(build(rand, depth - 1), buildCosine(build(rand, depth - 1) )) )\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(rand, depth - 1) ))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "out": "Characters 337-354:\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1))))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildTimes(build(rand, depth - 1), buildCosine(build(rand, depth - 1) )) )\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(build(rand, depth - 1) )))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1))))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildSine (build (rand, (depth - 1))))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth num )", "out": "Characters 1446-1451:\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> let num = rand (1, 3) in build (rand, (depth num));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth - num )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> let num = rand (1, 3) in build (rand, (depth - num));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth - num )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> let num = rand (1, 3) in build (rand, (depth - num));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n| 9 -> let num = rand(1,7) in\nif(num mod 2 = 0) then \nbuildAverage( buildSine(build(rand, depth - 1)), build(rand, depth - 1))\nelse\nbuildAverage( buildCosine(build(rand, depth - 1)), build(rand, depth - 1))\n\n| _ -> build(rand, depth - num )", "out": "Characters 1636-1639:\nError: Unbound value num\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | 9 ->\n      let num = rand (1, 7) in\n      if (num mod 2) = 0\n      then\n        buildAverage\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildAverage\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - num));;\n", "type": "scope"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> let num = rand (1, 3) in build (rand, (depth - num));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n| 9 -> let num = rand(1,7) in\nif(num mod 2 = 0) then \nbuildAverage( buildSine(build(rand, depth - 1)), build(rand, depth - 1))\nelse\nbuildAverage( buildCosine(build(rand, depth - 1)), build(rand, depth - 1))\n\n| _ -> build(rand, depth - 1 )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | 9 ->\n      let num = rand (1, 7) in\n      if (num mod 2) = 0\n      then\n        buildAverage\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildAverage\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n|_ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n|_ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n|_ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n|_ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 5) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 5) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 7 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 7 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 7 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), buildCosine(build(rand, depth - 1)))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), buildCosine(build(rand, depth - 1)),\nbuildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 7 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))),\n             (buildCosine (build (rand, (depth - 1)))),\n             (buildSine (build (rand, (depth - 1)))),\n             (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 7 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))),\n             (buildCosine (build (rand, (depth - 1)))),\n             (buildSine (build (rand, (depth - 1)))),\n             (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 7 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), buildCosine(build(rand, depth - 1)))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), buildCosine(build(rand, depth - 1)),\nbuildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 7 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))),\n             (buildCosine (build (rand, (depth - 1)))),\n             (buildSine (build (rand, (depth - 1)))),\n             (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 7 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 6) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 6 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 6) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 6 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 6) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildSine(build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 6 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildSine(build(rand, depth - 1))", "out": "Characters 93-99:\n  if( num > 4) then buildX()\n                    ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSine (build (rand, (depth - 1))));;\n", "type": "scope"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine( buildSine(build(rand, depth - 1)))\n| 2 -> buildCosine(buildCosine(build(rand, depth - 1)))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), buildCosine(build(rand, depth - 1)))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildSine(build(rand, depth - 1))", "out": "Characters 93-99:\n  if( num > 4) then buildX()\n                    ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (buildSine (build (rand, (depth - 1))))\n     | 2 -> buildCosine (buildCosine (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSine (build (rand, (depth - 1))));;\n", "type": "scope"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 5) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildSine(build(rand, depth - 1))", "out": "Characters 93-99:\n  if( num > 4) then buildX()\n                    ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 5) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSine (build (rand, (depth - 1))));;\n", "type": "scope"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "Characters 93-99:\n  if( num > 4) then buildX()\n                    ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": "scope"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "Characters 49-57:\n  let g = makeRand (seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n", "min": "\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}, {"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}, {"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}, {"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}, {"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Percent  of expr\n| Negate   of expr\n| SumSquared of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then eval(a_less, x, y)\nelse eval(b_less, x, y)\n| Percent(e1) -> eval (e1, x, y) *. 0.01\n| Negate(e1) -> eval (e1, x, y) *. (-1.0)\n| SumSquared(e1, e2, e3) -> eval(e1, x, y) * eval(e1, x, y) \n+ eval(e2, x, y) * eval(e2, x, y)\n+ eval(e3, x, y) * eval(e3, x, y)", "out": "Characters 483-497:\n  | SumSquared(e1, e2, e3) -> eval(e1, x, y) * eval(e1, x, y) \n                              ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) * (eval (e1, x, y))) +\n         ((eval (e2, x, y)) * (eval (e2, x, y))))\n        + ((eval (e3, x, y)) * (eval (e3, x, y)));;\n", "type": "type"}, {"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": "scope"}, {"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then eval(a_less, x, y)\nelse eval(b_less, x, y)\n| Percent(e1) -> eval (e1, x, y) *. 0.01\n| Negate(e1) -> eval (e1, x, y) *. (-1.0)\n| SumSquared(e1, e2, e3) -> eval(e1, x, y) *. eval(e1, x, y) \n+. eval(e2, x, y) *. eval(e2, x, y)\n+. eval(e3, x, y) *. eval(e3, x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n         ((eval (e2, x, y)) *. (eval (e2, x, y))))\n        +. ((eval (e3, x, y)) *. (eval (e3, x, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != b) in g,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f x in (xx, (xx != b)) in (g, b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f x in (xx, (xx != b)) in (g, b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != f xx) in g,b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != f xx) in g,b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f x in (xx, (xx != (f xx))) in (g, b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Percent  of expr\n| Negate   of expr\n| SumSquared of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 15) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 15) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then buildPercent(rand, depth - 1)\nelse if(num mod 3 = 0) then buildNegate(rand, depth - 1)\nelse buildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))", "out": "Characters 555-572:\n  if(num mod 2 = 0) then buildPercent(rand, depth - 1)\n                                     ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then buildPercent (rand, (depth - 1))\n         else\n           if (num mod 3) = 0\n           then buildNegate (rand, (depth - 1))\n           else\n             buildSumSquared\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then buildPercent(build(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then buildPercent (build (rand, (depth - 1)))\n         else\n           if (num mod 3) = 0\n           then buildNegate (build (rand, (depth - 1)))\n           else\n             buildSumSquared\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 11) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then buildPercent(build(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 11) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then buildPercent (build (rand, (depth - 1)))\n         else\n           if (num mod 3) = 0\n           then buildNegate (build (rand, (depth - 1)))\n           else\n             buildSumSquared\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then\n           buildSumSquared\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n         else\n           if (num mod 3) = 0\n           then buildNegate (build (rand, (depth - 1)))\n           else buildPercent (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7  -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then\n           buildSumSquared\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n         else\n           if (num mod 3) = 0\n           then buildNegate (build (rand, (depth - 1)))\n           else buildPercent (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then\n           buildSumSquared\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n         else\n           if (num mod 3) = 0\n           then buildNegate (build (rand, (depth - 1)))\n           else buildPercent (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then\n           buildSumSquared\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n         else\n           if (num mod 3) = 0\n           then buildNegate (build (rand, (depth - 1)))\n           else buildPercent (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then\n           buildSumSquared\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n         else\n           if (num mod 3) = 0\n           then buildNegate (build (rand, (depth - 1)))\n           else buildPercent (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n         ((eval (e2, x, y)) *. (eval (e2, x, y))))\n        +. ((eval (e3, x, y)) *. (eval (e3, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    if depth > 8\n    then\n      (let num = rand (1, 10) in\n       if (num mod 3) == 0\n       then\n         buildSumSquared\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n       else\n         if (num mod 2) = 0\n         then buildNegate (build (rand, (depth - 1)))\n         else buildPercent (build (rand, (depth - 1))))\n    else\n      (let num = rand (1, 10) in\n       match num with\n       | 1|2 -> buildSine (build (rand, (depth - 1)))\n       | 3|4 -> buildCosine (build (rand, (depth - 1)))\n       | 5|6 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7|8 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 9 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Percent e -> \"(\" ^ ((exprToString e) ^ \"*.01)\")\n  | Negate e -> \"(-\" ^ ((exprToString e) ^ \")\")\n  | SumSquared (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"^2)\" ^\n              (\"(\" ^\n                 ((exprToString e2) ^ (\"^2)\" ^ ((exprToString e3) ^ \"^2))\"))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse if(depth > 8) then begin\nlet num = rand(1,10) in\nif((num mod 3) == 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 2 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))\nend\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    if depth > 8\n    then\n      (let num = rand (1, 10) in\n       if (num mod 3) == 0\n       then\n         buildSumSquared\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n       else\n         if (num mod 2) = 0\n         then buildNegate (build (rand, (depth - 1)))\n         else buildPercent (build (rand, (depth - 1))))\n    else\n      (let num = rand (1, 10) in\n       match num with\n       | 1|2 -> buildSine (build (rand, (depth - 1)))\n       | 3|4 -> buildCosine (build (rand, (depth - 1)))\n       | 5|6 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7|8 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 9 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildSumPercent(e)\t           = SumPercent(e1, e2, e3)", "out": "Characters 47-49:\n  let buildSumPercent(e)\t           = SumPercent(e1, e2, e3);;\n                                                 ^^\nError: Unbound value e1\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumPercent of expr* expr* expr;;\n\nlet buildSumPercent e = SumPercent (e1, e2, e3);;\n", "type": "scope"}, {"in": "let buildNegate(e)                 = Negate(e)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumPercent of expr* expr* expr;;\n\nlet buildNegate e = Negate e;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildSumPercent(e1, e2, e3)\t           = SumPercent(e1, e2, e3)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumPercent of expr* expr* expr;;\n\nlet buildSumPercent (e1,e2,e3) = SumPercent (e1, e2, e3);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildSumPercent(e1, e2, e3)\t   = SumPercent(e1, e2, e3)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumPercent of expr* expr* expr;;\n\nlet buildSumPercent (e1,e2,e3) = SumPercent (e1, e2, e3);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "type": ""}]}
