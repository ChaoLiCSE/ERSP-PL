{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif d = s then l\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,l) -> if d = s then l else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,l) -> if k = s then l else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,l) -> if k = s then l else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with\n| [] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen then h::seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with\n| [] -> seen\n| h::t -> \nlet seen' =\nif (List.mem h seen) then h::seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with\n| []    ->\nseen\n| h::t  ->\nlet seen' =\nif !(List.mem h seen) then h::seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 115-132:\n  if !(List.mem h seen) then h::seen\n      ^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a ref\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with\n| []    ->\nseen\n| h::t  ->\nlet seen' =\nif (List.mem h seen) then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nmatch (f b) with\n| (b',c') ->\nif c' then wwhile (f,b')\nelse b'", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (f f b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "out": "Characters 31-32:\n  wwhile (f f b,b);;\n            ^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nmatch f with\n| true  -> false\n| false -> true in\nwwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ =\n  let fixpoint (f,b) = match f with | true  -> false | false  -> true in\n  wwhile (f, b);;\n", "out": "Characters 78-79:\n  wwhile (f,b);;\n          ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,l) -> if k = s then l else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (f b = b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "out": "Characters 29-36:\n  wwhile (f b = b,b);;\n          ^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun x -> f x = b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f x) = b), b));;\n", "out": "Characters 28-48:\n  wwhile (fun x -> f x = b,b);;\n         ^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun x -> (f x = b,b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> ((((f x) = b), b), b));;\n", "out": "Characters 28-52:\n  wwhile (fun x -> (f x = b,b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((f b) b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =0", "min": "\nlet fixpoint (f,b) = 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =0", "min": "\nlet fixpoint (f,b) = 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile ((f b) b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (notequal b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((notequal b), b);;\n", "out": "Error: Unbound value notequal\nHint: Did you mean notequals?\nError: Unbound value notequal\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 29-37:\n  wwhile (notequal b,b);;\n          ^^^^^^^^\nError: Unbound value notequal\nHint: Did you mean notequals?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (notequals b,b)", "min": "\nlet notequals x y = x <> y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((notequals b), b);;\n", "out": "Characters 29-40:\n  wwhile (notequals b,b);;\n          ^^^^^^^^^^^\nError: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun x -> f b = b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b) = b), b));;\n", "out": "Characters 28-48:\n  wwhile (fun x -> f b = b,b);;\n         ^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (equ f b,b)", "min": "\nlet equ f b = (f b) = b;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((equ f b), b);;\n", "out": "Characters 29-36:\n  wwhile (equ f b,b);;\n          ^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (if b=(f b) then true else false,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then true else (false, b));;\n", "out": "Characters 45-49:\n  wwhile (if b=(f b) then true else false,b);;\n                          ^^^^\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((b,f b = b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((b, ((f b) = b)), b);;\n", "out": "Characters 29-40:\n  wwhile ((b,f b = b),b);;\n          ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun b -> (b,f b = b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> ((b, ((f b) = b)), b));;\n", "out": "Characters 28-52:\n  wwhile (fun b -> (b,f b = b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun b -> (b,(f b) = b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> ((b, ((f b) = b)), b));;\n", "out": "Characters 28-54:\n  wwhile (fun b -> (b,(f b) = b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((f b <> b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "out": "Characters 29-39:\n  wwhile ((f b <> b),b);;\n          ^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun b -> (f b <> b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> (((f b) <> b), b));;\n", "out": "Characters 28-51:\n  wwhile (fun b -> (f b <> b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (match (f,b) with | (b',c') -> (f b' <> b'),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (match (f, b) with | (b',c') -> (((f b') <> b'), b));;\n", "out": "Characters 62-64:\n  wwhile (match (f,b) with | (b',c') -> (f b' <> b'),b);;\n                                           ^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,l) -> if k = s then l else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (not ((f b)=b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not ((f b) = b)), b);;\n", "out": "Characters 29-42:\n  wwhile (not ((f b)=b),b);;\n          ^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((not f),((f b)=b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not f), ((f b) = b), b);;\n", "out": "Characters 28-49:\n  wwhile ((not f),((f b)=b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun x -> not x,(f b)=b),b", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (fun x  -> ((not x), ((f b) = b)))), b);;\n", "out": "Characters 28-52:\n  wwhile (fun x -> not x,(f b)=b),b;;\n         ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((f,(f b)=b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "out": "Characters 29-40:\n  wwhile ((f,(f b)=b),b);;\n          ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun f -> (f,(f b)=b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun f  -> ((f, ((f b) = b)), b));;\n", "out": "Characters 28-52:\n  wwhile (fun f -> (f,(f b)=b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with\n| []    ->\nseen\n| h::t  ->\nlet seen' =\nmatch List.mem h seen with\n| true  ->\nseen\n| false -> h::seen\nin \nlet rest' = t\nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h seen with | true  -> seen | false  -> h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n| []    ->\nd\n| h::t  ->\nmatch h with\n| (s,l) ->\nmatch k = s with\n| true  -> l\n| false -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with\n       | (s,l) -> (match k = s with | true  -> l | false  -> assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n| []    ->\nd\n| h::t  ->\nmatch h with\n| (s,l) ->\nmatch k = s with\n| true  -> l\n| false -> assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with\n       | (s,l) -> (match k = s with | true  -> l | false  -> assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun f -> (f,(f b)=b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (fun f  -> ((f, ((f b) = b)), b));;\n", "out": "Characters 28-52:\n  wwhile (fun f -> (f,(f b)=b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((f,(f b) = b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "out": "Characters 29-42:\n  wwhile ((f,(f b) = b),b);;\n          ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (let x = not f in (x,(f b) = b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let x = not f in ((x, ((f b) = b)), b));;\n", "out": "Characters 46-59:\n  wwhile (let x = not f in (x,(f b) = b),b);;\n                           ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile (f b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((not f) b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((not f) b), b);;\n", "out": "Characters 29-36:\n  wwhile ((not f) b,b);;\n          ^^^^^^^\nError: This expression has type bool\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile ((not f b) b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((not f b) b), b);;\n", "out": "Characters 30-33:\n  wwhile ((not f b) b,b);;\n           ^^^\nError: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((not (f b)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((not (f b)), b);;\n", "out": "Characters 29-40:\n  wwhile ((not (f b)),b);;\n          ^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (fixpoint(f,f b),b)", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 40-43:\n  wwhile (fixpoint(f,f b),b);;\n                     ^^^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (fixpoint(f,match f b with | (b',c') -> c'),b)", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fixpoint (f, (match f b with | (b',c') -> c'))), b);;\n", "out": "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         'c -> 'c * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 57-64:\n  wwhile (fixpoint(f,match f b with | (b',c') -> c'),b);;\n                                      ^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (fixpoint(f,a = match f b with | (b',c') -> c'),b)", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fixpoint (f, (a = (match f b with | (b',c') -> c')))), b);;\n", "out": "Error: Unbound value a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 40-41:\n  wwhile (fixpoint(f,a = match f b with | (b',c') -> c'),b);;\n                     ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (fixpoint(f,let a = match f b with | (b',c') -> c' in a),b)", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fixpoint (f, (let a = match f b with | (b',c') -> c' in a))), b);;\n", "out": "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         'c -> 'c * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 65-72:\n  wwhile (fixpoint(f,let a = match f b with | (b',c') -> c' in a),b);;\n                                              ^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (f b <> b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "out": "Characters 29-37:\n  wwhile (f b <> b,b);;\n          ^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile ((f, f b <> b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) <> b)), b);;\n", "out": "Characters 29-42:\n  wwhile ((f, f b <> b),b);;\n          ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun f b -> (f, f b <> b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (fun f  -> fun b  -> ((f, ((f b) <> b)), b));;\n", "out": "Characters 28-56:\n  wwhile (fun f b -> (f, f b <> b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) =\nwwhile (fun func f b -> (f, f b <> b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (fun func  -> fun f  -> fun b  -> ((f, ((f b) <> b)), b));;\n", "out": "Characters 28-61:\n  wwhile (fun func f b -> (f, f b <> b),b);;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (let func x y = (x, x y <> y) in func f b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x y = (x, ((x y) <> y)) in ((func f b), b));;\n", "out": "Characters 61-69:\n  wwhile (let func x y = (x, x y <> y) in func f b,b);;\n                                          ^^^^^^^^\nError: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (\nlet func x y =\nmatch x y = y with\n| true  ->\n(x,true)\n| false ->\n(x,false)\nin (func f b,b)\n)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func x y =\n       match (x y) = y with | true  -> (x, true) | false  -> (x, false) in\n     ((func f b), b));;\n", "out": "Characters 109-117:\n  in (func f b,b)\n      ^^^^^^^^\nError: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (\nlet func x y =\nmatch x y = y with\n| true  ->\n(x,true)\n| false ->\n(x,false)\nin func f b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func x y =\n       match (x y) = y with | true  -> (x, true) | false  -> (x, false) in\n     ((func f b), b));;\n", "out": "Characters 108-116:\n  in func f b,b);;\n     ^^^^^^^^\nError: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (\nlet func x y =\nmatch x y = y with\n| true  ->\n((x,true),b)\n| false ->\n((x,false),b)\nin func f b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func x y =\n       match (x y) = y with\n       | true  -> ((x, true), b)\n       | false  -> ((x, false), b) in\n     func f b);;\n", "out": "Characters 116-124:\n  in func f b);;\n     ^^^^^^^^\nError: This expression has type (('a -> 'a) * bool) * 'a\n       but an expression was expected of type ('b -> 'b * bool) * 'b\n       Type ('a -> 'a) * bool is not compatible with type 'b -> 'b * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n| []    ->\nd\n| h::t  ->\nmatch h with\n| (s,l) ->\nmatch k = s with\n| true  ->\nl\n| false ->\nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with\n       | (s,l) -> (match k = s with | true  -> l | false  -> assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func f b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func f b), b));;\n", "out": "Characters 63-71:\n  wwhile (let func x = fun x -> (0,true) in func f b,b);;\n                                            ^^^^^^^^\nError: This expression has type int * bool\n       but an expression was expected of type 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,f b = b) in func b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x x = (0, ((f b) = b)) in ((func b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (b,f b = b) in func b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x x = (b, ((f b) = b)) in ((func b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x x = (b, ((f b) = b)) in ((func b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (b,f b <> b) in func b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x x = (b, ((f b) <> b)) in ((func b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,f b <> b) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) <> b)) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,f b <> b) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,f b = b) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) = b)) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,f b = b) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) <> b) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) <> b)) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,(f b) <> b) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) = b)) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,(f b) = b) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) = b)) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,(f b) = b) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let rec func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let _ = fun x -> (f b,not ((f b) = b)) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let _ = fun x  -> ((f b), (not ((f b) = b))) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let _ = fun x -> (f b,not ((f b) = b)) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (fun x -> (f b,not ((f b) = b)),b)", "min": "\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b), (not ((f b) = b))), b));;\n", "out": "Characters 21-27:\n  wwhile (fun x -> (f b,not ((f b) = b)),b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,f b = b) in func,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) = b)) in (func, b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f b,f b = b) in func,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f x,f x = x) in func,b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f x), ((f x) = x)) in (func, b));;\n", "out": "Characters 21-27:\n  wwhile (let func x = fun x -> (f x,f x = x) in func,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func = fun x -> (f x,f x = x) in func,b)", "min": "\nlet fixpoint (f,b) = wwhile (let func x = ((f x), ((f x) = x)) in (func, b));;\n", "out": "Characters 21-27:\n  wwhile (let func = fun x -> (f x,f x = x) in func,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) =\nwwhile (let func = fun x -> (f x,f x <> x) in func,b)", "min": "\nlet fixpoint (f,b) = wwhile (let func x = ((f x), ((f x) <> x)) in (func, b));;\n", "out": "Characters 21-27:\n  wwhile (let func = fun x -> (f x,f x <> x) in func,b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| h::t  ->\nmatch h with\n(s,l) ->\nmatch k = s with\ntrue  ->\nl\n| false ->\nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with\n       | (s,l) -> (match k = s with | true  -> l | false  -> assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr\t\t\t    ->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t    ->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average (expr,expr)\t\t    ->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   (expr,expr)\t\t    ->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  (expr,expr,expr,expr)     ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr) ->\n      \"(\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr) ^ \")/2)\")))\n  | Times (expr,expr) ->\n      \"(\" ^ ((exprToString expr) ^ (\"*\" ^ ((exprToString expr) ^ \")\")))\n  | Thresh (expr,expr,expr,expr) ->\n      \"(\" ^ (expr ^ (\"<\" ^ (expr ^ (\"?\" ^ (expr ^ (\":\" ^ (expr ^ \")\")))))));;\n", "out": "Characters 206-210:\n  | Average (expr,expr)\t\t    ->\n                  ^^^^\nError: Variable expr is bound several times in this matching\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ expr0 ^ \"<\" ^ expr1 ^ \"?\" ^ expr2 ^ \":\" ^ expr3 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"*\" ^ ((exprToString expr1) ^ \")\")))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        (expr0 ^ (\"<\" ^ (expr1 ^ (\"?\" ^ (expr2 ^ (\":\" ^ (expr3 ^ \")\")))))));;\n", "out": "Characters 426-431:\n  \"(\" ^ expr0 ^ \"<\" ^ expr1 ^ \"?\" ^ expr2 ^ \":\" ^ expr3 ^ \")\";;\n        ^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"*\" ^ ((exprToString expr1) ^ \")\")))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(pi*\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(pi*\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"*\" ^ ((exprToString expr1) ^ \")\")))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(pi*\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(pi*\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\nexprToString expr0 ^ \"*\" ^ exprToString expr1\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| h::t  ->\nmatch h with\n(s,l) ->\nmatch k = s with\ntrue  ->\nl\n| false ->\nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with\n       | (s,l) -> (match k = s with | true  -> l | false  -> assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\nmatch (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (eval (expr0, x, y))\n  | Cosine expr0 -> cos (eval (expr0, x, y))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (eval (expr0, x, y))\n  | Cosine expr0 -> cos (eval (expr0, x, y))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (eval (expr0, x, y))\n  | Cosine expr0 -> cos (eval (expr0, x, y))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (pi *. eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (pi *. eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\nmatch (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| h::t  ->\nmatch h with\n(s,l) ->\nmatch k = s with\ntrue  ->\nl\n| false ->\nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with\n       | (s,l) -> (match k = s with | true  -> l | false  -> assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| h::t  ->\nmatch h with\n(s,l) ->\nmatch k = s with\ntrue  ->\nl\n| false ->\nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with\n       | (s,l) -> (match k = s with | true  -> l | false  -> assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\nmatch k = i with\ntrue  ->\nl\n| false ->\nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = i with | true  -> l | false  -> assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\nmatch k = i with\ntrue  ->\ni\n| false ->\nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = i with | true  -> i | false  -> assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\nmatch k = s with\ntrue  ->\ni\n| false ->\nassoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = s with | true  -> i | false  -> assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\n(match k = s with\ntrue  ->\ni\n| false ->\nassoc (d,k,t)\n)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = s with | true  -> i | false  -> assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 -> buildAverage (build (rand, (depth - 1)))\n       | 3 -> buildTimes (build (rand, (depth - 1)))\n       | 4 -> buildThresh (build (rand, (depth - 1))));;\n", "out": "Characters 232-253:\n  buildAverage(build(rand,depth-1))\n              ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,3) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ())\n  | _ ->\n      (match rand (0, 3) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| _ -> buildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\n(match k = s with\ntrue  ->\ni\n| false ->\nassoc (d,k,t)\n)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = s with | true  -> i | false  -> assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\n(match k = s with\ntrue  ->\ni\n| false ->\nassoc (d,k,t)\n)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = s with | true  -> i | false  -> assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildX()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (0, 1) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildX ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildX()\n| 3 -> buildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (0, 1) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildX ()\n       | 3 -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,9) < 5 with\ntrue  -> buildX()\n| false -> buildY()\n)\n| _ ->\n(match rand (0,9) with\n0 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildSine(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match (rand (0, 9)) < 5 with\n       | true  -> buildX ()\n       | false  -> buildY ())\n  | _ ->\n      (match rand (0, 9) with\n       | 0 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildSine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,9) < 5 with\ntrue  -> buildX()\n| false -> buildY()\n)\n| _ ->\n(match rand (0,5) with\n0 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildSine(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match (rand (0, 9)) < 5 with\n       | true  -> buildX ()\n       | false  -> buildY ())\n  | _ ->\n      (match rand (0, 5) with\n       | 0 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildSine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,9) < 5 with\ntrue  -> buildX()\n| false -> buildY()\n)\n| _ ->\n(match rand (0,5) with\n0 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildSine(build(rand,depth-1))\n| _ ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match (rand (0, 9)) < 5 with\n       | true  -> buildX ()\n       | false  -> buildY ())\n  | _ ->\n      (match rand (0, 5) with\n       | 0 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | _ ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,5) with\n0 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildSine(build(rand,depth-1))\n| _ ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 5) with\n       | 0 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | _ ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,5) with\n0 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildSine(build(rand,depth-1))\n| _ ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 5) with\n       | 0 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | _ ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,5) with\n0 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildSine(build(rand,depth-1))\n\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 5) with\n       | 0 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildSine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildSine(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildSine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 1 ->\nbuildSine(build(rand,depth-1))\n| 2 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildCosine(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\n(match k = s with\ntrue  ->\ni\n| false ->\nassoc (d,k,t)\n)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = s with | true  -> i | false  -> assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(pi*\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(pi*\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\nexprToString expr0 ^ \"*\" ^ exprToString expr1\n| Thresh  (expr0,expr1,expr2,expr3) ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\"\n| Maximum (expr0,expr1,expr2)\t    ->\n\"max(\" ^ exprToString expr0 ^ \",\" ^ exprToString expr1 ^ \",\" ^ exprToString expr2 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"max(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Maximum  of expr * expr * expr\n| Absolute of expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (pi *. eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (pi *. eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\n(match (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)\n)\n| Maximum (expr0,expr1,expr2)       ->\n(match (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\n(match (eval (expr1,x,y) < eval (expr2,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr1,x,y)\n)\n| false ->\n(match (eval (expr0,x,y) < eval (expr2,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr0,x,y)\n)\n)\n| Absolute (expr0)\t\t    ->\n(match (eval (expr0,x,y) < 0.0) with\ntrue  ->\n0.0 -. eval (expr0,x,y)\n| false ->\neval (expr0,x,y)\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (pi *. eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (pi *. eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\n(match (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)\n)\n| Maximum (expr0,expr1,expr2)       ->\n(match (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\n(match (eval (expr1,x,y) < eval (expr2,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr1,x,y)\n)\n| false ->\n(match (eval (expr0,x,y) < eval (expr2,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr0,x,y)\n)\n)\n| Absolute (expr0)\t\t    ->\n(match (eval (expr0,x,y) < 0.0) with\ntrue  ->\n0.0 -. eval (expr0,x,y)\n| false ->\neval (expr0,x,y)\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\n(match k = s with\ntrue  ->\ni\n| false ->\nassoc (d,k,t)\n)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = s with | true  -> i | false  -> assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,8) with\n0 ->\nbuildX()\n| 1 ->\nbuildY()\n| 2 ->\nbuildSine(build(rand,depth-1))\n| 3 ->\nbuildCosine(build(rand,depth-1))\n| 4 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 8 ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 8 -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (1,9) with\n9 ->\nbuildX()\n| 1 ->\nbuildY()\n| 2 ->\nbuildSine(build(rand,depth-1))\n| 3 ->\nbuildCosine(build(rand,depth-1))\n| 4 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 8 ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 9) with\n       | 9 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 8 -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,8) with\n0->\nbuildX()\n| 1 ->\nbuildY()\n| 2 ->\nbuildSine(build(rand,depth-1))\n| 3 ->\nbuildCosine(build(rand,depth-1))\n| 4 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,8) with\n0->\nbuildX()\n| 1 ->\nbuildY()\n| 2 ->\nbuildSine(build(rand,depth-1))\n| 3 ->\nbuildCosine(build(rand,depth-1))\n| 4 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,8) with\n0->\nbuildX()\n| 1 ->\nbuildY()\n| 2 ->\nbuildSine(build(rand,depth-1))\n| 3 ->\nbuildCosine(build(rand,depth-1))\n| 4 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 8) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,10) with\n0->\nbuildX()\n| 1 ->\nbuildY()\n| 2 | 8 ->\nbuildSine(build(rand,depth-1))\n| 3 | 9 ->\nbuildCosine(build(rand,depth-1))\n| 4 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,11) with\n0->\nbuildX()\n| 1 ->\nbuildY()\n| 2 | 8 ->\nbuildSine(build(rand,depth-1))\n| 3 | 9 ->\nbuildCosine(build(rand,depth-1))\n| 4 | 10 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 11) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4|10 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,11) with\n0->\nbuildX()\n| 1 ->\nbuildY()\n| 2 | 8 ->\nbuildSine(build(rand,depth-1))\n| 3 | 9 ->\nbuildCosine(build(rand,depth-1))\n| 4 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 | 10 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 11) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5|10 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,10) with\n0->\nbuildX()\n| 1 ->\nbuildY()\n| 2 | 8 ->\nbuildSine(build(rand,depth-1))\n| 3 | 9 ->\nbuildCosine(build(rand,depth-1))\n| 4 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet buildAbsolute e = Absolute e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMaximum (e1,e2,e3) = Maximum (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 10) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2|8 -> buildSine (build (rand, (depth - 1)))\n       | 3|9 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 7 ->\n           buildMaximum\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildAbsolute (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
