{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match xs with\n| [] -> 0\n| h:: t -> 1 in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> 0 | h::t -> 1 in\n  let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match x with\n| [] -> 0\n| h:: t -> 1 in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | h::t -> 1 in\n  let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + sqsum t in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 76-77:\n  | h:: t -> (h*h) + sqsum t in\n                           ^\nError: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | h::t -> 1 in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> (h * h) + (sqsum t) in\n  let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + f base t in \nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 70-71:\n  | h:: t -> (h*h) + f base t in \n                     ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> (h * h) + (f base t) in\n  let base = 0 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + List.fold_left f base t in \nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 85-86:\n  | h:: t -> (h*h) + List.fold_left f base t in \n                                    ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x =\n    match x with | [] -> a | h::t -> (h * h) + (List.fold_left f base t) in\n  let base = 0 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = fun x -> x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 79-83:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int\n", "min": "\nlet sqsum xs =\n  let f a x x = x * x in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = fun _ x -> x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 81-85:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> int -> int\n", "min": "\nlet sqsum xs =\n  let f a x _ x = x * x in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = fun a x -> x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 81-85:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> int -> int\n", "min": "\nlet sqsum xs =\n  let f a x a x = x * x in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a * a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = fun a x ->  x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 86-90:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "min": "\nlet sqsum xs =\n  let f a x a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = g a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 28-29:\n  let f a x = g a x = x * x + a in\n              ^\nError: Unbound value g\n", "min": "\nlet sqsum xs =\n  let f a x = (g a x) = ((x * x) + a) in\n  let base = 0 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = g a x = x * x + a in\nlet base = 0 in\nList.fold_left g base xs", "out": "Characters 28-29:\n  let f a x = g a x = x * x + a in\n              ^\nError: Unbound value g\n", "min": "\nlet sqsum xs =\n  let f a x = (g a x) = ((x * x) + a) in\n  let base = 0 in List.fold_left g base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsumL xs = \nlet rec helper acc rest = match rest with\n| [] -> acc * acc\n| h :: t -> h + helper (acc + h) t\nin helper 0 xs", "out": "", "min": "\nlet sqsumL xs =\n  let rec helper acc rest =\n    match rest with | [] -> acc * acc | h::t -> h + (helper (acc + h) t) in\n  helper 0 xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsumL xs = \nlet rec helper acc rest = match rest with\n| [] -> acc * acc\n| h :: t -> h + helper (acc + h) t\nin helper 0 xs", "out": "", "min": "\nlet sqsumL xs =\n  let rec helper acc rest =\n    match rest with | [] -> acc * acc | h::t -> h + (helper (acc + h) t) in\n  helper 0 xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsumL xs = \nlet rec helper acc rest = match rest with\n| [] -> acc \n| h :: t -> h + helper (acc + h) t\nin helper 0 xs", "out": "", "min": "\nlet sqsumL xs =\n  let rec helper acc rest =\n    match rest with | [] -> acc | h::t -> h + (helper (acc + h) t) in\n  helper 0 xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsumL xs = \nlet rec helper acc rest = match rest with\n| [] -> acc \n| h :: t -> helper (acc + h) t\nin helper 0 xs", "out": "", "min": "\nlet sqsumL xs =\n  let rec helper acc rest =\n    match rest with | [] -> acc | h::t -> helper (acc + h) t in\n  helper 0 xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsumL xs = \nlet rec helper acc rest = match rest with\n| [] -> acc \n| h :: t -> helper (acc + h*h) t\nin helper 0 xs", "out": "", "min": "\nlet sqsumL xs =\n  let rec helper acc rest =\n    match rest with | [] -> acc | h::t -> helper (acc + (h * h)) t in\n  helper 0 xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> h*h + sqsumL", "out": "Characters 63-69:\n  | h :: t -> h*h + sqsumL;;\n                    ^^^^^^\nError: This expression has type int list -> int\n       but an expression was expected of type int\n", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (h * h) + sqsumL;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> h*h + sqsumL t", "out": "", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsumL t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t + h*h", "out": "", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) + (h * h);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t + h*h", "out": "", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) + (h * h);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t @ h*h", "out": "Characters 57-65:\n  | h :: t -> sqsumL t @ h*h;;\n              ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) @ (h * h);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t + h*h", "out": "", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) + (h * h);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t + h*h", "out": "", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) + (h * h);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t + h*h", "out": "", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) + (h * h);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t + h*h", "out": "", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) + (h * h);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t + h*h", "out": "", "min": "\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) + (h * h);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = f a x in\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 27-28:\n  let f a x = f a x in\n              ^\nError: Unbound value f\n", "min": "\nlet pipe fs = let f a x = f a x in let base = 0 in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a x in\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 66-67:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 57-58:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 57-58:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = x in \nList.fold_left f base fs", "out": "Characters 57-58:\n  let base = x in \n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = fun x -> x + 1 in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in\n  let base x = x + 1 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun y -> fun x -> a in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 92-93:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "min": "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun y -> fun x -> a in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 92-93:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "min": "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a (f x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 31-32:\n  let f a x =  a (f x) in\n                  ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x = a (f x) in let base x = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a (x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  let existing = a in \nlet next = x in \nexisting(next) in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 125-126:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = let existing = a in let next = x in existing next in\n  let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun x' -> a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun x' -> a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun x' -> (a x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a (f x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 31-32:\n  let f a x =  a (f x) in\n                  ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x = a (f x) in let base x = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a (f x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 31-32:\n  let f a x =  a (f x) in\n                  ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x = a (f x) in let base x = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun y -> fun x -> a in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "Characters 92-93:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "min": "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"hi\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"hi\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"hi\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"hi\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"hi\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"hi\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"hi\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"hi\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  failwith \"hi\" in \nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"hi\" in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun a -> fun x -> x in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun a -> fun x ->  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun g -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x g = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then x :: a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "out": "Characters 96-98:\n  let f a x = if x = \"a\" then x :: a in\n                                ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then x :: a in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then x :: a \nelse a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "out": "Characters 143-166:\n  List.fold_left f base l;;\n  ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string list\n       but an expression was expected of type string\n", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then x :: a else a in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then a ^ x in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "out": "Characters 94-99:\n  let f a x = if x = \"a\" then a ^ x in\n                              ^^^^^\nError: This expression has type string but an expression was expected of type\n         unit\n", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then a ^ x in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ x in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x  ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if a = \"a\" then a ^ x  ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "out": "Characters 94-106:\n  let f a x = if a = \"a\" then a ^ x  ^ sep in\n                              ^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         unit\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a = \"a\" then a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x  ^ sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ sep) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map sepConcat f l", "out": "Characters 23-31:\n  let stringOfList f l = List.map sepConcat f l;;\n                         ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (sepConcat f) l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (f sepConcat ) l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (f sepConcat) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map f l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let nl = List.map f l in sepConcat \"\" nl", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let nl = List.map f l in sepConcat \"\" nl;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let nl = List.map f l in\n\" [ \" ^ sepConcat \";\" nl ^ \"]\"", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let nl = List.map f l in \" [ \" ^ ((sepConcat \";\" nl) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let nl = List.map f l in\n\"[\" ^ sepConcat \";\" nl ^ \"]\"", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let nl = List.map f l in \"[\" ^ ((sepConcat \";\" nl) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let nl = List.map f l in\n\"[\" ^ sepConcat \"; \" nl ^ \"]\"", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let nl = List.map f l in \"[\" ^ ((sepConcat \"; \" nl) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif( n <= 0) then []\nelse\nx :: clone x (n-1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 < List.length l2) then \nclone 0 (List.length l1 - List.length l2)\nelse\nclone 0 (List.length l2 - List.length l1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then clone 0 ((List.length l1) - (List.length l2))\n  else clone 0 ((List.length l2) - (List.length l1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 < List.length l2) then \n(l1, clone 0 (List.length l1 - List.length l2))\nelse\n(clone 0 (List.length l2 - List.length l1), l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (l1, (clone 0 ((List.length l1) - (List.length l2))))\n  else ((clone 0 ((List.length l2) - (List.length l1))), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 < List.length l2) then \n(l1, clone 0 (List.length l2 - List.length l1))\nelse\n(clone 0 (List.length l1 - List.length l2), l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (l1, (clone 0 ((List.length l2) - (List.length l1))))\n  else ((clone 0 ((List.length l1) - (List.length l2))), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 < List.length l2) then \n(l1, l2 @ clone 0 (List.length l2 - List.length l1))\nelse\n(l1 @ clone 0 (List.length l1 - List.length l2), l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (l1, (l2 @ (clone 0 ((List.length l2) - (List.length l1)))))\n  else ((l1 @ (clone 0 ((List.length l1) - (List.length l2)))), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 < List.length l2) then \n(l1, clone 0 (List.length l2 - List.length l1) @ l2)\nelse\n(clone 0 (List.length l1 - List.length l2) @ l1, l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (l1, ((clone 0 ((List.length l2) - (List.length l1))) @ l2))\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 < List.length l2) then \n(clone 0 (List.length l2 - List.length l1) @ l1, l2)\nelse\n(l1, clone 0 (List.length l1 - List.length l2) @ l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h :: t -> if (h = 0) then removeZero t\nelse l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h :: t -> if (h = 0) then removeZero t\nelse l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = padZero l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 192-196:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type 'a list\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = failwith \"to be implemented\"", "out": "", "min": "\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (index, result) = a in\nlet (list1,list2) = x in\nmatch list2 with\n| [] -> []\n| h::t ->\nlet resList = mulByDigit h list1 in\nlet newIndex = (index + 1) in \nlet newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in\n(newIndex, newRes)\nin\nlet base = (0, []) in\nlet args = ((List.rev l1),(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 288-306:\n  (newIndex, newRes)\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (index,result) = a in\n    let (list1,list2) = x in\n    match list2 with\n    | [] -> []\n    | h::t ->\n        let resList = mulByDigit h list1 in\n        let newIndex = index + 1 in\n        let newRes =\n          bigAdd result\n            (mulByDigit (int_of_float (10.0 ** (float (newIndex - 1))))\n               resList) in\n        (newIndex, newRes) in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = x in carry in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 134-142:\n  let args =  List.rev List.combine l1 l2 in\n              ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = x in carry in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 231-252:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = x in carry in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 209-230:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"hi\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"hi\" in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n|(x, y) -> x in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 178-179:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x,y) -> x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n|(x, y) -> x in carry in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 200-201:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = match a with | (x,y) -> x in carry in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = [] in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 157-161:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type 'b list\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = match a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in carry in \nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 286-291:\n  | (x,y) -> (new_carry, digit::y) in carry in \n                                      ^^^^^\nError: Unbound value carry\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet f y z x = y z;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ =\n  let bigAdd l1 l2 =\n    let add (l1,l2) =\n      let f a x =\n        let carry = match a with | (x,y) -> x in\n        match x with\n        | (addend_a,addend_b) ->\n            let new_carry = ((carry + addend_a) + addend_b) / 10 in\n            let digit = ((carry + addend_a) + addend_b) mod 10 in\n            (match a with | (x,y) -> (new_carry, (digit :: y))) in\n      carry in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (x,y) -> x in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) mod 10 in\n          let num = ((carry + add1) + add2) / 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,s) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,s) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) mod 10 in\n          let num = ((carry + add1) + add2) / 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,s) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,s) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (newCarry, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 271-279:\n  let base = (newCarry, []) in\n              ^^^^^^^^\nError: Unbound value newCarry\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (newCarry, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"tbd\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"tbd\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper (num, carry, l) = match l with\n| _ -> []\nin helper (i, 0, l)", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper (num,carry,l) = match l with | _ -> [] in helper (i, 0, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper (num, carry, l) = match l with\n| [] -> removeZero(carry :: l)\n| h :: t -> []\nin helper (i, 0, l)", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,l) =\n    match l with | [] -> removeZero (carry :: l) | h::t -> [] in\n  helper (i, 0, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper (num, carry, rest, l) = match rest with\n| [] -> removeZero(carry :: l)\n| h :: t -> helper(num, (num * h)/10, t, ((carry + num*h) mod 10) :: l)\nin helper (i, 0, l, [])", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet t x = x + 1;;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        helper\n          (num, ((num * h) / 10), t, (((carry + (num * h)) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper (num, carry, rest, l) = match rest with\n| [] -> removeZero(carry :: l)\n| h :: t -> let prod = num * h in\nhelper(num, prod/10, t, ((carry + prod) mod 10) :: l)\nin helper (i, 0, l, [])", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet t x = x + 1;;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 =\nlet g =\nlet f b x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_,res) = (List.fold_left f base args) in\nres\nin\nList.fold_left bigAdd [] g", "out": "Error: This expression has type int list list\n       but an expression was expected of type 'a * 'b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 148-176:\n  let (_,res) = (List.fold_left f base args) in\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let g =\n    let f b x = ((mulByDigit x l1) @ (clone 0 (List.length b))) :: b in\n    let base = [] in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  List.fold_left bigAdd [] g;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (index, result) = a in\nlet (list1,list2) = x in\nmatch list2 with\n| [] -> []\n| h::t ->\nlet resList = mulByDigit h list1 in\nlet newIndex = (index + 1) in \nlet newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in\n(newIndex, newRes)\nin\nlet base = (0, []) in\nlet args = ((List.rev l1),(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 288-306:\n  (newIndex, newRes)\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (index,result) = a in\n    let (list1,list2) = x in\n    match list2 with\n    | [] -> []\n    | h::t ->\n        let resList = mulByDigit h list1 in\n        let newIndex = index + 1 in\n        let newRes =\n          bigAdd result\n            (mulByDigit (int_of_float (10.0 ** (float (newIndex - 1))))\n               resList) in\n        (newIndex, newRes) in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"tbd\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"tbd\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n|(numZero, soFar) -> (numZero + 1, bigAdd ((mulByDigit x l1) @ clone 0 numZero) soFar) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numZero,soFar) ->\n        ((numZero + 1),\n          (bigAdd ((mulByDigit x l1) @ (clone 0 numZero)) soFar)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n|(num, soFar) -> (num + 1, bigAdd ((mulByDigit x l1) @ clone 0 num) soFar) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (num,soFar) ->\n        ((num + 1), (bigAdd ((mulByDigit x l1) @ (clone 0 num)) soFar)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n|(num, seen) -> (num + 1, bigAdd ((mulByDigit x l1) @ clone 0 num) seen) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (num,seen) ->\n        ((num + 1), (bigAdd ((mulByDigit x l1) @ (clone 0 num)) seen)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x l1) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (num,prod) ->\n        ((num + 1), (bigAdd ((mulByDigit x l1) @ (clone 0 num)) prod)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x List.rev l1) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 80-90:\n  |(num, prod) -> (num + 1, bigAdd ((mulByDigit x List.rev l1) @ clone 0 num) prod) in\n                                     ^^^^^^^^^^\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (num,prod) ->\n        ((num + 1),\n          (bigAdd ((mulByDigit x List.rev l1) @ (clone 0 num)) prod)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x (List.rev l1)) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (num,prod) ->\n        ((num + 1),\n          (bigAdd ((mulByDigit x (List.rev l1)) @ (clone 0 num)) prod)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x (List.rev l1)) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (num,prod) ->\n        ((num + 1),\n          (bigAdd ((mulByDigit x (List.rev l1)) @ (clone 0 num)) prod)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let mulByDigit digit list = \nlet rec mulByDigitHelper(digit, origList, resList) = \nif digit > 0 then mulByDigitHelper(digit - 1, origList, (bigAdd origList resList))\nelse resList in match padZero [] list with\n(zerosList, sameList) -> mulByDigitHelper(digit, list, zerosList)", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet mulByDigit digit list =\n  let rec mulByDigitHelper (digit,origList,resList) =\n    if digit > 0\n    then mulByDigitHelper ((digit - 1), origList, (bigAdd origList resList))\n    else resList in\n  match padZero [] list with\n  | (zerosList,sameList) -> mulByDigitHelper (digit, list, zerosList);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper (num, carry, rest, l) = match rest with\n| [] -> removeZero(carry :: l)\n| h :: t -> helper(num, (num * h)/10, t, ((carry + num*h) mod 10) :: l)\nin helper (i, 0, l, [])", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet t x = x + 1;;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        helper\n          (num, ((num * h) / 10), t, (((carry + (num * h)) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper (num, carry, rest, l) = match rest with\n| [] -> removeZero(carry :: l)\n| h :: t -> let prod = num * h in\nhelper(num, prod/10, t, ((carry + prod) mod 10) :: l)\nin helper (i, 0, l, [])", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet t x = x + 1;;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper (num, carry, rest, l) = match rest with\n| [] -> removeZero(carry :: l)\n| h :: t -> let prod = num * h in\nhelper(num, prod/10, t, ((carry + prod) mod 10) :: l)\nin helper (i, 0, List.rev l, [])", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet t x = x + 1;;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, (List.rev l), []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let nl = List.map f l in\n\"[\" ^ sepConcat \"; \" nl ^ \"]\"", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let nl = List.map f l in \"[\" ^ ((sepConcat \"; \" nl) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs =\nlet f func1 func2 = fun input -> func2(func1(input)) in\nlet base = fun input' -> input' in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f func1 func2 input = func2 (func1 input) in\n  let base input' = input' in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let nl = List.map f l in\n\"[\" ^ sepConcat \"; \" nl ^ \"]\"", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let nl = List.map f l in \"[\" ^ ((sepConcat \"; \" nl) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper (num, carry, rest, l) = match rest with\n| [] -> removeZero(carry :: l)\n| h :: t -> let prod = num * h in\nhelper(num, prod/10, t, ((carry + prod) mod 10) :: l)\nin helper (i, 0, List.rev l, [])", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet t x = x + 1;;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, (List.rev l), []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nfold_l f base xs", "out": "", "min": "\nlet t x = x + 1;;\n\nlet rec fold_l f acc xs =\n  match xs with | [] -> acc | h::t -> fold_l f (f acc h) t;;\n\nlet sqsum xs = let f a x = a + (x * x) in let base = 0 in fold_l f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe2(fnList) = \nlet f func1 func2 = fun input -> func2(func1(input)) in\nlet base = fun input' -> input' in\nList.fold_left f base fnList", "out": "", "min": "\nlet pipe2 fnList =\n  let f func1 func2 input = func2 (func1 input) in\n  let base input' = input' in List.fold_left f base fnList;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe2(fnList) = \nlet f func1 func2 = fun input -> func2(func1(input)) in\nlet base = fun input' -> input' in\nList.fold_left f base fnList", "out": "", "min": "\nlet pipe2 fnList =\n  let f func1 func2 input = func2 (func1 input) in\n  let base input' = input' in List.fold_left f base fnList;;\n", "type": ""}]}
