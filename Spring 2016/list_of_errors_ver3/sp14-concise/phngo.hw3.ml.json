{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun helper -> (x (a helper)) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x helper = x (a helper) in\n  let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun f' -> (x (a f')) in\nlet base =  fun base' -> base' in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x f' = x (a f') in\n  let base base' = base' in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l)^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = if n <= 0 then []\nelse x::(clone x(n-1))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = if (List.length l1) > (List.length l2)\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse ((clone 0 (List.length l2 - List.length l1)) @ l1, l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []    -> []\n| h::t  -> if h=0 then removeZero t\nelse h::t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun f' -> (x (a f')) in\nlet base =  fun base' -> base' in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x f' = x (a f') in\n  let base base' = base' in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l)^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = if n <= 0 then []\nelse x::(clone x(n-1))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = if (List.length l1) > (List.length l2)\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse ((clone 0 (List.length l2 - List.length l1)) @ l1, l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = if (List.length l1) > (List.length l2)\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse ((clone 0 (List.length l2 - List.length l1)) @ l1, l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []    -> []\n| h::t  -> if h=0 then removeZero t\nelse h::t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (carry, sum) = a in\nlet (l1_digit,l2_digit) = x in\nlet new_digit = l1_digit + l2_digit + carry in\n((new_digit/10), (new_digit mod 10)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,sum) = a in\n      let (l1_digit,l2_digit) = x in\n      let new_digit = (l1_digit + l2_digit) + carry in\n      ((new_digit / 10), ((new_digit mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (carry, sum) = a in\nlet (l1_digit,l2_digit) = x in\nlet new_digit = l1_digit + l2_digit + carry in\n((new_digit/10), (new_digit mod 10)::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,sum) = a in\n      let (l1_digit,l2_digit) = x in\n      let new_digit = (l1_digit + l2_digit) + carry in\n      ((new_digit / 10), ((new_digit mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+c) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + c) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 126-127:\n  | h::t -> ((h+carry)/10)::((h+c) mod 10)::t\n                                ^\nError: Unbound value c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+carry) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 279-283:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+carry) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = (0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 275-279:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+carry) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 257-283:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((o,sum),[])\t      -> (0,sum)\n| ((o,sum),(b,c)::l') -> let d = (b + c + o) in\nif d < 10 then (0, d::sum)\nelse (1, (d-10)::sum)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((o,sum),[]) -> (0, sum)\n      | ((o,sum),(b,c)::l') ->\n          let d = (b + c) + o in\n          if d < 10 then (0, (d :: sum)) else (1, ((d - 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 303-307:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((o,sum),[])\t      -> (0,sum)\n| ((o,sum),(b,c)::l') -> let d = (b + c + o) in\nif d < 10 then (0, d::sum)\nelse (1, (d-10)::sum)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((o,sum),[]) -> (0, sum)\n      | ((o,sum),(b,c)::l') ->\n          let d = (b + c) + o in\n          if d < 10 then (0, (d :: sum)) else (1, ((d - 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 303-307:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b)/10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (*let carry = match a with (x,y) -> x in*)\nmatch x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\nlet digit = (a + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((a + d1) + d2) / 10 in\n          let digit = ((a + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 162-167:\n  match a with (x,y) -> (new_carry, digit::y) in\n               ^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\nlet digit = (a + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((a + d1) + d2) / 10 in\n          let digit = ((a + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 132-133:\n  match x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\n                                           ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (carry + d1 + d2)/10 in\nlet digit = (carry + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((carry + d1) + d2) / 10 in\n          let digit = ((carry + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch a with ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (pair,sum) -> pair in\n      match a with\n      | ((d1,d2),sum) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let sum = ((c + d1) + d2) mod 10 in\n          (match a with | (pair,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 135-136:\n  match a with ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\n                                          ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch pair with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (pair,sum) -> pair in\n      match pair with\n      | (d1,d2) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let digit = ((c + d1) + d2) mod 10 in\n          (match a with | (pair,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 101-105:\n  match pair with (d1,d2) -> let c' = (c + d1 + d2)/10 in\n        ^^^^\nError: Unbound value pair\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch x with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (pair,sum) -> pair in\n      match x with\n      | (d1,d2) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let digit = ((c + d1) + d2) mod 10 in\n          (match a with | (pair,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (c,sum) -> c in\nmatch x with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (c,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (c,sum) -> c in\n      match x with\n      | (d1,d2) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let digit = ((c + d1) + d2) mod 10 in\n          (match a with | (c,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet c = match a with\n(c,sum) -> c in\nlet sum = match a with\n(c, sum) -> sum in\nmatch x with\n(d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (c,sum) -> c in\n      let sum = match a with | (c,sum) -> sum in\n      match x with\n      | (d1,d2) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let digit = ((c + d1) + d2) mod 10 in (c', (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(c,sum) ->\nmatch x with\n(d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let digit = ((c + d1) + d2) mod 10 in (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(c,sum) ->\nmatch x with\n(d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet d' = (c + d1 + d2) mod 10 in (c', d'::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(c,sum) ->\nmatch x with\n(d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet d' = (c + d1 + d2) mod 10 in (c', d'::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (l1)) (List.rev (l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(c,sum) ->\nmatch x with\n(d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet d' = (c + d1 + d2) mod 10 in (c', d'::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse if i <= 0 then []\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else if i <= 0 then [] else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t)\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> 0\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> 0)\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": "Characters 175-176:\n  | _ -> 0\n         ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> []\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> [])\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> []\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> [])\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = failwith (0, []) in\nlet args = failwith l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> [])\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (c,sum) -> ((c + 1), (bigAdd ((mulByDigit x l1) @ (clone 0 c)) sum)) in\n  let base = failwith (0, []) in\n  let args = failwith l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type string\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 131-138:\n  let base = failwith (0, []) in\n                      ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> [])\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (c,sum) -> ((c + 1), (bigAdd ((mulByDigit x l1) @ (clone 0 c)) sum)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> [])\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (c,sum) -> ((c + 1), (bigAdd ((mulByDigit x l1) @ (clone 0 c)) sum)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
