{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di,ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (di,ki) -> if ki = k then di else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (ki,di) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (ki,di) -> if ki = k then di else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem (h, seen)\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 113-131:\n  if List.mem (h, seen)\n     ^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 113-123:\n  if List.mem h\n     ^^^^^^^^^^\nError: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = failwith \"to be written\"", "out": "", "min": "\nlet rec wwhile (f,b) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (ki,di) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (ki,di) -> if ki = k then di else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then b else wwhile (f, k);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f b with\n| (k, tf) -> \nif tf = false\nthen k\nelse wwhile (f,k)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (\nlet g a =\na, true\nin \ng, b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (let g a = (a, true) in (g, b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (\nlet g a = \nf a, f a = a\nin \ng, b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (let g a = ((f a), ((f a) = a)) in (g, b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (let g a = ((f a), ((f a) = a)) in (g, b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (\nlet g a = \nf a, f a != a\nin \ng, b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (let g a = ((f a), ((f a) != a)) in (g, b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": " fixpoint (f,b) = wwhile (\nlet g a = \nf a, f a != a\nin \ng, b)", "out": "Error: Unbound value f\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 11-12:\n   fixpoint (f,b) = wwhile (\n             ^\nError: Unbound value f\n", "min": "\nlet fixpoint (f,b) = wwhile (let g a = ((f a), ((f a) != a)) in (g, b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet _ =\n  (fixpoint (f, b)) = (wwhile (let g a = ((f a), ((f a) != a)) in (g, b)));;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (let g a = ((f a), ((f a) != a)) in (g, b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (ki,di) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (ki,di) -> if ki = k then di else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a, b)", "out": "Characters 28-56:\n  ............................(\n  fun a ->\n  f a, f a != a, b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\n, b)", "out": "Characters 28-57:\n  ............................(\n  fun a ->\n  f a, f a != a\n  , b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\n, b)", "out": "Characters 28-57:\n  ............................(\n  fun a ->\n  f a, f a != a\n  , b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (fun a -> f a, f a != a, b)", "out": "Characters 28-55:\n  let fixpoint (f,b) = wwhile (fun a -> f a, f a != a, b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile ((fun a  -> ((f a), ((f a) != a))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile ((fun a  -> ((f a), ((f a) != a))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile ((fun a  -> ((f a), ((f a) != a))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile ((fun a  -> ((f a), ((f a) != a))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (ki,di) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (ki,di) -> if ki = k then di else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"pi* \" exprToString s", "out": "Characters 78-84:\n  | Sine s -> \"pi* \" exprToString s;;\n              ^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" exprToString s;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"pi* \" + exprToString s", "out": "Characters 78-84:\n  | Sine s -> \"pi* \" + exprToString s;;\n              ^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" + (exprToString s);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> String.concat [\"pi* \"; exprToString s]", "out": "Characters 92-116:\n  | Sine s -> String.concat [\"pi* \"; exprToString s];;\n                            ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat [\"pi* \"; exprToString s];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> String.concat sep [\"pi* \"; exprToString s]", "out": "Characters 92-95:\n  | Sine s -> String.concat sep [\"pi* \"; exprToString s];;\n                            ^^^\nError: Unbound value sep\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat sep [\"pi* \"; exprToString s];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> String.concat \"pi* \" ^ exprToString s", "out": "Characters 78-98:\n  | Sine s -> String.concat \"pi* \" ^ exprToString s;;\n              ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string list -> string\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> (String.concat \"pi* \") ^ (exprToString s);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"pi* \" ^ exprToString s", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" ^ (exprToString s);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"pi*\" ^ exprToString s", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi*\" ^ (exprToString s);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ exprToString s", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ (exprToString s);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ exprToString s \")\"", "out": "Characters 90-102:\n  | Sine s -> \"sin(pi*\" ^ exprToString s \")\";;\n                          ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ (exprToString s \")\");;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ exprToString s ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e' -> \"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \"cos(pi*)\" ^ exprToString e' ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*)\" ^ ((exprToString e') ^ \")\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e' -> \"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \"cos(pi*\" ^ exprToString e' ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e' -> \"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e' -> \"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e' -> \"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> exprToString e1 ^ \"*\" ^ exprToString e2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine e' -> \n\"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \n\"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \n\"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> \nexprToString e1 ^ \"*\" ^ exprToString e2\n| Threshold (e1, e2, e3, e4) -> \nexprToString e1 ^ \"<\" ^ exprToString e2 \"?\" ^ \nexprToString e3 ^ \"?\" exprToString e4", "out": "Characters 308-317:\n  | Threshold (e1, e2, e3, e4) -> \n    ^^^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Threshold does not belong to type expr\nHint: Did you mean Thresh?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Threshold (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2 \"?\") ^\n              ((exprToString e3) ^ (\"?\" exprToString e4))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine e' -> \n\"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \n\"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \n\"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> \nexprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \nexprToString e1 ^ \"<\" ^ exprToString e2 \"?\" ^ \nexprToString e3 ^ \"?\" exprToString e4", "out": "Characters 360-372:\n  exprToString e1 ^ \"<\" ^ exprToString e2 \"?\" ^ \n                          ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2 \"?\") ^\n              ((exprToString e3) ^ (\"?\" exprToString e4))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine e' -> \n\"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \n\"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \n\"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> \nexprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \nexprToString e1 ^ \"<\" ^ exprToString e2 \"?\" ^ exprToString e3 ^ \"?\" exprToString e4", "out": "Characters 360-372:\n  exprToString e1 ^ \"<\" ^ exprToString e2 \"?\" ^ exprToString e3 ^ \"?\" exprToString e4;;\n                          ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2 \"?\") ^\n              ((exprToString e3) ^ (\"?\" exprToString e4))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine e' -> \n\"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \n\"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \n\"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> \nexprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \nexprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ \nexprToString e3 ^ \"?\" exprToString e4", "out": "Characters 403-406:\n  exprToString e3 ^ \"?\" exprToString e4;;\n                    ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\"?\" exprToString e4)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine e' -> \n\"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \n\"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \n\"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> \nexprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \nexprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ \nexprToString e3 ^ \"?\" ^ exprToString e4", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\"?\" ^ (exprToString e4))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine e' -> \n\"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \n\"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \n\"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> \nexprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \n\"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ \nexprToString e3 ^ \"?\" ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\"?\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine e' -> \n\"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \n\"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \n\"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> \nexprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \n\"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ \nexprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval e)", "out": "Characters 87-88:\n  | Sine e -> sin(pi *. eval e);;\n                             ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> sin (pi *. (eval e));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi * eval e)", "out": "Characters 76-78:\n  | Sine e -> sin(pi * eval e);;\n                  ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> sin (pi * (eval e));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval e)", "out": "Characters 87-88:\n  | Sine e -> sin(pi *. eval e);;\n                             ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> sin (pi *. (eval e));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval (e,0,0))", "out": "Characters 82-94:\n  | Sine e -> sin(pi *. eval (e,0,0));;\n                        ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0, 0)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval (e,0.0,0.0))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) * eval (e2,x,y)) / 2)", "out": "Characters 161-174:\n  | Average (e1,e2) -> ((eval (e1,x,y) * eval (e2,x,y)) / 2);;\n                         ^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) * (eval (e2, x, y))) / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) *. eval (e2,x,y)) / 2)", "out": "Characters 160-192:\n  | Average (e1,e2) -> ((eval (e1,x,y) *. eval (e2,x,y)) / 2);;\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) *. eval (e2,x,y)) /. 2)", "out": "Characters 196-197:\n  | Average (e1,e2) -> ((eval (e1,x,y) *. eval (e2,x,y)) /. 2);;\n                                                            ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) *. eval (e2,x,y)) /. 2.0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 2.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y)) /. 2.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 2.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) + eval (e2,x,y)) /. 2.0", "out": "Characters 160-173:\n  | Average (e1,e2) -> (eval (e1,x,y) + eval (e2,x,y)) /. 2.0;;\n                        ^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2.0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> eval e1 *. eval e2", "out": "Characters 223-225:\n  | Times (e1,e2) -> eval e1 *. eval e2;;\n                          ^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval e1) *. (eval e2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (ki,di) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (ki,di) -> if ki = k then di else assoc (d, k, t));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match depth with\n| 0 -> \nbuildX()\n| d -> \nbuildSine(build (rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | d -> buildSine (build (rand, (depth - 1)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | d -> buildSine (build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,5) with\n| 0 -> \nbuildSine (build (rand, depth-1))\n| 1 -> \nbuildCosine (build (rand, depth-1))\n| 2 -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| 3 -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| 4 ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 5) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<5) -> \nbuildSine (build (rand, depth-1))\n| i when (i<10) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<20) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<80) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 5 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 10 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 20 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 5 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 10 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 20 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<20) -> \nbuildSine (build (rand, depth-1))\n| i when (i<40) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<50) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<90) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 40 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 50 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 90 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| AlternateSign of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AlternateSign of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Negate   of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<20) -> \nbuildSine (build (rand, depth-1))\n| i when (i<45) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<65) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<75) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<80) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))\n| i when (i<100) ->\nbuildNegate (build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 45 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 65 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 75 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 -> buildNegate (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<20) -> \nbuildSine (build (rand, depth-1))\n| i when (i<45) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<65) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<75) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<80) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))\n| i when (i<100) ->\nbuildNegate (build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 45 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 65 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 75 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 -> buildNegate (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 45 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 65 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 75 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 -> buildNegate (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Negate e' -> \"negate(\" ^ ((exprToString e') ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Log      of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0", "out": "Characters 416-417:\n  else 0;;\n       ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Log      of expr\n| SumOfSquares of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) + (eval(e2,x,y) ** 2.0) + (eval(e3,x,y) ** 2.0)", "out": "Characters 449-470:\n  (eval(e1,x,y) ** 2.0) + (eval(e2,x,y) ** 2.0) + (eval(e3,x,y) ** 2.0);;\n  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) + ((eval (e2, x, y)) ** 2.0)) +\n        ((eval (e3, x, y)) ** 2.0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) **. 2.0) + (eval(e2,x,y) **. 2.0) + (eval(e3,x,y) **. 2.0)", "out": "Characters 463-466:\n  (eval(e1,x,y) **. 2.0) + (eval(e2,x,y) **. 2.0) + (eval(e3,x,y) **. 2.0);;\n                ^^^\nError: Unbound value **.\nHint: Did you mean *. or **?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) **. 2.0) + ((eval (e2, x, y)) **. 2.0)) +\n        ((eval (e3, x, y)) **. 2.0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) +. (eval(e2,x,y) ** 2.0) +. (eval(e3,x,y) ** 2.0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n        ((eval (e3, x, y)) ** 2.0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<15) -> \nbuildSine (build (rand, depth-1))\n| i when (i<30) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<40) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<50) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<60) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))\n| i when (i<80) ->\nbuildLog (build (rand, depth-1))\n| i when (i<100) -> \nbuildSumOfSquares (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLog e = Log e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 15 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 30 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 40 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 50 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 -> buildLog (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n        ((eval (e3, x, y)) ** 2.0);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLog e = Log e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 15 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 30 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 40 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 50 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 -> buildLog (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Log e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n((eval(e1,x,y) ** 2.0) \n+. (eval(e2,x,y) ** 2.0)\n+. (eval(e3,x,y) ** 2.0)) /. 3.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| ModF e1 ->\n(match modf (eval (e1,x,y) *. 10) with\n| (f, i) -> f\n)\n| SumOfSquares (e1,e2,e3) ->\n((eval(e1,x,y) ** 2.0) \n+. (eval(e2,x,y) ** 2.0)\n+. (eval(e3,x,y) ** 2.0)) /. 3.0", "out": "Characters 351-355:\n  | ModF e1 ->\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor ModF does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| ModF      of expr\n| SumOfSquares of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| ModF e1 ->\n(match modf (eval (e1,x,y) *. 10.0) with\n| (f, i) -> f\n)\n| SumOfSquares (e1,e2,e3) ->\n((eval(e1,x,y) ** 2.0) \n+. (eval(e2,x,y) ** 2.0)\n+. (eval(e3,x,y) ** 2.0)) /. 3.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<20) -> \nbuildSine (build (rand, depth-1))\n| i when (i<40) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<50) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<60) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<70) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))\n| i when (i<85) ->\nbuildModF (build (rand, depth-1))\n| i when (i<100) -> \nbuildSumOfSquares (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 40 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 50 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 70 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 85 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 40 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 50 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 70 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 85 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ModF e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| ModF e1 ->\n(match modf (eval (e1,x,y) *. 4.0) with\n| (f, i) -> f\n)\n| SumOfSquares (e1,e2,e3) ->\n((eval(e1,x,y) ** 2.0) \n+. (eval(e2,x,y) ** 2.0)\n+. (eval(e3,x,y) ** 2.0)) /. 3.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 4.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 4.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 40 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 50 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 70 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 85 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ModF e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<30) -> \nbuildSine (build (rand, depth-1))\n| i when (i<40) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<60) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<80) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<85) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))\n| i when (i<90) ->\nbuildModF (build (rand, depth-1))\n| i when (i<100) -> \nbuildSumOfSquares (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 30 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 40 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 60 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 85 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 90 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<23) -> \nbuildSine (build (rand, depth-1))\n| i when (i<46) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<56) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<64) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<96) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))\n| i when (i<98) ->\nbuildModF (build (rand, depth-1))\n| i when (i<100) -> \nbuildSumOfSquares (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 23 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 46 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 56 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 64 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 96 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 98 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 4.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 23 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 46 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 56 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 64 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 96 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 98 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ModF e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 4.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 23 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 46 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 56 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 64 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 96 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 98 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ModF e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 4.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 23 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 46 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 56 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 64 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 96 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 98 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ModF e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<18) -> \nbuildSine (build (rand, depth-1))\n| i when (i<36) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<56) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<75) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 18 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 36 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 56 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 75 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<30) -> \nbuildSine (build (rand, depth-1))\n| i when (i<60) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<80) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<90) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 30 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 60 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 80 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 90 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 4.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 30 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 60 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 80 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 90 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ModF e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (ki,di) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (ki,di) -> if ki = k then di else assoc (d, k, t));;\n", "type": ""}]}
