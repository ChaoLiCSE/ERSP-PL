{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (s,x) = h in if s = k then x else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (((*failwith \"to be written\"*)fun x -> f(x), x = f(x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 115-123:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet rec wwhile (f,b) =\n  let (i,c) = f b in if c = true then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  (wwhile ((fun x  -> ((f x), (x = (f x)))), b)) *\n    (let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (i,c) = f b in if c = true then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f x in (xx, (xx = x)) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g x = let xx = f(x) in (xx, xx = x) in \nwwhile (g,b)", "out": "Characters 66-72:\n  wwhile (g,b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in wwhile (g, b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x) in g\nwwhile (g,b)", "out": "Characters 66-67:\n  let g x = let xx = (f x) in (xx, xx = x) in g\n                                              ^\nError: This function has type 'a -> 'a * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in g wwhile (g, b);;\n", "type": "other"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x) in\nwwhile (g,b)", "out": "Characters 66-72:\n  wwhile (g,b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in wwhile (g, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x) in\nwwhile (g,b)", "out": "Characters 67-73:\n  wwhile (g,b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) if ( List.mem(h, seen) = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 121-125:\n   if ( List.mem(h, seen) = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\n                            ^^^^\nError: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "min": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if (List.mem (h, seen)) = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) if (List.mem(h, seen)) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 99-118:\n   if (List.mem(h, seen)) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\n      ^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if List.mem (h, seen)\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) if (List.mem(h, seen) = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 120-124:\n   if (List.mem(h, seen) = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\n                           ^^^^\nError: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "min": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if (List.mem (h, seen)) = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) let x = List.mem(h, seen) in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 133-137:\n   let x = List.mem(h, seen) in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\n                                        ^^^^\nError: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "min": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          let x = List.mem (h, seen) in\n          if x = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  let x = List.mem(h, seen) in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 145-149:\n  let seen' =  let x = List.mem(h, seen) in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\n                                                    ^^^^\nError: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          let x = List.mem (h, seen) in\n          if x = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  let x = List.mem h seen in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 154-159:\n  let seen' =  let x = List.mem h seen in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\n                                                             ^^^^^\nError: Unbound value seen'\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          let x = List.mem h seen in\n          if x = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if (List.mem h seen) then seen else List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if List.mem h seen then seen else List.rev (h :: (List.rev seen)) in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if (List.mem h seen) then seen else h :: seen(*List.rev(h:: List.rev(seen))*) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if (List.mem h seen) then seen else h :: seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if (List.mem h seen) then seen else h :: seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet(i, c) = f(b) in\nif(c = true) then wwhile(f, i) else i", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (i,c) = f b in if c = true then wwhile (f, i) else i;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x) in\nwwhile (g,b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (i,c) = f b in if c = true then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (s,x) = h in if s = k then x else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = \nets(e, \"\")", "out": "Characters 26-29:\n  ets(e, \"\");;\n  ^^^\nError: Unbound value ets\n", "min": "\nlet rec exprToString e = ets (e, \"\");;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = failwith \"to be written\"", "out": "", "min": "\nlet rec exprToString e = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "out": "Characters 91-94:\n  | Sine (a) -> sin(pi *. eval(a))\n                              ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval a))\n  | Cosine a -> cos (pi *. (eval a))\n  | Average (a,b) -> ((eval a) +. (eval b)) / 2\n  | Times (a,b) -> (eval a) *. (eval b)\n  | Thresh (a,b,c,d) -> if (eval a) < (eval b) then eval c else eval d;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine a -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "out": "Characters 89-92:\n  | Sine a -> sin(pi *. eval(a))\n                            ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval a))\n  | Cosine a -> cos (pi *. (eval a))\n  | Average (a,b) -> ((eval a) +. (eval b)) / 2\n  | Times (a,b) -> (eval a) *. (eval b)\n  | Thresh (a,b,c,d) -> if (eval a) < (eval b) then eval c else eval d;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a, x, y))\n| Cosine (a) -> cos(pi *. eval(a, x, y))\n| Average (a, b) -> ((eval(a, x, y) +. eval(b, x, y)) / 2)\n| Times (a, b) -> eval(a, x, y) *. eval(b, x, y)\n| Thresh (a, b, c, d) -> if(eval(a, x, y) < eval(b,x ,y)) then  eval(c, x, y) else eval(d, x ,y)", "out": "Characters 164-196:\n  | Average (a, b) -> ((eval(a, x, y) +. eval(b, x, y)) / 2)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a, x, y))\n| Cosine (a) -> cos(pi *. eval(a, x, y))\n| Average (a, b) -> ((eval(a, x, y) +. eval(b, x, y)) / 2.0)\n| Times (a, b) -> eval(a, x, y) *. eval(b, x, y)\n| Thresh (a, b, c, d) -> if(eval(a, x, y) < eval(b,x ,y)) then  eval(c, x, y) else eval(d, x ,y)", "out": "Characters 164-196:\n  | Average (a, b) -> ((eval(a, x, y) +. eval(b, x, y)) / 2.0)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a, x, y))\n| Cosine (a) -> cos(pi *. eval(a, x, y))\n| Average (a, b) -> ((eval(a, x, y) +. eval(b, x, y)) /. 2.0)\n| Times (a, b) -> eval(a, x, y) *. eval(b, x, y)\n| Thresh (a, b, c, d) -> if(eval(a, x, y) < eval(b,x ,y)) then  eval(c, x, y) else eval(d, x ,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = \nlet s = \"\" in\nmatch e with\n| VarX -> s ^ \"x\"\n| VarY -> s ^ \"y\"\n| Sine (a) -> s ^ \"sin(pi*\" ^ exprToString(a) ^\")\"\n| Cosine (a) -> s ^ \"cos(pi*\" ^ exprToString(a) ^ \")\"\n| Average (a, b) -> s ^ \"((\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"/2)\"\n| Times (a, b) -> s ^ exprToString(a) ^ \"*\" ^ exprToString(b)\n| Thresh (a, b, c, d) -> s ^ \"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ exprToString(c) ^ \":\" ^ exprToString(d) ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (s,x) = h in if s = k then x else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX else buildY else let x = rand(0, 5) in\nmatch x with\n| 0 -> buildSine(buildX)\n| 1 -> buildCosine(build(rand, depth -1))\n| 2 -> buildAverage(build(rand, depth -1), build(rand, depth -1))\n| 3 -> buildTimes(build(rand, depth -1), build(rand, depth -1))\n| 4 -> buildThresh(build(rand, depth -1), build(rand, depth -1), build(rand, depth -1), build(rand, depth -1))", "out": "Characters 149-157:\n  | 0 -> buildSine(buildX)\n                  ^^^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine buildX\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX else buildY else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "out": "Characters 145-171:\n  if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)));;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX else buildY else let x = rand(0, 5) in\nif( x = 0) then buildSine(buildX) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "out": "Characters 145-153:\n  if( x = 0) then buildSine(buildX) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)));;\n                           ^^^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine buildX\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "out": "Characters 421-532:\n  if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)));;\n                                                                                                                                                                                                                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "out": "Characters 421-532:\n  if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)));;\n                                                                                                                                                                                                                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))", "out": "Characters 339-399:\n  if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)));;\n                                                                                                                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\n(*if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)\nmatch x with\n| 0 -> buildSine(build(rand, (depth - 1)))\n| 1 -> buildCosine(build(rand, (depth -1)))\n| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))\n| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))\n| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)\n\n\ndoRandomColor(8, 0, 5)", "out": "Error: This function has type\n         (float * float -> float) * (float * float -> float) *\n         (float * float -> float) * int * string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 487-496:\n  emitColor (f1,f2,f3,n,name)\n  ^^^^^^^^^\nError: This function has type\n         (float * float -> float) * (float * float -> float) *\n         (float * float -> float) * int * string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name) doRandomColor (8, 0, 5);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| NewA     of expr * expr\n| NewB     of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewA of expr* expr\n  | NewB of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = \nlet s = \"\" in\nmatch e with\n| VarX -> s ^ \"x\"\n| VarY -> s ^ \"y\"\n| Sine (a) -> s ^ \"sin(pi*\" ^ exprToString(a) ^\")\"\n| Cosine (a) -> s ^ \"cos(pi*\" ^ exprToString(a) ^ \")\"\n| Average (a, b) -> s ^ \"((\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"/2)\"\n| Times (a, b) -> s ^ exprToString(a) ^ \"*\" ^ exprToString(b)\n| Thresh (a, b, c, d) -> s ^ \"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ exprToString(c) ^ \":\" ^ exprToString(d) ^ \")\"\n| NewA(a, b) -> s ^ \"sin(pi*\"^ exprToString(a) ^ \")*cos(pi*\"^ exprToString(b) ^ \")\"\n| NewB(a, b, c) -> s ^ \"(\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"+\" ^ exprToString(c) ^ \")^0\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewA of expr* expr\n  | NewB of expr* expr* expr;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))))\n  | NewA (a,b) ->\n      s ^\n        (\"sin(pi*\" ^\n           ((exprToString a) ^ (\")*cos(pi*\" ^ ((exprToString b) ^ \")\"))))\n  | NewB (a,b,c) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"+\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")^0\"))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = \nlet s = \"\" in\nmatch e with\n| VarX -> s ^ \"x\"\n| VarY -> s ^ \"y\"\n| Sine (a) -> s ^ \"sin(pi*\" ^ exprToString(a) ^\")\"\n| Cosine (a) -> s ^ \"cos(pi*\" ^ exprToString(a) ^ \")\"\n| Average (a, b) -> s ^ \"((\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"/2)\"\n| Times (a, b) -> s ^ exprToString(a) ^ \"*\" ^ exprToString(b)\n| Thresh (a, b, c, d) -> s ^ \"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ exprToString(c) ^ \":\" ^ exprToString(d) ^ \")\"\n| NewA(a, b) -> s ^ \"sin(pi*\"^ exprToString(a) ^ \")*cos(pi*\"^ exprToString(b) ^ \")\"\n| NewB(a, b, c) -> s ^ \"(\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"+\" ^ exprToString(c) ^ \")-\" ^ \"(\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"+\" ^ exprToString(c) ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewA of expr* expr\n  | NewB of expr* expr* expr;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))))\n  | NewA (a,b) ->\n      s ^\n        (\"sin(pi*\" ^\n           ((exprToString a) ^ (\")*cos(pi*\" ^ ((exprToString b) ^ \")\"))))\n  | NewB (a,b,c) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"+\" ^\n                 ((exprToString b) ^\n                    (\"+\" ^\n                       ((exprToString c) ^\n                          (\")-\" ^\n                             (\"(\" ^\n                                ((exprToString a) ^\n                                   (\"+\" ^\n                                      ((exprToString b) ^\n                                         (\"+\" ^ ((exprToString c) ^ \")\")))))))))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\n(*if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)\nmatch x with\n| 0 -> buildSine(build(rand, (depth - 1)))\n| 1 -> buildCosine(build(rand, (depth -1)))\n| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))\n| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))\n| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))\n| 6 -> buildNewA(build(rand, (depth -1)), build(rand, (depth -1)))\n| 7 -> buildNewB(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth - 1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewA of expr* expr\n  | NewB of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNewA (a,b) = NewA (a, b);;\n\nlet buildNewB (a,b,c) = NewB (a, b, c);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildNewA ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildNewB\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
