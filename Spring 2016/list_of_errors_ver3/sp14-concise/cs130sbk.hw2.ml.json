{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> if k' = k then v' else acc tl\n| [] -> d\n| _ -> failwith \"to be written\"\nin\nacc l", "min": "\nlet rec assoc (d,k,l) =\n  let rec acc xs =\n    match xs with\n    | (k',v')::tl -> if k' = k then v' else acc tl\n    | [] -> d\n    | _ -> failwith \"to be written\" in\n  acc l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nacc tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"\nin\nacc l", "min": "\nlet rec assoc (d,k,l) =\n  let rec acc xs =\n    match xs with\n    | (k',v')::tl -> if k' = k then v' else acc tl\n    | [] -> d\n    | _ -> failwith \"This ain't your mom's hashmap\" in\n  acc l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen h :: seen \nelse seen  \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f b in match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f b in match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (let xx = f x in (x, (f x) = x),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (let xx = f x in ((x, ((f x) = x)), b));;\n", "out": "Characters 40-41:\n  let fixpoint (f,b) = wwhile (let xx = f x in (x, (f x) = x),b);;\n                                          ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (let xx = f xx in (xx, (f xx) = xx),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (let xx = f xx in ((xx, ((f xx) = xx)), b));;\n", "out": "Characters 40-42:\n  let fixpoint (f,b) = wwhile (let xx = f xx in (xx, (f xx) = xx),b);;\n                                          ^^\nError: Unbound value xx\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile (fun xx -> ((xx, f xx = xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (fun xx  -> ((xx, ((f xx) = xx)), b));;\n", "out": "Characters 28-59:\n  let fixpoint (f,b) = wwhile (fun xx -> ((xx, f xx = xx)),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile (fun xx -> (xx, f xx = xx),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (fun xx  -> ((xx, ((f xx) = xx)), b));;\n", "out": "Characters 28-57:\n  let fixpoint (f,b) = wwhile (fun xx -> (xx, f xx = xx),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, f xx = xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "fixpoint (g,0) should return 739085", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0) should return 739085;;\n", "out": "Characters 10-11:\n  fixpoint (g,0) should return 739085;;\n            ^\nError: This expression has type int -> int\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd) -> 'a -> 'b -> 'c -> 'd\n       Type int is not compatible with type 'a -> 'b -> 'c -> 'd \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile (fun xx -> (xx, (f xx) = xx)),b", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = ((wwhile (fun xx  -> (xx, ((f xx) = xx)))), b);;\n", "out": "Characters 28-57:\n  let fixpoint (f,b) = wwhile (fun xx -> (xx, (f xx) = xx)),b;;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) != xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) != xx))), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0.5)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0.5);;\n", "out": "Characters 0-8:\n  fixpoint (g,0.5);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g, 700000)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 700000);;\n", "out": "Characters 0-8:\n  fixpoint (g, 700000);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, not ((f xx) = xx))),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, (not ((f xx) = xx)))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun xx -> (xx, not ((f xx) = xx))),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g, 700000)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 700000);;\n", "out": "Characters 0-8:\n  fixpoint (g, 700000);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, not ((f xx) = xx))),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, (not ((f xx) = xx)))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun xx -> (xx, not ((f xx) = xx))),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\n| b' -> b'\nin\nacc b", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' | b' -> b' in\n  acc b;;\n", "out": "Characters 129-131:\n  | b' -> b'\n          ^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) != xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 100);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) != xx))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 )", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in\n  fixpoint (g, 739085);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 );;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in\n  fixpoint (g, 739080);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 );;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in\n  fixpoint (g, 739080);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 );;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 );;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 );;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 );;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf x\n| VarY y -> sprintf y in\nacc e\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n", "out": "Characters 68-74:\n  | VarX x -> sprintf x\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf x\n| VarY y -> sprintf y in\nacc e\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n", "out": "Characters 68-74:\n  | VarX x -> sprintf x\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf \"%s\" x | VarY y -> sprintf \"%s\" y in\n  acc e exprToString VarX;;\n", "out": "Characters 68-74:\n  | VarX x -> sprintf \"%s\" x\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf \"%s\" x | VarY y -> sprintf \"%s\" y in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 68-74:\n  | VarX x -> sprintf \"%s\" x\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY y -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 90-96:\n  | VarY y -> sprintf \"y\" in\n    ^^^^^^\nError: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY y -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 90-96:\n  | VarY y -> sprintf \"y\" in\n    ^^^^^^\nError: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 75-82:\n  | VarX-> sprintf \"x\" \n           ^^^^^^^\nError: Unbound value sprintf\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 75-82:\n  | VarX-> sprintf \"x\" \n           ^^^^^^^\nError: Unbound value sprintf\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> printf \"x\" \n| VarY -> printf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> printf \"x\" | VarY  -> printf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 75-81:\n  | VarX-> printf \"x\" \n           ^^^^^^\nError: Unbound value printf\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> Printf.sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 105-112:\n  | VarY -> sprintf \"y\" in\n            ^^^^^^^\nError: Unbound value sprintf\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 127-130:\n  acc e \"\"\n  ^^^\nError: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 131-134:\n  acc e \"\"\n  ^^^\nError: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "out": "Characters 131-134:\n  acc e \"\"\n  ^^^\nError: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\"\n\nexprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\" exprToString VarX;;\n", "out": "Characters 132-136:\n  accu e \"\"\n  ^^^^\nError: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n\nlet _ = exprToString VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nmatch e with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x   -> Printf.srprintf \"Sine(%s)\" exprToString x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.srprintf \"Sine(%s)\" exprToString x;;\n", "out": "Characters 114-129:\n  | Sine x   -> Printf.srprintf \"Sine(%s)\" exprToString x;;\n                ^^^^^^^^^^^^^^^\nError: Unbound value Printf.srprintf\nHint: Did you mean sprintf?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = \nmatch e with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x   -> Printf.sprintf \"Sine(%s)\" exprToString x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n", "out": "Characters 129-139:\n  | Sine x   -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n                               ^^^^^^^^^^\nError: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine\\(%s\\)\" exprToString x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine\\\\(%s\\\\)\" exprToString x;;\n", "out": "Characters 128-140:\n  | Sine x -> Printf.sprintf \"Sine\\(%s\\)\" exprToString x;;\n                             ^^^^^^^^^^^^\nError: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n", "out": "Characters 128-138:\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n                             ^^^^^^^^^^\nError: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "out": "Characters 0-12:\n  exprToString Sine(VarX);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "out": "Characters 0-12:\n  exprToString Sine(VarX);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "out": "Characters 0-12:\n  exprToString Sine(VarX);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nacc tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"\nin\nacc l", "min": "\nlet rec assoc (d,k,l) =\n  let rec acc xs =\n    match xs with\n    | (k',v')::tl -> if k' = k then v' else acc tl\n    | [] -> d\n    | _ -> failwith \"This ain't your mom's hashmap\" in\n  acc l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n\nexprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x ->\n      Printf.sprintf \"Sine(%s)\" (exprToString x) exprToString Sine VarX;;\n", "out": "Characters 96-106:\n  | Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n                              ^^^^^^^^^^\nError: This expression has type\n         ('a -> 'b -> 'c -> 'd, unit, string, string, string,\n          'a -> 'b -> 'c -> 'd)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd is not compatible with type string \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "out": "Characters 0-12:\n  exprToString Sine(VarX);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "out": "Characters 0-12:\n  exprToString Sine(VarX);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet _ = exprToString Sine VarX;;\n", "out": "Characters 0-12:\n  exprToString Sine(VarX);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sine(VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet _ = exprToString Sine VarX;;\n", "out": "Characters 0-12:\n  exprToString Sine(VarX);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine(x) -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average(x, y) -> Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times ()\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times ()|_ -> failwith \"are we writing a lisp compiler now\";;\n", "out": "Characters 280-288:\n  | Times ()\n    ^^^^^^^^\nError: The constructor Times expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\nexprToString e1\nexprToString e2\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) -> Printf.sprintf \"%s*%s\" exprToString e1 exprToString e2\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": "Characters 313-320:\n  | Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n                                     ^^^^^^^\nError: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) * eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 154-168:\n  | Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2\n                        ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 153-187:\n  | Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*eval(e', x, y))\n| Cosine(e') -> cos(pi*eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval (e', x, y)))\n  | Cosine e' -> cos (pi * (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 80-82:\n  | Sine(e') -> sin(pi*eval(e', x, y))\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc d k tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc d k tl\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": "Characters 91-92:\n  assoc d k tl\n        ^\nError: This expression has type 'a but an expression was expected of type\n         'a * 'b * ('b * ('c -> 'd -> 'e)) list\n       The type variable 'a occurs inside\n       'a * 'b * ('b * ('c -> 'd -> 'e)) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then wwhile (f, b') else b'", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(|%s|)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(|%s|)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Abs      of expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(|%s|)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(|%s|)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> abs (eval e) ^. 0.5 \n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> (abs (eval e)) ^. 0.5\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 389-391:\n  | Sqrt (e) -> abs (eval e) ^. 0.5 \n                             ^^\nError: Unbound value ^.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval e))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs (eval e))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 392-393:\n  | Sqrt (e) -> sqrt (abs (eval e))\n                                ^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 386-402:\n  | Sqrt (e) -> sqrt (abs (eval (e, x, y)))\n                          ^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (absF (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (absF (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 382-386:\n  | Sqrt (e) -> sqrt (absF (eval (e, x, y)))\n                      ^^^^\nError: Unbound value absF\nHint: Did you mean abs?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> 0", "min": "\nlet rec build (rand,depth) = match depth with | 0 -> 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = match depth with | 0 -> 0;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type int but an expression was expected of type\n         expr\n"}, {"type": "type", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = match depth with | 0 -> 0;;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 216-218:\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n                                                      ^^\nError: This expression has type int but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> 0\n| _ -> build(rand, depth - 1)", "min": "\nlet rec build (rand,depth) =\n  match depth with | 0 -> 0 | _ -> build (rand, (depth - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> build(rand, depth - 1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> build(rand, depth - 1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then wwhile (f, b') else b'", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> build(rand, depth - 1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Abs      of expr\n| Quad     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Quad (e1, e2, e3) -> Printf.sprintf \"(%s + %s)^2 + %s\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Quad (e1,e2,e3) ->\n      Printf.sprintf \"(%s + %s)^2 + %s\" (exprToString e1) (exprToString e2)\n        (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildSqrt(e)                   = Sqrt(Abs(e))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \nMath.pow ((eval (e1, x, y) + \neval (e2, x, y)), 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (Math.pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) +\n        (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 434-442:\n  Math.pow ((eval (e1, x, y) + \n  ^^^^^^^^\nError: Unbound module Math\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \nmath.pow ((eval (e1, x, y) + \neval (e2, x, y)), 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (math.pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) +\n        (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 434-438:\n  math.pow ((eval (e1, x, y) + \n  ^^^^\nError: Unbound value math\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) + \neval (e2, x, y)) ** 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 436-451:\n  ((eval (e1, x, y) + \n    ^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) + \neval (e2, x, y)) ** 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 436-451:\n  ((eval (e1, x, y) + \n    ^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) + \neval (e2, x, y)) **. 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) **. 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 472-475:\n  eval (e2, x, y)) **. 2)\n                   ^^^\nError: Unbound value **.\nHint: Did you mean *. or **?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) + \neval (e2, x, y)) ** 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 436-451:\n  ((eval (e1, x, y) + \n    ^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) +. \neval (e2, x, y)) ** 2)\n+. eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 476-477:\n  eval (e2, x, y)) ** 2)\n                      ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n(eval (e1, x, y) +. \neval (e2, x, y)) ** 2\n+. eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 475-476:\n  eval (e2, x, y)) ** 2\n                      ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n(eval (e1, x, y) +. \neval (e2, x, y)) ** 2.0\n+. eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2.0) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \neval (e1, x, y) ** 2.0 +.  \neval (e1, x, y) * eval (e2, x, y) +. \neval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e1, x, y)) * (eval (e2, x, y))))\n        +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": "Characters 462-477:\n  eval (e1, x, y) * eval (e2, x, y) +. \n  ^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \neval (e1, x, y) ** 2.0 +.  \neval (e1, x, y) *. eval (e2, x, y) +. \neval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e1, x, y)) *. (eval (e2, x, y))))\n        +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Quad (e1, e2, e3) -> Printf.sprintf \"(%s^2 + %s*%s + %s\"\n(exprToString e1)\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Quad (e1,e2,e3) ->\n      Printf.sprintf \"(%s^2 + %s*%s + %s\" (exprToString e1) (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Abs      of expr\n| Gauss    of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) \n-. 1.0\n\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv\n\neval_fn Gauss (1, 1)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in\n  assert (((-1.0) <= rv) && (rv <= 1.0)); rv eval_fn Gauss (1, 1);;\n", "out": "Characters 82-84:\n  rv\n  ^^\nError: This expression has type float\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Gauss (e1, e2, e3) -> Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage  next next\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage next next\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "out": "Characters 179-191:\n  | 3 -> buildAverage  next next\n         ^^^^^^^^^^^^\nError: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next next)\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "out": "Characters 193-197:\n  | 3 -> buildAverage (next next)\n                       ^^^^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "out": "Characters 212-222:\n  | 4 -> buildTimes next next\n         ^^^^^^^^^^\nError: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\n\ndoRandomGray (7, 150, 200)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next) doRandomGray (7, 150, 200));;\n", "out": "Error: This function has type expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 309-319:\n  | 7 -> buildGauss (next, next, next)\n         ^^^^^^^^^^\nError: This function has type expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> match rand (1, 2) with\n| 1 -> buildX\n| 2 -> buildY\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n", "out": "Characters 189-193:\n  | 1-> buildSine next\n                  ^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> match rand (1, 2) with\n| 1 -> buildX\n| 2 -> buildY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n", "out": "Characters 185-189:\n  | 1-> buildSine next\n                  ^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "out": "Characters 189-193:\n  | 1-> buildSine next\n                  ^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "out": "Characters 189-193:\n  | 1-> buildSine next\n                  ^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n1 -> VarX\n| 2 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) \n-. 1.0\n\n| _ -> failwith Printf.sprintf \"Expression %s\" e", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith Printf.sprintf \"Expression %s\" e;;\n", "out": "Characters 536-550:\n  | _ -> failwith Printf.sprintf \"Expression %s\" e;;\n                  ^^^^^^^^^^^^^^\nError: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) \n-. 1.0\n\n| _ -> failwith Printf.sprintf  e", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith Printf.sprintf e;;\n", "out": "Characters 536-550:\n  | _ -> failwith Printf.sprintf  e;;\n                  ^^^^^^^^^^^^^^\nError: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildSqrt(e)                   = Sqrt(e)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildSqrt e = Sqrt e;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildAbs(e)\t\t\t   = Abs(e)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAbs e = Abs e;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildAbs(e)\t\t\t   = Abs(e)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAbs e = Abs e;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildGauss(e1,e2,e3)           = Gauss(e1,e2,e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n1 -> VarX\n| 2 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n|1 -> VarX\n| 2 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (0, 1) with\n| 1 -> VarX\n| 0 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 1 -> VarX | 0 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (0, 1) with\n| 0 -> VarX\n| 1 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (0, 1) with\n0 -> VarX\n| 1 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (0, 1) with\n0 -> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 1) with\n0 -> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 1) with | 0 -> VarX | 1 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n0 -> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 0 -> VarX | 1 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n|1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n|1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 1) with\n| 0-> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| _ -> abs next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> abs next);;\n", "out": "Characters 564-568:\n  | _ -> abs next);;\n             ^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| _ -> buildAbs next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAbs e = Abs e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildAbs next);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAbs e = Abs e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildAbs next);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp -(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) \n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((2.0 *. exp) -\n         ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n            (eval (e3, x, y))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": "Characters 441-444:\n  2.0 *.exp -(\n        ^^^\nError: This expression has type float -> float\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (-(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) )\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                  (eval (e3, x, y))))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": "Characters 447-512:\n  ............(\n  (eval (e1, x, y) -. \n  eval (e2, x, y))** 2.0 \n  /. eval (e3, x,y))..\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (-(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)))\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                  (eval (e3, x, y))))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": "Characters 447-512:\n  ............(\n  (eval (e1, x, y) -. \n  eval (e2, x, y))** 2.0 \n  /. eval (e3, x,y)).\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n-(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (((- ((eval (e1, x, y)) -. (eval (e2, x, y)))) ** 2.0) /.\n              (eval (e3, x, y))));;\n", "out": "Characters 448-485:\n  .(eval (e1, x, y) -. \n  eval (e2, x, y)).......\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp ~-.(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp ~-.(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y))-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-.\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                  (eval (e3, x, y))))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Gauss (e1, e2, e3) -> Printf.sprintf \"2*(e^(-((%s-%s)/%s)^2) - 1\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(-((%s-%s)/%s)^2) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0)\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-.\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) /.\n                   (eval (e3, x, y)))\n                  ** 2.0))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) * sqrt (2 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) * (sqrt (2 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": "Characters 514-529:\n  eval (e3, x,y))** 2.0) /. (eval (e3, x, y) * sqrt (2 *. pi))\n                             ^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) *. sqrt (2 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) *. (sqrt (2 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": "Characters 539-540:\n  eval (e3, x,y))** 2.0) /. (eval (e3, x, y) *. sqrt (2 *. pi))\n                                                      ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) *. (sqrt (2.0 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) *. (sqrt (2.0 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp (~-.(\n((eval (e1, x, y) -. eval (e2, x, y)) \n/. eval (e3, x,y)) ** 2.0)) \n/. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) *. (sqrt (2.0 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp (~-.(\n((eval (e1, x, y) -. eval (e2, x, y)) \n/. eval (e3, x,y)) ** 2.0)) \n/. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) *. (sqrt (2.0 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Abs      of expr\n| Logistic   of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\"\n(exprToString e1)\n(exprToString e2)\n(exprToString Abs(e3))\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\" (exprToString e1)\n        (exprToString e2) (exprToString Abs e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": "Characters 717-729:\n  (exprToString Abs(e3))\n   ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\"\n(exprToString e1)\n(exprToString e2)\n(exprToString (Abs(e3)))\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\" (exprToString e1)\n        (exprToString e2) (exprToString (Abs e3))\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1 - exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ^ eval (e3, x, y))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1 - (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "out": "Characters 451-497:\n  (2.0 /. (1 - exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ^ eval (e3, x, y))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "out": "Characters 439-508:\n  .2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n  -. 1.0)...................\nError: This expression has type float but an expression was expected of type\n         string\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ^ eval (e3, x, y))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "out": "Characters 439-508:\n  .2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n  -. 1.0)...................\nError: This expression has type float but an expression was expected of type\n         string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^%s\"\n(exprToString e1)\n(exprToString e2)\n(exprToString (Abs(e3)))\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^%s\" (exprToString e1)\n        (exprToString e2) (exprToString (Abs e3))\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) *8 eval (e3, x, y))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        * (8 eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "out": "Characters 439-508:\n  .2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n  -. 1.0)....................\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ** eval (e3, x, y))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ** eval (e3, x, y))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))\n-. 1.0))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        ((1.0 -.\n            (exp\n               (-.\n                  (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                     (eval (e3, x, y))))))\n           -. 1.0)\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        ((1.0 -.\n            (exp\n               (-.\n                  (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                     (eval (e3, x, y))))))\n           -. 1.0)\n  | _ -> failwith \"error\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(1.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(1.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(1.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(1.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))))\n| _ -> failwith \"error\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 1) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      1.0 /.\n        (1.0 -.\n           (exp\n              (-.\n                 (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                    (eval (e3, x, y))))))\n  | _ -> failwith \"error\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(1/(1+e^(-%s*%s*%s)))\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(1/(1+e^(-%s*%s*%s)))\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLogistic (e1,e2,e3) = Logistic (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 6) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildLogistic\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc (d, k, tl)\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "out": ""}]}
