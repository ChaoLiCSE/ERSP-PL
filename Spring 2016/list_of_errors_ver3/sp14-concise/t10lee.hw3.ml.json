{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs", "out": "Characters 73-77:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = [] in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 31-32:\n  let f a x = a**2 + x in\n                 ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs =\n  let f a x = (a ** 2) + x in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a^2 + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 30-35:\n  let f a x = a^2 + x in\n                ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet sqsum xs =\n  let f a x = a ^ (2 + x) in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a^^2 + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 31-36:\n  let f a x = a^^2 + x in\n                 ^^^^^\nError: This expression has type int but an expression was expected of type\n         ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n           ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n", "min": "\nlet sqsum xs =\n  let f a x = a ^^ (2 + x) in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = match x with\n| [] -> (fun b -> b)\nin\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 97-101:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> (fun b  -> b) in\n  let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> x a\nin\nlet base = (fun _ x -> x) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> x a in\n  let base _ x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z d -> x d)\nin\nlet base = (fun _ y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> fun d  -> x d) in\n  let base _ y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z d -> x d )\nin\nlet base = (fun _ y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> fun d  -> x d) in\n  let base _ y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z -> x  )\nin\nlet base = (fun c y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> x) in\n  let base c y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z -> x  )\nin\nlet base = (fun _ y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> x) in\n  let base _ y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z -> x  )\nin\nlet base = (fun y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> x) in\n  let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z -> x )\nin\nlet base = (fun y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> x) in\n  let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = (fun b -> x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x b = x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = (fun b a -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x b a = a x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = (fun b c -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "out": "Characters 88-89:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'c -> 'b\n", "min": "\nlet pipe fs =\n  let f a x b c = a x in let base y = y in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = (fun y -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x y = a x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = (fun y -> a x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x y = a x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun c -> y ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "Characters 38-39:\n  let f a x = ( fun c -> y ) in\n                         ^\nError: Unbound value y\n", "min": "\nlet pipe fs = let f a x c = y in let base b = b in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x c = x in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun c -> f a x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "Characters 38-39:\n  let f a x = ( fun c -> f a x ) in\n                         ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x c = f a x in let base b = b in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun c -> f (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "Characters 38-39:\n  let f a x = ( fun c -> f (a x) ) in\n                         ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x c = f (a x) in let base b = b in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun c -> fun d -> (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "Characters 100-101:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'c -> 'b\n", "min": "\nlet pipe fs =\n  let f a x c d = a x in let base b = b in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun x -> f (g x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "Characters 38-39:\n  let f a x = ( fun x -> f (g x) ) in\n                         ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x x = f (g x) in let base b = b in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun y -> a (y x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "Characters 93-94:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n", "min": "\nlet pipe fs =\n  let f a x y = a (y x) in let base b = b in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = ( fun y -> x (a y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ cc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "Characters 96-98:\n  let f a x = (fun acc x -> x ^ cc) in\n                                ^^\nError: Unbound value cc\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ cc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "Characters 151-155:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type string but an expression was expected of type\n         string -> string -> string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "Characters 133-156:\n  List.fold_left f base l;;\n  ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string -> string -> string\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "Characters 151-155:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type string but an expression was expected of type\n         string -> string -> string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ h ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (h ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" ^ h ^ \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" ^ (h ^ \"\") in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base =  h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map f l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat \";\") l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \";\") l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map f (sepConcat \";\") l", "out": "Characters 24-32:\n  List.map f (sepConcat \";\") l;;\n  ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \";\") l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]", "out": "Characters 50-63:\n  | _ -> clone x (n-1) :: [h];;\n         ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x (n - 1); h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [x]", "out": "Characters 50-63:\n  | _ -> clone x (n-1) :: [x];;\n         ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x (n - 1); x];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = match n with\n| 0 -> []\n| 1 -> clone x (n-1) :: [x]", "out": "Characters 50-63:\n  | 1 -> clone x (n-1) :: [x];;\n         ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n = match n with | 0 -> [] | 1 -> [clone x (n - 1); x];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "out": "", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = match n with\n| 0 -> []\n| a -> if a < 0 then [] else clone x (n-1) @ [x]", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 > List.length l2)\nthen (List.append (clone 0 (List.length l1 - List.length l2)) l2, l1)\nelse (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then ((List.append (clone 0 ((List.length l1) - (List.length l2))) l2), l1)\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 > List.length l2)\nthen (List.append (clone 0 (List.length l1 - List.length l2)) l2, l1)\nelse (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then ((List.append (clone 0 ((List.length l1) - (List.length l2))) l2), l1)\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> l\n| h::t -> if h = 0 then removeZero t", "out": "Characters 70-82:\n  | h::t -> if h = 0 then removeZero t;;\n                          ^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t", "out": "Characters 71-83:\n  | h::t -> if h = 0 then removeZero t;;\n                          ^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> l\n| h::t ->\nif h = 0 \nthen removeZero t\nelse l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif (List.length l1 > List.length l2)\nthen (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)\nelse (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a::x in\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 127-128:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if t1 + t2 then [t1+t2]\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 109-111:\n  | ([h1::t1],[h2::t2]) -> if t1 + t2 then [t1+t2]\n                              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if t1 + t2 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if t1 + t2 > 9 then [t1+t2]\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 109-111:\n  | ([h1::t1],[h2::t2]) -> if t1 + t2 > 9 then [t1+t2]\n                              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (t1 + t2) > 9 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [h1+h2]\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 127-133:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [h1+h2]\n                                                ^^^^^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [h1 + h2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then []\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 126-128:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then []\n                                               ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [1+h1] @ a\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 126-136:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [1+h1] @ a\n                                               ^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [1 + h1] @ a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [1+h1] @ a\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 126-136:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [1+h1] @ a\n                                               ^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [1 + h1] @ a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then false\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 126-131:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then false\n                                               ^^^^^\nError: This variant expression is expected to have type unit\n       The constructor false does not belong to type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then false in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> 0\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then 9\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 125-126:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then 9\n                                               ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then 9 in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then x a\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 126-127:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then x a\n                                               ^\nError: This expression has type int list list * int list list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> a\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then x \nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 125-126:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then x \n                                               ^\nError: This expression has type int list list * int list list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> a\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 129-130:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\n                                                   ^\nError: This expression has type int list list * int list list\n       but an expression was expected of type 'a list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> 0\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 129-130:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\n                                                   ^\nError: This expression has type int list list * int list list\n       but an expression was expected of type 'a list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> 0 :: a\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 134-135:\n  | ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\n                                                   ^\nError: This expression has type int list list * int list list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0 :: a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> 0\n| h::t-> if h > 9 then 8\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 98-99:\n  | h::t-> if h > 9 then 8\n                         ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> 0 | h::t -> if h > 9 then 8 in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x*x\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 129-133:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (x * x) in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a :: x\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 126-127:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x::a\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 109-135:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x :: a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 127-131:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x\nin\nlet base = 0 in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 109-135:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet a = h::t in \nmatch x with\n| (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 61-62:\n  let a = h::t in \n          ^\nError: Unbound value h\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let a = h :: t in\n      match x with\n      | (x1,x2) ->\n          if ((x1 + x2) + h) > 9 then 1 :: (h = ((x1 + x2) + (h mod 10))) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 114-116:\n  | h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\n                                               ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: (h = ((x1 + x2) + (h mod 10))) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 114-116:\n  | h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\n                                               ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 115-117:\n  | h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))\n                                                ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 118-120:\n  | h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\n                                                   ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)::t2) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9(*1 :: (x1 + x2 + h mod 10) *)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 116-117:\n  | h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9\n                                                 ^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | (h::t,(x1,x2)::t2) -> if ((x1 + x2) + h) > 9 then 9 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 182-186:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| h -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 156-182:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h1) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 71-73:\n  | (h1,h1) -> []\n        ^^\nError: Variable h1 is bound several times in this matching\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h1) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 162-188:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> (h2,h1)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 184-188:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (h2, h1) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 164-190:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 163-189:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\n(add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 187-188:\n  | (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\n                                                                       ^\nError: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g)::t ->\n            if ((f + g) + carry) > 9\n            then (1, (((f + g) + (carry mod 10)) :: t))\n            else (0, (((f + g) + (carry mod 10)) :: t)) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 183-184:\n  | (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\n                                                                   ^\nError: Unbound value t\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, (((f + g) + (carry mod 10)) :: t))\n            else (0, (((f + g) + (carry mod 10)) :: t)) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 321-325:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,[g])-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 321-322:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int * 'a list -> int * int -> int * int\n       but an expression was expected of type\n         int * 'a list -> int * int -> int * 'a list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g::[]) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 321-325:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newcarry, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 255-263:\n  | (o,p) -> (newcarry, digit::p)\n              ^^^^^^^^\nError: Unbound value newcarry\nHint: Did you mean carry?\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> (f + g) + (carry mod 10) in\n      match a with | (o,p) -> (newcarry, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> (f + g) + (carry mod 10) in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\n| []   -> carry\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 230-232:\n  | []   -> carry\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * int\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit =\n        match x with | (f,g) -> ((f + g) + carry) mod 10 | [] -> carry in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g::h)-> g\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g::h) -> g in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, newc::digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p::q) -> (newc, digit::q)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p::q) -> (newc, (digit :: q)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p::q) -> (newc, digit::q)\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (newc, (digit :: q))\n      | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (0, newc::digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p::q) -> (0, newc::digit::q)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p::q) -> (0, (newc :: digit :: q)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p::q) -> (0, newc::digit::q)\n| (o,p) -> (0, newc::digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit i-1 l) (mulByDigit i-1 l)", "out": "Characters 74-86:\n  bigAdd (mulByDigit i-1 l) (mulByDigit i-1 l);;\n          ^^^^^^^^^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then l\n  else\n    (let a = [i] in bigAdd ((mulByDigit i) - (1 l)) ((mulByDigit i) - (1 l)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then l\n  else (let a = [i] in bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then l else bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = bigAdd a x in\nlet base = [] in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 241-267:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd a x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 67-68:\n  | (_,y) -> (0, bigAdd a x) in\n                        ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd a x)) in\n  let base = (0, []) in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd y x)) in\n  let base = (0, []) in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin List.rev unzeroed", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ =\n  let unzeroed =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n    constructargs [] [1; 2; 3] (List.rev [4; 5; 6]) in\n  List.rev unzeroed;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist 0)\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed", "out": "Characters 290-291:\n  | _ -> addZeroes (num-1) (List.append somelist 0)\n                                                 ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ =\n  let unzeroed =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n    constructargs [] [1; 2; 3] (List.rev [4; 5; 6]) in\n  let rec addZeroes num somelist =\n    match num with\n    | 0 -> somelist\n    | _ -> addZeroes (num - 1) (List.append somelist 0) in\n  let rec addZeroesWhole acc a =\n    match a with\n    | [] -> acc\n    | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n  addZeroesWhole [] unzeroed;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ =\n  let unzeroed =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n    constructargs [] [1; 2; 3] (List.rev [4; 5; 6]) in\n  let rec addZeroes num somelist =\n    match num with\n    | 0 -> somelist\n    | _ -> addZeroes (num - 1) (List.append somelist [0]) in\n  let rec addZeroesWhole acc a =\n    match a with\n    | [] -> acc\n    | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n  addZeroesWhole [] unzeroed;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] l1 (List.rev l1)\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd y x)) in\n  let base = (0, []) in\n  let args =\n    let unzeroed =\n      let rec constructargs acc a b =\n        match b with\n        | [] -> acc\n        | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n      constructargs [] l1 (List.rev l1) in\n    let rec addZeroes num somelist =\n      match num with\n      | 0 -> somelist\n      | _ -> addZeroes (num - 1) (List.append somelist [0]) in\n    let rec addZeroesWhole acc a =\n      match a with\n      | [] -> acc\n      | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n    addZeroesWhole [] unzeroed in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd y x)) in\n  let base = (0, []) in\n  let args =\n    let unzeroed =\n      let rec constructargs acc a b =\n        match b with\n        | [] -> acc\n        | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n      constructargs [] l1 (List.rev l2) in\n    let rec addZeroes num somelist =\n      match num with\n      | 0 -> somelist\n      | _ -> addZeroes (num - 1) (List.append somelist [0]) in\n    let rec addZeroesWhole acc a =\n      match a with\n      | [] -> acc\n      | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n    addZeroesWhole [] unzeroed in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "out": "Characters 76-96:\n  bigAdd (mulByDigit (i-1) l)  l;;\n         ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then 0 else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then [0]\n  else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then [0]\n  else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd y x)) in\n  let base = (0, []) in\n  let args =\n    let unzeroed =\n      let rec constructargs acc a b =\n        match b with\n        | [] -> acc\n        | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n      constructargs [] l1 (List.rev l2) in\n    let rec addZeroes num somelist =\n      match num with\n      | 0 -> somelist\n      | _ -> addZeroes (num - 1) (List.append somelist [0]) in\n    let rec addZeroesWhole acc a =\n      match a with\n      | [] -> acc\n      | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n    addZeroesWhole [] unzeroed in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then [0]\n  else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd y x)) in\n  let base = (0, []) in\n  let args =\n    let unzeroed =\n      let rec constructargs acc a b =\n        match b with\n        | [] -> acc\n        | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n      constructargs [] l1 (List.rev l2) in\n    let rec addZeroes num somelist =\n      match num with\n      | 0 -> somelist\n      | _ -> addZeroes (num - 1) (List.append somelist [0]) in\n    let rec addZeroesWhole acc a =\n      match a with\n      | [] -> acc\n      | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n    addZeroesWhole [] unzeroed in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
