{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a + f x in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a + (f x) in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 31-32:\n  let f a x = a + f x in\n                  ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a + f x in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a + (f x) in let base = x in List.fold_left f base fs;;\n", "out": "Characters 31-32:\n  let f a x = a + f x in\n                  ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a + x a in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a + (x a) in let base = x in List.fold_left f base fs;;\n", "out": "Characters 49-50:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  1 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a = x a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a = (x a) in List.fold_left f base fs;;\n", "out": "Characters 55-59:\n  List.fold_left f base fs;;\n                   ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = x a in\nlet base = (fun x -> x) in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 83-87:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = x a in\nlet base = (fun x -> x) in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 83-87:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = x a in\nlet base = (fun x -> x) in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 83-87:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 81-85:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 81-85:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = x a in\nlet base = 0 in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (x a) in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 72-76:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a = f (a y) in\nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (f (a y)) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 31-32:\n  let f a x = a = f (a y) in\n                  ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a = x (a y) in\nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (x (a y)) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 36-37:\n  let f a x = a = x (a y) in\n                       ^\nError: Unbound value y\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 81-85:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = fun x a -> x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> x a) in\n  let base x = x in List.fold_left f base fs;;\n", "out": "Characters 91-92:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type (('a -> 'b) -> 'a -> 'b) -> 'c -> bool\n       but an expression was expected of type\n         (('a -> 'b) -> 'a -> 'b) -> 'c -> ('a -> 'b) -> 'a -> 'b\n       Type bool is not compatible with type ('a -> 'b) -> 'a -> 'b \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = fun x a t-> x (a t) in \nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> fun t  -> x (a t)) in\n  let base x = x in List.fold_left f base fs;;\n", "out": "Characters 96-97:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type\n         (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) -> 'd -> bool\n       but an expression was expected of type\n         (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) ->\n         'd -> ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b\n       Type bool is not compatible with type\n         ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = (fun x y -> x (a y)) in \nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n", "out": "Characters 45-50:\n  let f a x = a = (fun x y -> x (a y)) in \n                                ^^^^^\nError: This expression has type ('a -> 'b) -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a = fun y ->  x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a = (fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n", "out": "Characters 94-95:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> ('b -> 'b) -> bool\n       but an expression was expected of type\n         ('a -> 'b) -> ('b -> 'b) -> 'a -> 'b\n       Type bool is not compatible with type 'a -> 'b \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =  a x in \nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 77-78:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  fun y -> x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \"[\" ^ List.map sepConcat \";\" l ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat \";\" l) ^ \"]\");;\n", "out": "Characters 29-37:\n  let stringOfList f l = \"[\" ^ List.map sepConcat \";\" l ^ \"]\";;\n                               ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n", "out": "Characters 29-38:\n  let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\";;\n                               ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \";\" (List.map f l)) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper x n-1 x::acc in\ncloneHelper x n []", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else ((cloneHelper x n) - (1 x)) :: acc in\n  cloneHelper x n [];;\n", "out": "Characters 74-89:\n  let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper x n-1 x::acc in\n                                                       ^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper x n []", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper x n [];;\n", "out": "Characters 87-88:\n  let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\n                                                                    ^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper x n []", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper x n [];;\n", "out": "Characters 87-88:\n  let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\n                                                                    ^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper (x ,n,[])", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "out": "Characters 87-88:\n  let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\n                                                                    ^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper (x,n,[])", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "out": "Characters 87-88:\n  let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\n                                                                    ^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = if n < 0 then [] else clone x n-1", "min": "\nlet rec clone x n = if n < 0 then [] else (clone x n) - 1;;\n", "out": "Characters 42-51:\n  let rec clone x n = if n < 0 then [] else clone x n-1;;\n                                            ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = if n < 0 then [] else clone (x,n-1)", "min": "\nlet rec clone x n = if n < 0 then [] else clone (x, (n - 1));;\n", "out": "Characters 49-50:\n  let rec clone x n = if n < 0 then [] else clone (x,n-1);;\n                                                   ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec clone x n = \nlet cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "min": "\nlet rec clone x n =\n  let cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "out": "Characters 74-85:\n  let cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\n                                                       ^^^^^^^^^^^\nError: Unbound value cloneHelper\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "min": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "min": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if (n < 0) then acc else cloneHelper x n-1 x::acc in\ncloneHelper x n []", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else ((cloneHelper x n) - (1 x)) :: acc in\n  cloneHelper x n [];;\n", "out": "Characters 76-91:\n  let rec cloneHelper x n acc = if (n < 0) then acc else cloneHelper x n-1 x::acc in\n                                                         ^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type int\n"}, {"type": "", "in": "let padZero l1 l2 = failwith \"to be implemented\"", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper (x,n-1, x::acc) in\ncloneHelper (x,n,[])", "min": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone (x,n) = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper (x,n-1, x::acc) in\ncloneHelper (x,n,[])", "min": "\nlet rec clone (x,n) =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper (x,n-1, x::acc) in\ncloneHelper (x,n,[])", "min": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if (n < 0) then acc else cloneHelper x (n-1) (x::acc) in\ncloneHelper x n []", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "out": "Characters 146-175:\n  else if (diff > 0) then List.append (clone 0 diff) l2;;\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append ((clone 0 (abs diff)) l1)\nelse if (diff > 0) then List.append ((clone 0 diff) l2)", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append ((clone 0 (abs diff)) l1)\n  else if diff > 0 then List.append ((clone 0 diff) l2);;\n", "out": "Characters 99-119:\n  if (diff < 0) then List.append ((clone 0 (abs diff)) l1)\n                                  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append ((clone 0 (abs diff)),l1)\nelse if (diff > 0) then List.append ((clone 0 diff),l2)", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append ((clone 0 (abs diff)), l1)\n  else if diff > 0 then List.append ((clone 0 diff), l2);;\n", "out": "Characters 98-123:\n  if (diff < 0) then List.append ((clone 0 (abs diff)),l1)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.append ((clone 0 (abs diff)),l1),l2)\nelse if (diff > 0) then (l1,List.append ((clone 0 diff),l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append ((clone 0 (abs diff)), l1)), l2)\n  else if diff > 0 then (l1, (List.append ((clone 0 diff), l2)));;\n", "out": "Characters 99-124:\n  if (diff < 0) then (List.append ((clone 0 (abs diff)),l1),l2)\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.combine ((clone 0 (abs diff)),l1),l2)\nelse if (diff > 0) then (l1,List.combine ((clone 0 diff),l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.combine ((clone 0 (abs diff)), l1)), l2)\n  else if diff > 0 then (l1, (List.combine ((clone 0 diff), l2)));;\n", "out": "Characters 100-125:\n  if (diff < 0) then (List.combine ((clone 0 (abs diff)),l1),l2)\n                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "out": "Characters 146-175:\n  else if (diff > 0) then List.append (clone 0 diff) l2;;\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "out": "Characters 146-175:\n  else if (diff > 0) then List.append (clone 0 diff) l2;;\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1;;\n", "out": "Characters 86-121:\n  if (diff < 0) then List.append (clone 0 (abs diff)) l1;;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1 else l2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else if (diff > 0) then l1 else l1", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then l1 else l1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.append (clone 0 (abs diff)) l1,l2) else if (diff > 0) then (l1,List.append (clone 0 diff) l2) else (l1,l2)", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h::t -> if (h = 0) then removeZero t else l", "min": "\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + (fst x + snd x) mod 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (((fst x) + (snd x)) mod 10) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 146-172:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), (sum mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 237-258:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres::[] \nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), (sum mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in [res] in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1', l2') = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1' l2' in\nlet (_, res) = List.fold_left f base args in\nres::[] \nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1',l2') =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), (sum mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in [res] in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if (n <= 0) then acc else cloneHelper x (n-1) (x::acc) in\ncloneHelper x n []", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1', l2') = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1' l2' in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1',l2') =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1', l2') = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, sum mod 10::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1' l2' in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1',l2') =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1', l2') = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1' l2' in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1',l2') =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1', l2') = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/9, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1' l2' in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1',l2') =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 9), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1', l2') = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1' l2' in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1',l2') =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h::t -> if (h = 0) then removeZero t else l", "min": "\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 207-208:\n  let (_, res) = List.fold_right f base args in\n                                 ^\nError: This expression has type int * int list -> int * int -> int * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine List.reverse l1 List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine List.reverse l1 List.reverse l2 in\n    let (_,res) = List.fold_left f base args in List.reverse res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "out": "Characters 154-166:\n  let args = List.combine List.reverse l1 List.reverse l2 in\n             ^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.reverse l1) (List.reverse l2) in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.reverse l1) (List.reverse l2) in\n    let (_,res) = List.fold_left f base args in List.reverse res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "out": "Characters 168-180:\n  let args = List.combine (List.reverse l1) (List.reverse l2) in\n                           ^^^^^^^^^^^^\nError: Unbound value List.reverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.reverse res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "out": "Characters 243-255:\n  List.reverse res\n  ^^^^^^^^^^^^\nError: Unbound value List.reverse\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.rev res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "out": "Characters 276-297:\n  removeZero (add (padZero 0::l1 0::l2));;\n                  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero (0::l1) (0::l2)))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0::l1) (0::l2)))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0:l1) (0:l2)))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 : l1) (0 : l2)));;\n", "out": "Characters 279-281:\n  removeZero (add (padZero (0:l1) (0:l2)));;\n                              ^^\nError: Unbound type constructor l1\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0::l1) (0::l2)))", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet rec mulHelper c m l r = match l with \n| [] -> \nr\n| h::t ->\nmulHelper ((m*h + c)/10) m t (((m*h + c) mod 10)::r)\nin\nmulHelper 0 i (List.rev (0::l)) []", "min": "\nlet rec mulByDigit i l =\n  let rec mulHelper c m l r =\n    match l with\n    | [] -> r\n    | h::t ->\n        mulHelper (((m * h) + c) / 10) m t ((((m * h) + c) mod 10) :: r) in\n  mulHelper 0 i (List.rev (0 :: l)) [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd snd a (List.append l1 (clone 0 (fst a))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 44-50:\n  let f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\n                          ^^^^^^\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd (snd a) (List.append l1 (clone 0 (fst a))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nList.rev res", "min": "\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd (snd a) (List.append l1 (clone 0 (fst a))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in\n  let (_,res) = List.fold_left f base args in List.rev res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a) + 1, bigAdd (snd a) (List.append (mulByDigit x l1) (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet rec mulByDigit i l =\n  let rec mulHelper c m l r =\n    match l with\n    | [] -> r\n    | h::t ->\n        mulHelper (((m * h) + c) / 10) m t ((((m * h) + c) mod 10) :: r) in\n  mulHelper 0 i (List.rev (0 :: l)) [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1),\n      (bigAdd (snd a) (List.append (mulByDigit x l1) (clone 0 (fst a))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nlet rec cloneHelper x n acc = if (n <= 0) then acc else cloneHelper x (n-1) (x::acc) in\ncloneHelper x n []", "min": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
