{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) @ (helper (n / 10)) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) @ (helper (n / 10)) in\n  helper n;;\n", "out": "Characters 77-87:\n  | n ->  (n mod 10) @ (helper (n / 10)) in\n          ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\n(helper n).reverse", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  (helper n).reverse;;\n", "out": "Characters 123-130:\n  (helper n).reverse;;\n             ^^^^^^^\nError: Unbound record field reverse\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> xs\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> xs | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "out": "Characters 172-184:\n  | hd :: tl -> (reverse tl) :: hd in\n                ^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> []\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> [] | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "out": "Characters 172-184:\n  | hd :: tl -> (reverse tl) :: hd in\n                ^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append (helper (n / 10)) (n mod 10) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) (n mod 10) in\n  helper n;;\n", "out": "Characters 197-207:\n  | n ->  append (helper (n / 10)) (n mod 10) in\n                                   ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "out": "Characters 198-208:\n  | n ->  append [helper (n / 10)] [(n mod 10)] in\n                                    ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [n mod 10] in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "out": "Characters 198-206:\n  | n ->  append [helper (n / 10)] [n mod 10] in\n                                    ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "out": "Characters 198-208:\n  | n ->  append [helper (n / 10)] [(n mod 10)] in\n                                    ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append [helper (n / 10)] [(n mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "out": "Characters 199-209:\n  | n ->  (append [helper (n / 10)] [(n mod 10)]) in\n                                     ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (helper (n / 10)) @ [n mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append helper (n / 10) [(n mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append helper (n / 10) [n mod 10] in\n  helper n;;\n", "out": "Characters 173-179:\n  | n ->  (append helper (n / 10) [(n mod 10)]) in\n           ^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) [n mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (helper (n / 10)) @ [n mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) [n mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) [n mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) [n mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (helper (n / 10)) @ [n mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) [n mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  helper (append [(m / 10)] [(m mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> helper (append [m / 10] [m mod 10]) in\n  helper n;;\n", "out": "Characters 179-211:\n  | m ->  helper (append [(m / 10)] [(m mod 10)]) in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs2 with \n| [] -> xs1\n| hd :: tl -> (append (xs1 :: hd) tl) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs2 with | [] -> xs1 | hd::tl -> append (xs1 :: hd) tl in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": "Characters 102-105:\n  | hd :: tl -> (append (xs1 :: hd) tl) in\n                         ^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: append tl xs2 in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x <  10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x <  10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 107-114:\n  else  helper (count + 1) (sumList (digits n))\n                            ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 107-114:\n  else  helper (count + 1) (sumList (digits n))\n                            ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 107-114:\n  else  helper (count + 1) (sumList (digits n))\n                            ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 107-114:\n  else  helper (count + 1) (sumList (digits n))\n                            ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digits n = digitsOfInt (abs n)\ndigits (-23422) is [2,3,4,2,2]", "min": "\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n) digits (-23422) is [(2, 3, 4, 2, 2)];;\n", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 15-26:\n  let digits n = digitsOfInt (abs n)\n                 ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin (helper 0 n)", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 108-115:\n  else  (helper (count + 1) (sumList (digits n)))\n                             ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 108-115:\n  if (x < 10) then count else  (helper (count + 1) (sumList (digits n)))\n                                                    ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 1) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if count = 1 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 111-118:\n  if (count = 1) then count else  (helper (count + 1) (sumList (digits n)))\n                                                       ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 1) then x else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if count = 1 then x else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 107-114:\n  if (count = 1) then x else  (helper (count + 1) (sumList (digits n)))\n                                                   ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 2) then x else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if count = 2 then x else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "out": "Characters 107-114:\n  if (count = 2) then x else  (helper (count + 1) (sumList (digits n)))\n                                                   ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 2) then x else  (helper (count + 1) (sumList (digits x)))\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if count = 2 then x else helper (count + 1) (sumList (digits x)) in\n  helper 0 n;;\n", "out": "Characters 107-114:\n  if (count = 2) then x else  (helper (count + 1) (sumList (digits x)))\n                                                   ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then x else  (helper (count + 1) (sumList (digits x)))\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then x else helper (count + 1) (sumList (digits x)) in\n  helper 0 n;;\n", "out": "Characters 104-111:\n  if (x < 10) then x else  (helper (count + 1) (sumList (digits x)))\n                                                ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumlist (digits x)) in\nif (next < 10) then x else  (helper (count + 1) next)\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumlist (digits x) in\n    if next < 10 then x else helper (count + 1) next in\n  helper 0 n;;\n", "out": "Characters 70-77:\n  let next = (sumlist (digits x)) in\n              ^^^^^^^\nError: Unbound value sumlist\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then x else  (helper (count + 1) next)\nin (helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumList (digits x) in\n    if next < 10 then x else helper (count + 1) next in\n  helper 0 n;;\n", "out": "Characters 70-77:\n  let next = (sumList (digits x)) in\n              ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumList (digits x) in\n    if next < 10 then count else helper (count + 1) next in\n  helper 0 n;;\n", "out": "Characters 70-77:\n  let next = (sumList (digits x)) in\n              ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumList (digits x) in\n    if next < 10 then count else helper (count + 1) next in\n  helper 0 n;;\n", "out": "Characters 70-77:\n  let next = (sumList (digits x)) in\n              ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (x < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumList (digits x) in\n    if x < 10 then count else helper (count + 1) next in\n  helper 0 n;;\n", "out": "Characters 70-77:\n  let next = (sumList (digits x)) in\n              ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper sumList digits x in\nhelper n", "min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper sumList digits x in\n  helper n;;\n", "out": "Characters 68-74:\n  if (x < 10) then x else helper sumList digits x in\n                          ^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList digits x) in\nhelper n", "min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList digits x) in\n  helper n;;\n", "out": "Characters 76-83:\n  if (x < 10) then x else helper (sumList digits x) in\n                                  ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n", "min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList (digits x)) in\n  helper n;;\n", "out": "Characters 76-83:\n  if (x < 10) then x else helper (sumList (digits x)) in\n                                  ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n", "min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList (digits x)) in\n  helper n;;\n", "out": "Characters 76-83:\n  if (x < 10) then x else helper (sumList (digits x)) in\n                                  ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n", "min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList (digits x)) in\n  helper n;;\n", "out": "Characters 76-83:\n  if (x < 10) then x else helper (sumList (digits x)) in\n                                  ^^^^^^^\nError: Unbound value sumList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": "Characters 78-84:\n  | m ->  (append (helper (m / 10)) [(m mod 10)]) in\n           ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []", "min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper xs [];;\n", "out": "Characters 132-134:\n  helper xs [];;\n         ^^\nError: Unbound value xs\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []", "min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper xs [];;\n", "out": "Characters 132-134:\n  helper xs [];;\n         ^^\nError: Unbound value xs\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper l []", "min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = ((explode w) = listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper l [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append l1 l2 =\n  let rec helper xs1 xs2 result =\n    match xs1 with | [] -> result | hd::tl -> helper tl [] (hd :: result) in\n  helper l1 [] l2;;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList l = \nlet rec iter xs result = \nmatch xs with \n| [] -> result\n| hd :: tl -> iter tl (hd + result) in\niter l 0", "min": "\nlet rec sumList l =\n  let rec iter xs result =\n    match xs with | [] -> result | hd::tl -> iter tl (hd + result) in\n  iter l 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec append l1 l2 = \nlet rec helper xs1 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> helper tl (hd :: result) in\nhelper (listReverse l1) l2", "min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper l [];;\n\nlet rec append l1 l2 =\n  let rec helper xs1 result =\n    match xs1 with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper (listReverse l1) l2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper l [];;\n\nlet rec append l1 l2 =\n  let rec helper xs1 result =\n    match xs1 with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper (listReverse l1) l2;;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "out": ""}]}
