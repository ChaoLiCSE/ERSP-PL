{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-87:\n  | n ->  (n mod 10) @ (helper (n / 10)) in\n          ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) @ (helper (n / 10)) in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) @ (helper (n / 10)) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 123-130:\n  (helper n).reverse;;\n             ^^^^^^^\nError: Unbound record field reverse\n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  (helper n).reverse;;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\n(helper n).reverse"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 172-184:\n  | hd :: tl -> (reverse tl) :: hd in\n                ^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> xs | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> xs\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 172-184:\n  | hd :: tl -> (reverse tl) :: hd in\n                ^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> [] | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> []\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 197-207:\n  | n ->  append (helper (n / 10)) (n mod 10) in\n                                   ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) (n mod 10) in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append (helper (n / 10)) (n mod 10) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 198-208:\n  | n ->  append [helper (n / 10)] [(n mod 10)] in\n                                    ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 198-206:\n  | n ->  append [helper (n / 10)] [n mod 10] in\n                                    ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [n mod 10] in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 198-208:\n  | n ->  append [helper (n / 10)] [(n mod 10)] in\n                                    ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 199-209:\n  | n ->  (append [helper (n / 10)] [(n mod 10)]) in\n                                     ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append [helper (n / 10)] [(n mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 173-179:\n  | n ->  (append helper (n / 10) [(n mod 10)]) in\n           ^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append helper (n / 10) [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append helper (n / 10) [(n mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 179-211:\n  | m ->  helper (append [(m / 10)] [(m mod 10)]) in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> helper (append [m / 10] [m mod 10]) in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  helper (append [(m / 10)] [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 102-105:\n  | hd :: tl -> (append (xs1 :: hd) tl) in\n                         ^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs2 with | [] -> xs1 | hd::tl -> append (xs1 :: hd) tl in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs2 with \n| [] -> xs1\n| hd :: tl -> (append (xs1 :: hd) tl) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: append tl xs2 in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x <  10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x <  10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 107-114:\n  else  helper (count + 1) (sumList (digits n))\n                            ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 107-114:\n  else  helper (count + 1) (sumList (digits n))\n                            ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 107-114:\n  else  helper (count + 1) (sumList (digits n))\n                            ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)\ndigits (-23422) is [2,3,4,2,2]"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 15-26:\n  let digits n = digitsOfInt (abs n)\n                 ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n) digits (-23422) is [(2, 3, 4, 2, 2)];;\n", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-6:\n  digits -23422 = [2,3,4,2,2];;\n  ^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet _ = (digits - 23422) = [(2, 3, 4, 2, 2)];;\n", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-6:\n  import math;;\n  ^^^^^^\nError: Unbound value import\n", "min": "\nlet _ = import math;;\n", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 1) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 1) then x else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 2) then x else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 2) then x else  (helper (count + 1) (sumList (digits x)))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 107-114:\n  if (count = 2) then x else  (helper (count + 1) (sumList (digits x)))\n                                                   ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if count = 2 then x else helper (count + 1) (sumList (digits x)) in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then x else  (helper (count + 1) (sumList (digits x)))\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumlist (digits x)) in\nif (next < 10) then x else  (helper (count + 1) next)\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 70-77:\n  let next = (sumlist (digits x)) in\n              ^^^^^^^\nError: Unbound value sumlist\n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumlist (digits x) in\n    if next < 10 then x else helper (count + 1) next in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then x else  (helper (count + 1) next)\nin (helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 70-77:\n  let next = (sumList (digits x)) in\n              ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumList (digits x) in\n    if next < 10 then count else helper (count + 1) next in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (x < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper sumList digits x in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-74:\n  if (x < 10) then x else helper sumList digits x in\n                          ^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper sumList digits x in\n  helper n;;\n", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList digits x) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 76-83:\n  if (x < 10) then x else helper (sumList digits x) in\n                                  ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList digits x) in\n  helper n;;\n", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 76-83:\n  if (x < 10) then x else helper (sumList (digits x)) in\n                                  ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList (digits x)) in\n  helper n;;\n", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = digitalRoot 9876;;\n          ^^^^^^^^^^^\nError: Unbound value digitalRoot\n", "min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-98:\n  | hd :: tl ->  tl  (hd :: result)\n                 ^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> tl (hd :: result) in\n  helper xs [];;\n", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 132-134:\n  helper xs [];;\n         ^^\nError: Unbound value xs\n", "min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper xs [];;\n", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 132-134:\n  helper xs [];;\n         ^^\nError: Unbound value xs\n", "min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper xs [];;\n", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = ((explode w) = listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList l = \nlet rec iter xs result = \nmatch xs with \n| [] -> result\n| hd :: tl -> iter tl (hd + result) in\niter l 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec append l1 l2 = \nlet rec helper xs1 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> helper tl (hd :: result) in\nhelper (listReverse l1) l2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}]}
