{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = a+x in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =  a + x  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 81-85:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  fun a -> x  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =  fun x -> a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 84-85:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =  f (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = f (fun a  -> x) a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 28-29:\n  let f a x =  f (fun a->x) a  in\n               ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun a  -> x) a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =  a (fun a->x) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a (fun a  -> x) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 85-86:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type (('a -> 'b) -> 'c) -> 'b -> 'c\n       but an expression was expected of type\n         (('a -> 'b) -> 'c) -> 'b -> ('a -> 'b) -> 'c\n       The type variable 'c occurs inside ('a -> 'b) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun a->x) x in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun a  -> x) x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun x->x) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun x  -> x) a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun a->x) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun a  -> x) a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun a->a) x in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun a  -> a) x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun a->x) x in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun a  -> x) x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun x  -> a) a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun x  -> a) a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 57-58:\n  let base =  x in\n              ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun x  -> a) a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 57-58:\n  let base =  a in\n              ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  0 in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun x  -> a) a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun x  -> a) a in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun a->x) a in\nlet base =  fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun a  -> x) a in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun a->x) x in\nlet base =  fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun a  -> x) x in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun x->a) x in\nlet base =  fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun x  -> a) x in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   (fun a->x) x in\nlet base =  fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (fun a  -> x) x in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   fun b -> (x b) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x b = (x b) a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =   fun b -> (b x) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x b = (b x) a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 90-91:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   fun b -> (x b) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x b = (x b) a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =   fun b -> x (a b) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ a in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = a in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = a in let l = t in List.fold_left f base l;;\n", "out": "Characters 98-99:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h^sep in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep in\nlet base = h^x in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h ^ x in let l = t in List.fold_left f base l;;\n", "out": "Characters 100-101:\n  let base = h^x in\n               ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^sep) x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ sep) x in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": "Characters 78-85:\n  let f a x = (a^sep) x in\n              ^^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x (a^sep)  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x (a ^ sep) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": "Characters 143-144:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string list\n       but an expression was expected of type (string -> string) list\n       Type string is not compatible with type string -> string \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep  in\nlet base = h in\nlet l = x in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = x in List.fold_left f base l;;\n", "out": "Characters 112-113:\n  let l = x in\n          ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep  in\nlet base = a in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ sep in\n      let base = a in let l = t in List.fold_left f base l;;\n", "out": "Characters 99-100:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = f (pipe List.map l)", "min": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n\nlet stringOfList f l = f (pipe List.map l);;\n", "out": "Characters 31-39:\n  let stringOfList f l = f (pipe List.map l);;\n                                 ^^^^^^^^\nError: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type ('c -> 'c) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l =  List.map f l", "min": "\nlet stringOfList f l = List.map f l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l =  sepConcat f (List.map f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat f (List.map f l);;\n", "out": "Characters 46-47:\n  let stringOfList f l =  sepConcat f (List.map f l);;\n                                                ^\nError: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l =  sepConcat \"\" (List.map f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l =  List.map f l", "min": "\nlet stringOfList f l = List.map f l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l =  sepConcat \" \" (List.map f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l =  sepConcat l (List.map f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat l (List.map f l);;\n", "out": "Characters 48-49:\n  let stringOfList f l =  sepConcat l (List.map f l);;\n                                                  ^\nError: This expression has type string but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l =  sepConcat (List.map f l) l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l) l;;\n", "out": "Characters 34-48:\n  let stringOfList f l =  sepConcat (List.map f l) l;;\n                                    ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l =  sepConcat \"[]\" (List.map f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[]\" (List.map f l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = List.map f (sepConcat \"\" l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "out": "Characters 34-50:\n  let stringOfList f l = List.map f (sepConcat \"\" l);;\n                                    ^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = (List.map f (sepConcat \"\" l))", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "out": "Characters 35-51:\n  let stringOfList f l = (List.map f (sepConcat \"\" l));;\n                                     ^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l =  sepConcat \"\" (List.map f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec clone x n = match n with\n0    -> []\n| h::t ->  x::clone x (n-1)", "min": "\nlet rec clone x n = match n with | 0 -> [] | h::t -> x :: (clone x (n - 1));;\n", "out": "Characters 46-50:\n  | h::t ->  x::clone x (n-1);;\n    ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = match n with\n0    -> []\n| _ ->  x::clone x (n-1)", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = if n <= 0 then [] else x::clone x (n-1)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then (clone 0 l1, l2) \nelse if (s2<s1) then (l1, clone 0 l2)\nelse (l1,l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then ((clone 0 l1), l2)\n  else if s2 < s1 then (l1, (clone 0 l2)) else (l1, l2);;\n", "out": "Characters 99-101:\n  if (s1<s2) then (clone 0 l1, l2) \n                           ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\nelse (l1,l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, (((clone 0 s1) - s2) @ l2)) else (l1, l2);;\n", "out": "Characters 147-157:\n  else if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\n                             ^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n[]  -> []\n| h::t-> if(h=0) then removeZero t else h::removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec removeZero l = match l with\nh   -> if (h != 0) then []\n| h::t-> if(h=0) then removeZero t else h::removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | h -> if h != 0 then []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n", "out": "Characters 52-53:\n  h   -> if (h != 0) then []\n                  ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec removeZero l = match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h::removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h1::h2::t ->\n      if (h1 = 0) && (h2 != 0) then removeZero t else h :: (removeZero t);;\n", "out": "Characters 101-102:\n  | h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h::removeZero t;;\n                                                         ^\nError: Unbound value h\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h1::removeZero t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h1::h2::t ->\n      if (h1 = 0) && (h2 != 0) then removeZero t else h1 :: (removeZero t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\nh::t-> if(h=0) then removeZero t else h::removeZero t", "min": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n[]  -> []\n| h::t-> if(h!=0) then t else removeZero t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then t else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n[]  -> []\n| h::t-> if(h!=0) then t else h::removeZero t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then t else h :: (removeZero t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n[]  -> []\n| h::t-> if(h!=0) then h::t else removeZero t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n[]  -> []\n| h::t-> if(h!=0) then h::t else removeZero t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 159-185:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x/10, x%10)::a in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x % 10)) :: a in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 60-61:\n  let f a x = (x/10, x%10)::a in\n                      ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x/10, x mod 10)::a in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x mod 10)) :: a in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 150-176:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x/10, x mod 10)::a in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x mod 10)) :: a in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 124-150:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x mod 10::a in\nlet base = [] in\nlet args = a+x in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = a + x in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 95-96:\n  let args = a+x in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x mod 10::a in\nlet base = [] in\nlet args = a+x in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = a + x in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 95-96:\n  let args = a+x in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x mod 10::a in\nlet base = [] in\nlet args = x in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = x in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 95-96:\n  let args = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x mod 10::a in\nlet base = [] in\nlet args = 1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 137-141:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x mod 10::a in\nlet base = [] in\nlet args = a in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = a in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 95-96:\n  let args = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x mod 10::a in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 116-142:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x mod 10::a in\nlet base = (match l1 with h->h) + (match l2 with h->h) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = (match l1 with | h -> h) + (match l2 with | h -> h) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 174-178:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = ([],[]) in\nlet args =  List.combine(List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 155-181:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\n| h::t -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] | h::t -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 202-206:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\n| h::t -> []\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] | h::t -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 202-206:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> ([],[])\n| h::t -> ([],[])\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> ([], []) | h::t -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 217-221:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n([],[])   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 194-198:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 189-193:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 189-193:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 189-193:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 156-182:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 195-199:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 193-194:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list * 'b list -> 'c -> 'd list\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type 'd list is not compatible with type 'a list * 'b list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n[] -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 189-193:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[] -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 189-193:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[] -> ([], [])\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 200-204:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n[] -> ([], [])\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 193-194:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list -> 'b -> 'c list * 'd list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c list * 'd list is not compatible with type 'a list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 156-182:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  fun x -> x in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base x = x in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 164-190:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(c, h::t) -> []\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,h::t) -> [] in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 193-194:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a * 'b list -> 'c -> 'd list\n       but an expression was expected of type\n         'a * 'b list -> 'c -> 'a * 'b list\n       Type 'd list is not compatible with type 'a * 'b list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (snd a) with\n[]  -> (fst x + snd x, ((fst x + snd x)/10)::[(fst x + snd x) mod 10]) \n|h::t -> (0, [] )\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(_,[])   -> ((fst x + snd x)/10, [(fst x + snd x) mod 10]) \n| (c,h::t) -> \nlet sum = c + fst x + snd x in\n(sum/10, (sum mod 10)::(snd a))\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(_,[])   -> ((fst x + snd x)/10, [(fst x + snd x) mod 10]) \n| (c,h::t) -> \nlet sum = c + fst x + snd x in\n(sum/10, (sum mod 10)::(snd a))\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec mulByDigit i l = \nlet lr = List.rev l in\nmatch lr with\n(_,[])   -> ((fst x * snd x)/10, [(fst x * snd x) mod 10]) \n| (c,h::t) -> \nlet sum = c + (fst x * snd x) in\n(sum/10, (sum mod 10)::(snd a))", "min": "\nlet rec mulByDigit i l =\n  let lr = List.rev l in\n  match lr with\n  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])\n  | (c,h::t) ->\n      let sum = c + ((fst x) * (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a)));;\n", "out": "Characters 63-69:\n  (_,[])   -> ((fst x * snd x)/10, [(fst x * snd x) mod 10]) \n  ^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulBydigit i l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulBydigit i l);;\n", "out": "Characters 109-119:\n  | _ -> bigAdd (mulByDigit (i-2) l) (mulBydigit i l);;\n                                      ^^^^^^^^^^\nError: Unbound value mulBydigit\nHint: Did you mean mulByDigit?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit i l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit i l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit 2 l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit 2 l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) (mulByDigit 1 l)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (mulByDigit (i - 1) l) (mulByDigit 1 l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n0 -> [0]\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nlet rec accumulator n li acc = \nmatch n with\n0 -> [0]\n| 1 -> bigAdd li acc\n| _ -> accumulator (n-1) li (bigAdd li acc)\nin\naccumulator i l [0]", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n li acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd li acc\n    | _ -> accumulator (n - 1) li (bigAdd li acc) in\n  accumulator i l [0];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x =  failwith \"\" in\nlet base = (0, []) in\nlet args = List.combine (List.rev l1) (List.rev l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"\" in\n  let base = (0, []) in\n  let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x =  match a with\n(_,[])   -> mulByDigit (fst x) l1\n|(c, h::t) -> (c, mulByDigit h x)\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (_,[]) -> mulByDigit (fst x) l1\n    | (c,h::t) -> (c, (mulByDigit h x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 94-113:\n  |(c, h::t) -> (c, mulByDigit h x)\n                ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x =  match a with\n(_,[])   -> mulByDigit (fst x) l1\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,[]) -> mulByDigit (fst x) l1 in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 161-162:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a * 'b list -> int * 'c -> int list\n       but an expression was expected of type\n         'a * 'b list -> int * 'c -> 'a * 'b list\n       Type int list is not compatible with type 'a * 'b list \n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigMul l1 l2 = \nlet f a x = (fst a, bigAdd () ()) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x = ((fst a), (bigAdd () ())) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 47-49:\n  let f a x = (fst a, bigAdd () ()) \n                             ^^\nError: This variant expression is expected to have type int list\n       The constructor () does not belong to type list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd x (mulByDigit (fst a) x))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd snd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd snd x (mulByDigit (fst a) x))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 44-50:\n  let f a x = ((fst a)+1, bigAdd snd x (mulByDigit (fst a) x )) \n                          ^^^^^^\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd x (mulByDigit (fst a) x))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (snd x) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd x (mulByDigit (fst a) (snd x)))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 78-79:\n  let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (snd x) )) \n                                                            ^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (x@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd x (mulByDigit (fst a) (x @ (clone 0 (fst a)))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd x (mulByDigit (fst a) (l1 @ (clone 0 (fst a)))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd x (mulByDigit x (l1 @ (clone 0 (fst a)))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 65-66:\n  let f a x = ((fst a)+1, bigAdd x (mulByDigit x (l1@ clone 0 (fst a)) )) \n                                               ^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \n((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd (snd a) (mulByDigit x (l1 @ (clone 0 (fst a)))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \n(1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (1, (bigAdd (snd a) (mulByDigit x (l1 @ (clone 0 (fst a)))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (0,[]) -> (0, (mulByDigit x (l1 @ (clone 0 []))))\n    | (c,a) -> ((c + 1), (bigAdd a (mulByDigit x (l1 @ (clone 0 c))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 88-90:\n  (0, [])   -> (0, mulByDigit x (l1@ clone 0 []))\n                                             ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 0))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (0,[]) -> (0, (mulByDigit x (l1 @ (clone 0 0))))\n    | (c,a) -> ((c + 1), (bigAdd a (mulByDigit x (l1 @ (clone 0 c))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd (snd a) (mulByDigit x (l1 @ (clone 0 (fst a)))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
