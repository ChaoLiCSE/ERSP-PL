{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-72:\n  else n % 10 :: digitsOfInt (n\\10);;\n                               ^\nError: Illegal character (\\\\)\n", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n\\10)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-50:\n  else n % 10 :: digitsOfInt (n/10);;\n         ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n % 10) :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-66:\n  else digitsOfInt (n/10) :: n mod 10;;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-66:\n  else digitsOfInt (n/10) :: n mod 10;;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n/10 :: digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-66:\n  else digitsOfInt (n/10) :: n mod 10;;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n >= 0 then digitsOfInt (n/10) @ [n mod 10]\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-62:\n  else digitsOfInt n/10 @ [n mod 10];;\n       ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then [] (* BUG *)\nelse digitsOfInt n/10 @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [] (* BUG *)\nelse digitsOfInt (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [0] (* BUG *)\nelse digitsOfInt (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [] (* BUG *)\nelse digitsOfInt (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfIntHelper n = \nif n <= 0 then [] \nelse digitsOfInt (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfIntHelper n = \nif n <= 0 then [] \nelse digitsOfIntHelper (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [] \nelse digitsOfIntHelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n == 0 then [0]\nelse if n <= 0 then [] \nelse digitsOfIntHelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n == 0 then [0]\nelse if n < 0 then [] \nelse digitsOfIntHelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfIntHelper n = \ndigitsOfIntHelper (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfIntHelper n = \nif n > 0 then digitsOfIntHelper (n/10) @ [n mod 10] \nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n == 0 then [0]\nelse digitsOfIntHelper n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-77:\n  else 1 + additivePersistence sumList (digits n);;\n           ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence sumList (digits n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-86:\n  else 1 + additivePersistence (sumList digits n);;\n                                ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence (sumList digits n));;\n", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList digits n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n < 10 then 0\nelse 1 + additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-52:\n  if n > 0 then digitsOfInt n mod 10 ::(n/10) \n                ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) mod 10) :: (n / 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt n mod 10 ::(n/10) \nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-61:\n  if n > 0 then digitsOfInt (n mod 10) :: n/10\n                ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n mod 10)) :: (n / 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt (n mod 10) :: n/10\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 51-71:\n  if n > 0 then digitsOfInt ((n mod 10) :: n/10)\n                            ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then digitsOfInt ((n mod 10) :: (n / 10)) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt ((n mod 10) :: n/10)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 53-66:\n  if n > 0 then (n mod 10) :: digitsOfInt n/10\n                              ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: ((digitsOfInt n) / 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: digitsOfInt n/10\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: digitsOfInt (n/10)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-71:\n  k :: (n mod 10)\n  ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then let k = digitsOfInt (n / 10) in k :: (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\nk :: (n mod 10)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\n(n mod 10) :: k\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt (n/10) @ [n mod 10]\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt (n/10) @ [n mod 10]\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nreverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfIntHelper n result =\nif n > 0 then \n(n mod 10) :: digitsOfIntHelper (n/10) result\nelse \nresult"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt (n/10) @ [n mod 10]\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfIntHelper n result =\nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result\nelse result"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 153-169:\n  | y :: t -> if x == y then palindromeHelper s t\n                             ^^^^^^^^^^^^^^^^\nError: Unbound value palindromeHelper\n", "min": "\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x == y then palindromeHelper s t\n       | _ -> false);;\n", "in": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 153-169:\n  | y :: t -> if x == y then palindromeHelper s t\n                             ^^^^^^^^^^^^^^^^\nError: Unbound value palindromeHelper\n", "min": "\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x == y then palindromeHelper s t\n       | _ -> false)\n  | _ -> false;;\n", "in": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)\n| _ -> false"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 152-168:\n  | y :: t -> if x = y then palindromeHelper s t\n                            ^^^^^^^^^^^^^^^^\nError: Unbound value palindromeHelper\n", "min": "\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "in": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 157-177:\n  | y :: t -> if x = y then  palindromeHelper s t\n                             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 157-177:\n  | y :: t -> if x = y then  palindromeHelper s t\n                             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-176:\n  | y :: t -> if x = y then palindromeHelper s t\n                            ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-176:\n  | y :: t -> if x = y then palindromeHelper s t\n                            ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false)\n  | _ -> false;;\n", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)\n| _ -> false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 158-178:\n  | y :: t -> if (x = y) then palindromeHelper s t\n                              ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false)\n  | _ -> false;;\n", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t\n| _ -> false)\n| _ -> false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet wl = explode w in\nlet rl = listReverse wl in\npalindromeHelper wl rl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet wl = explode w in\nlet rl = listReverse wl in\nrl = wl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet wl = explode w in\nlet rl = listReverse wl in\nrl = wl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \ndigitsOfIntHelper n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \ndigitsOfIntHelper n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \ndigitsOfIntHelper n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) ((n mod 10) :: result)\nelse result in \ndigitsOfIntHelper n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-112:\n  if n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then (digitsOfIntHelper (n / 10) (n mod 10)) :: result\n    else result in\n  digitsOfIntHelper n [];;\n", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result\nelse result in \ndigitsOfIntHelper n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10 :: result)\nelse result in \ndigitsOfIntHelper n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec calculate n result = \nif n > 0 then calculate (n/10) (n mod 10 :: result)\nelse result in \ncalculate n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet rec calculate n result = \nif n > 0 then calculate (n/10) (n mod 10 :: result)\nelse result in \ncalculate n []"}]}
