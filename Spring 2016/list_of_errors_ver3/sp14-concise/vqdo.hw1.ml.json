{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n\\10)", "min": "", "out": "Characters 71-72:\n  else n % 10 :: digitsOfInt (n\\10);;\n                               ^\nError: Illegal character (\\\\)\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n % 10) :: (digitsOfInt (n / 10));;\n", "out": "Characters 49-50:\n  else n % 10 :: digitsOfInt (n/10);;\n         ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 48-66:\n  else digitsOfInt (n/10) :: n mod 10;;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 48-66:\n  else digitsOfInt (n/10) :: n mod 10;;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n/10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n / 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 48-66:\n  else digitsOfInt (n/10) :: n mod 10;;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n >= 0 then digitsOfInt (n/10) @ [n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n >= 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then [] (* BUG *)\nelse digitsOfInt n/10 @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n", "out": "Characters 49-62:\n  else digitsOfInt n/10 @ [n mod 10];;\n       ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [] (* BUG *)\nelse digitsOfInt (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [0] (* BUG *)\nelse digitsOfInt (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [0] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [] (* BUG *)\nelse digitsOfInt (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfIntHelper n = \nif n <= 0 then [] \nelse digitsOfInt (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfIntHelper n = \nif n <= 0 then [] \nelse digitsOfIntHelper (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (digitsOfIntHelper (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [] \nelse digitsOfIntHelper n", "min": "\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (digitsOfIntHelper (n / 10)) @ [n mod 10];;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digitsOfIntHelper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n == 0 then [0]\nelse if n <= 0 then [] \nelse digitsOfIntHelper n", "min": "\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (digitsOfIntHelper (n / 10)) @ [n mod 10];;\n\nlet rec digitsOfInt n =\n  if n == 0 then [0] else if n <= 0 then [] else digitsOfIntHelper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n == 0 then [0]\nelse if n < 0 then [] \nelse digitsOfIntHelper n", "min": "\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (digitsOfIntHelper (n / 10)) @ [n mod 10];;\n\nlet rec digitsOfInt n =\n  if n == 0 then [0] else if n < 0 then [] else digitsOfIntHelper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfIntHelper n = \ndigitsOfIntHelper (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfIntHelper n = (digitsOfIntHelper (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfIntHelper n = \nif n > 0 then digitsOfIntHelper (n/10) @ [n mod 10] \nelse []", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n == 0 then [0]\nelse digitsOfIntHelper n", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence sumList (digits n)", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "out": "Characters 58-77:\n  else 1 + additivePersistence sumList (digits n);;\n           ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList digits n)", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence (sumList digits n));;\n", "out": "Characters 79-86:\n  else 1 + additivePersistence (sumList digits n);;\n                                ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 0\nelse 1 + additivePersistence (sumList (digits n))", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse additivePersistence (sumList (digits n))", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else additivePersistence (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digits n))", "min": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt n mod 10 ::(n/10) \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) mod 10) :: (n / 10) else [];;\n", "out": "Characters 39-52:\n  if n > 0 then digitsOfInt n mod 10 ::(n/10) \n                ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt (n mod 10) :: n/10\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n mod 10)) :: (n / 10) else [];;\n", "out": "Characters 39-61:\n  if n > 0 then digitsOfInt (n mod 10) :: n/10\n                ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt ((n mod 10) :: n/10)\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then digitsOfInt ((n mod 10) :: (n / 10)) else [];;\n", "out": "Characters 51-71:\n  if n > 0 then digitsOfInt ((n mod 10) :: n/10)\n                            ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: digitsOfInt n/10\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: ((digitsOfInt n) / 10) else [];;\n", "out": "Characters 53-66:\n  if n > 0 then (n mod 10) :: digitsOfInt n/10\n                              ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: digitsOfInt (n/10)\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\nk :: (n mod 10)\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then let k = digitsOfInt (n / 10) in k :: (n mod 10) else [];;\n", "out": "Characters 70-71:\n  k :: (n mod 10)\n  ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\n(n mod 10) :: k\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then let k = digitsOfInt (n / 10) in (n mod 10) :: k else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt (n/10) @ [n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt (n/10) @ [n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digits n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nreverseHelper l []", "min": "\nlet rec reverseHelper l m =\n  match l with | x::s -> reverseHelper s (x :: m) | [] -> m;;\n\nlet rec listReverse l = reverseHelper l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfIntHelper n result =\nif n > 0 then \n(n mod 10) :: digitsOfIntHelper (n/10) result\nelse \nresult", "min": "\nlet rec digitsOfIntHelper n result =\n  if n > 0 then (n mod 10) :: (digitsOfIntHelper (n / 10) result) else result;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt (n/10) @ [n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfIntHelper n result =\nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result\nelse result", "min": "\nlet rec digitsOfIntHelper n result =\n  if n > 0 then (n mod 10) :: (digitsOfIntHelper (n / 10) result) else result;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)", "min": "\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x == y then palindromeHelper s t\n       | _ -> false);;\n", "out": "Characters 153-169:\n  | y :: t -> if x == y then palindromeHelper s t\n                             ^^^^^^^^^^^^^^^^\nError: Unbound value palindromeHelper\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)\n| _ -> false", "min": "\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x == y then palindromeHelper s t\n       | _ -> false)\n  | _ -> false;;\n", "out": "Characters 153-169:\n  | y :: t -> if x == y then palindromeHelper s t\n                             ^^^^^^^^^^^^^^^^\nError: Unbound value palindromeHelper\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)", "min": "\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "out": "Characters 152-168:\n  | y :: t -> if x = y then palindromeHelper s t\n                            ^^^^^^^^^^^^^^^^\nError: Unbound value palindromeHelper\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "out": "Characters 157-177:\n  | y :: t -> if x = y then  palindromeHelper s t\n                             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "out": "Characters 157-177:\n  | y :: t -> if x = y then  palindromeHelper s t\n                             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "out": "Characters 156-176:\n  | y :: t -> if x = y then palindromeHelper s t\n                            ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)\n| _ -> false", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false)\n  | _ -> false;;\n", "out": "Characters 156-176:\n  | y :: t -> if x = y then palindromeHelper s t\n                            ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t\n| _ -> false)\n| _ -> false", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false)\n  | _ -> false;;\n", "out": "Characters 158-178:\n  | y :: t -> if (x = y) then palindromeHelper s t\n                              ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x = y then palindromeHelper s t else false\n       | _ -> false)\n  | _ -> false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x = y then palindromeHelper s t else false\n       | _ -> false);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)", "min": "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x = y then palindromeHelper s t else false\n       | _ -> false);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet wl = explode w in\nlet rl = listReverse wl in\npalindromeHelper wl rl", "min": "\nlet rec reverseHelper l result =\n  match l with | x::s -> reverseHelper s (x :: result) | [] -> result;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper l [];;\n\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x = y then palindromeHelper s t else false\n       | _ -> false);;\n\nlet palindrome w =\n  let wl = explode w in let rl = listReverse wl in palindromeHelper wl rl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet wl = explode w in\nlet rl = listReverse wl in\nrl = wl", "min": "\nlet rec reverseHelper l result =\n  match l with | x::s -> reverseHelper s (x :: result) | [] -> result;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper l [];;\n\nlet palindrome w = let wl = explode w in let rl = listReverse wl in rl = wl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet wl = explode w in\nlet rl = listReverse wl in\nrl = wl", "min": "\nlet rec reverseHelper l result =\n  match l with | x::s -> reverseHelper s (x :: result) | [] -> result;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper l [];;\n\nlet palindrome w = let wl = explode w in let rl = listReverse wl in rl = wl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| x::s -> x + sumList s", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in []", "min": "\nlet rec digitsOfInt n =\n  let result = [] in\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then (n mod 10) :: (digitsOfIntHelper (n / 10) result)\n    else result in\n  [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \ndigitsOfIntHelper n []", "min": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then (n mod 10) :: (digitsOfIntHelper (n / 10) result)\n    else result in\n  digitsOfIntHelper n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \ndigitsOfIntHelper n []", "min": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then (n mod 10) :: (digitsOfIntHelper (n / 10) result)\n    else result in\n  digitsOfIntHelper n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \ndigitsOfIntHelper n []", "min": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then (n mod 10) :: (digitsOfIntHelper (n / 10) result)\n    else result in\n  digitsOfIntHelper n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) ((n mod 10) :: result)\nelse result in \ndigitsOfIntHelper n []", "min": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then digitsOfIntHelper (n / 10) ((n mod 10) :: result)\n    else result in\n  digitsOfIntHelper n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result\nelse result in \ndigitsOfIntHelper n []", "min": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then (digitsOfIntHelper (n / 10) (n mod 10)) :: result\n    else result in\n  digitsOfIntHelper n [];;\n", "out": "Characters 77-112:\n  if n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10 :: result)\nelse result in \ndigitsOfIntHelper n []", "min": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then digitsOfIntHelper (n / 10) ((n mod 10) :: result)\n    else result in\n  digitsOfIntHelper n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec calculate n result = \nif n > 0 then calculate (n/10) (n mod 10 :: result)\nelse result in \ncalculate n []", "min": "\nlet rec digitsOfInt n =\n  let rec calculate n result =\n    if n > 0 then calculate (n / 10) ((n mod 10) :: result) else result in\n  calculate n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec calculate n result = \nif n > 0 then calculate (n/10) (n mod 10 :: result)\nelse result in \ncalculate n []", "min": "\nlet rec digitsOfInt n =\n  let rec calculate n result =\n    if n > 0 then calculate (n / 10) ((n mod 10) :: result) else result in\n  calculate n [];;\n", "out": ""}]}
