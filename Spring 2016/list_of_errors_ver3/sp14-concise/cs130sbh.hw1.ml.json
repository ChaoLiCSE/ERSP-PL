{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| hd::tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "out": "Characters 63-73:\n  | hd::tl -> hd + sumList tl;;\n                   ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| hd::tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "out": "Characters 63-73:\n  | hd::tl -> hd + sumList tl;;\n                   ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt n/10", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: ((digitsOfInt n) / 10);;\n", "out": "Characters 67-80:\n  else n - (n/10) * 10 :: digitsOfInt n/10;;\n                          ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse (n - (n/10) * 10) :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append digitsOfInt (n/10) (n - (n/10) * 10)", "min": "\nlet rec append xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (append tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append digitsOfInt (n / 10) (n - ((n / 10) * 10));;\n", "out": "Characters 47-53:\n  else append digitsOfInt (n/10) (n - (n/10) * 10);;\n       ^^^^^^\nError: This function has type 'a list -> 'a -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse addIntToList (digitsOfInt (n/10)) (n - (n/10) * 10)", "min": "\nlet rec addIntToList xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (addIntToList tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else addIntToList (digitsOfInt (n / 10)) (n - ((n / 10) * 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append (digitsOfInt (n/10)) [(n - (n/10) * 10)]", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append (digitsOfInt (n/10)) [(n - (n/10) * 10)]", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append (digitsOfInt (n/10)) [n - (n/10) * 10]", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = failwith \"TBD\"", "min": "\nlet rec additivePersistence n = failwith \"TBD\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = match digits (n) with\n| [] -> -1\n| hd::tl -> 1 + additivePersistence (sumList tl)", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match digits n with\n  | [] -> (-1)\n  | hd::tl -> 1 + (additivePersistence (sumList tl));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = match digits (n) with\n| [] -> -1\n| hd::tl -> 1 + additivePersistence (sumList tl)", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match digits n with\n  | [] -> (-1)\n  | hd::tl -> 1 + (additivePersistence (sumList tl));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nif n < 10\nthen 0\nelse 1 + additivePersistence (sumList n)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList n));;\n", "out": "Characters 88-89:\n  else 1 + additivePersistence (sumList n);;\n                                        ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10\nthen 0\nelse 1 + additivePersistence (sumList (digits n))", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digits n))", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append (digitsOfInt (n/10)) [n - (n/10) * 10]", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = (hd (listReverse w)) \nthen palindrome (tl (listReverse tail))\nelse false", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (hd (listReverse w))\n      then palindrome (tl (listReverse tail))\n      else false;;\n", "out": "Characters 102-104:\n  if head = (hd (listReverse w)) \n             ^^\nError: Unbound value hd\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = hd (listReverse w)\nthen palindrome (tl (listReverse tail))\nelse false", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (hd (listReverse w))\n      then palindrome (tl (listReverse tail))\n      else false;;\n", "out": "Characters 101-103:\n  if head = hd (listReverse w)\n            ^^\nError: Unbound value hd\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse w)\nthen palindrome (List.tl (listReverse tail))\nelse false", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse w))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n", "out": "Characters 122-123:\n  if head = List.hd (listReverse w)\n                                 ^\nError: This expression has type string but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse [w])\nthen palindrome (List.tl (listReverse [tail]))\nelse false", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse [w]))\n      then palindrome (List.tl (listReverse [tail]))\n      else false;;\n", "out": "Characters 101-126:\n  if head = List.hd (listReverse [w])\n            ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         char\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse tail)\nthen palindrome (List.tl (listReverse tail))\nelse false", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| hd::[] -> true\n| hd::tl -> match (listReverse tl) with\n| hdr::tlr ->\nif hdr = hd\nthen palindrome tlr\nelse false", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | hd::[] -> true\n  | hd::tl ->\n      (match listReverse tl with\n       | hdr::tlr -> if hdr = hd then palindrome tlr else false);;\n", "out": "Characters 154-157:\n  then palindrome tlr\n                  ^^^\nError: This expression has type char list\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = \nlet rec palHelper xs =\nmatch xs with\n| [] -> true\n| hd::tl -> match (listReverse tl) with\n| [] -> true\n| hdr::tlr ->\nif hdr = hd\nthen palindrome tlr\nelse false\nin \npalHelper (explode w)", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n", "out": "Characters 165-168:\n  then palindrome tlr\n                  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = \nlet rec palHelper xs =\nmatch xs with\n| [] -> true\n| hd::tl -> match (listReverse tl) with\n| [] -> true\n| hdr::tlr ->\nif hdr = hd\nthen palindrome tlr\nelse false\nin \npalHelper (explode w)", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n", "out": "Characters 165-168:\n  then palindrome tlr\n                  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec palHelper xs =\nmatch xs with\n| [] -> true\n| hd::tl -> match (listReverse tl) with\n| [] -> true\n| hdr::tlr ->\nif hdr = hd\nthen palHelper tlr\nelse false\nin \npalHelper (explode w)", "min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palHelper tlr else false) in\n  palHelper (explode w);;\n", "out": ""}]}
