{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 41-43:\n  if( n < 0 ) then [];;\n                   ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "in": "let rec digitsOfInt n =\nif( n < 0 ) then []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-61:\n  else helperDigits (n, []);;\n       ^^^^^^^^^^^^\nError: Unbound value helperDigits\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n", "in": "let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])"}, {"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-61:\n  else helperDigits (n, []);;\n       ^^^^^^^^^^^^\nError: Unbound value helperDigits\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n", "in": "let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])"}, {"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-4:\n  let_ = digitsOfInt 0;;\n  ^^^^\nError: Unbound value let_\n", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = let_ = (digitsOfInt 0);;\n", "in": "let_ = digitsOfInt 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \naddPHelper(n, 0, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \naddPHelper(n, 0, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \naddPHelper(n, 0, 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \ndigitalHelper(n, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 66-73:\n  if(converted = (reverse w)) then true\n                  ^^^^^^^\nError: Unbound value reverse\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (reverse w) then true else false;;\n", "in": "let palindrome w = \nlet converted = explode w in \nif(converted = (reverse w)) then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-79:\n  if(converted = (listReverse w)) then true\n                              ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse w) then true else false;;\n", "in": "let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse w)) then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in\nif(n < 10) then n\nelse additivePersistence sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in 1 + 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in 1 + 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse additivePersistence sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \ndigitalHelper(n, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 2 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 0 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse 1 + additivePersistence2 sum"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 170-175:\n  else begin Printf.printf \"bye\" 1 + additivePersistence2 sum end;;\n                           ^^^^^\nError: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else (Printf.printf \"bye\" 1) + (additivePersistence2 sum);;\n", "in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse begin Printf.printf \"bye\" 1 + additivePersistence2 sum end"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 1 end\nelse begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence2 sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl"}]}
