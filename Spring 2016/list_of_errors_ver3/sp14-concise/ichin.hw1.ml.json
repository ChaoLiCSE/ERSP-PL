{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif( n < 0 ) then []", "out": "Characters 41-43:\n  if( n < 0 ) then [];;\n                   ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])", "out": "Characters 49-61:\n  else helperDigits (n, []);;\n       ^^^^^^^^^^^^\nError: Unbound value helperDigits\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n", "type": "scope"}, {"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])", "out": "Characters 49-61:\n  else helperDigits (n, []);;\n       ^^^^^^^^^^^^\nError: Unbound value helperDigits\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n", "type": "scope"}, {"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let_ = digitsOfInt 0", "out": "Characters 0-4:\n  let_ = digitsOfInt 0;;\n  ^^^^\nError: Unbound value let_\n", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = let_ = (digitsOfInt 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \naddPHelper(n, 0, 0)", "out": "", "min": "\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \naddPHelper(n, 0, 0)", "out": "", "min": "\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \naddPHelper(n, 0, 1)", "out": "", "min": "\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \ndigitalHelper(n, 0)", "out": "", "min": "\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet converted = explode w in \nif(converted = (reverse w)) then true\nelse false", "out": "Characters 66-73:\n  if(converted = (reverse w)) then true\n                  ^^^^^^^\nError: Unbound value reverse\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (reverse w) then true else false;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse w)) then true\nelse false", "out": "Characters 78-79:\n  if(converted = (listReverse w)) then true\n                              ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse w) then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false", "out": "", "min": "\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in\nif(n < 10) then n\nelse additivePersistence sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if n < 10 then n else additivePersistence sum;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in 1 + 2", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec additivePersistence n = let newList = digitsOfInt n in 1 + 2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in 1 + 2", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in let sum = sumList newList in 1 + 2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse additivePersistence sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then sum else additivePersistence sum;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \ndigitalHelper(n, 0)", "out": "", "min": "\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 2 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 2 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 0 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 0 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse 1 + additivePersistence2 sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else 1 + (additivePersistence2 sum);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse begin Printf.printf \"bye\" 1 + additivePersistence2 sum end", "out": "Characters 170-175:\n  else begin Printf.printf \"bye\" 1 + additivePersistence2 sum end;;\n                           ^^^^^\nError: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else (Printf.printf \"bye\" 1) + (additivePersistence2 sum);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else (Printf.printf \"bye\"; 1 + (additivePersistence2 sum));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 1 end\nelse begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 1)\n  else (Printf.printf \"bye\"; 1 + (additivePersistence2 sum));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence2 sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum", "out": "", "min": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
