{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + xs in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 78-80:\n  List.fold_left f base xs;;\n                        ^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + xs in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs", "out": "Characters 73-77:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = [] in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = a in\nList.fold_left f base xs", "out": "Characters 50-51:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = a in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x' -> x (a x') in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x' -> x (a x') in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun y -> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun inner -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "out": "Characters 40-41:\n  let f a x = fun inner -> y |> a |> x in\n                           ^\nError: Unbound value y\n", "min": "\nlet pipe fs =\n  let f a x inner = (y |> a) |> x in\n  let base y = y in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = (y |> a) |> x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = (y |> a) |> x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a t in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "out": "Characters 136-137:\n  List.fold_left f base l;;\n                 ^\nError: This expression has type (string list -> string) -> 'a -> string\n       but an expression was expected of type\n         (string list -> string) -> 'a -> string list -> string\n       Type string is not compatible with type string list -> string \n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (a t)) in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^h in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ h) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map f l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map f l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"[\" List.map f l", "out": "Characters 23-32:\n  let stringOfList f l = sepConcat \"[\" List.map f l;;\n                         ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[\" List.map f l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"[\" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[\" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \" \" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let st = sepConcat \";\" (List.map f l) in \"[\" ^ st ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let st = sepConcat \";\" (List.map f l) in \"[\" ^ (st ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let st = sepConcat \"; \" (List.map f l) in \"[\" ^ st ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let st = sepConcat \"; \" (List.map f l) in \"[\" ^ (st ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ mid ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ (mid ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map f l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let mid = List.map f l in \"[\" ^ mid \"]\"", "out": "Characters 55-58:\n  let stringOfList f l = let mid = List.map f l in \"[\" ^ mid \"]\";;\n                                                         ^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet stringOfList f l = let mid = List.map f l in \"[\" ^ (mid \"]\");;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"; \" List.map f l", "out": "Characters 23-32:\n  let stringOfList f l = sepConcat \"; \" List.map f l;;\n                         ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = (List.map f l)", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = (List.map f l)", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ mid", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ mid;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ mid ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ (mid ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0 then []\nelse x::clone x (n-1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet f a l = a+1 l in \nlet base = a\nin List.fold_left f base", "out": "Characters 35-36:\n  let f a l = a+1 l in \n                ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  let f a l = a + (1 l) in let base = a in List.fold_left f base;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) acc l2 in\nif length1 < length2 then true\nelse false", "out": "Characters 73-76:\n  let length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in\n                                                      ^^^\nError: Unbound value acc\n", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) acc l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) acc l2 in\n  if length1 < length2 then true else false;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2 then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2-length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0", "out": "Characters 226-251:\n  then clone (length1-length2) 0;;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0", "out": "Characters 228-253:\n  then clone (length1-length2) 0;;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1 - length2) 0", "out": "Characters 228-255:\n  then clone (length1 - length2) 0;;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone 0 (length2 - length1) \nelse if length2 < length1\nthen clone 0 (length1 - length2)", "out": "Characters 228-255:\n  then clone 0 (length1 - length2);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone 0 (length2 - length1)\n  else if length2 < length1 then clone 0 (length1 - length2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> 0\n| x::l' -> if x = 0\nthen List.fold_left (fun acc x -> acc+1) 0 l", "out": "Characters 71-110:\n  then List.fold_left (fun acc x -> acc+1) 0 l;;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> 0\n  | x::l' -> if x = 0 then List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> l\n| x::l' -> \nif x=0 \nthen removeZero l'\nelse l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, a) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet l = dig :: a in\ncarry, l in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,a) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in let l = dig :: a in (carry, l) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet l = dig :: acc in\ncarry, l in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in let l = dig :: acc in (carry, l) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch acc with\n| []   -> (carry2, carry2 :: dig :: [])\n| h::t -> (carry2, carry2 :: dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match acc with\n      | [] -> (carry2, [carry2; dig])\n      | h::t -> (carry2, (carry2 :: dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch acc with\n| []   -> (carry2, dig :: [])\n| h::t -> (carry2, dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match acc with | [] -> (carry2, [dig]) | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| []   -> (carry2::dig :: [])\n| h::t -> (carry2::dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 204-206:\n  | []   -> (carry2::dig :: [])\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> [carry2; dig] | h::t -> carry2 :: dig :: t in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| []   -> (carry2, dig :: [])\n| h::t -> (carry2, dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 204-206:\n  | []   -> (carry2, dig :: [])\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> (carry2, [dig]) | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| h::t -> (carry2, dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 204-208:\n  | h::t -> (carry2, dig :: t) in\n    ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in match a with | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| (x,y) -> (carry2, dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 229-230:\n  | (x,y) -> (carry2, dig :: t) in\n                             ^\nError: Unbound value t\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | (x,y) -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| (x,y) -> (carry2, dig :: y) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | (x,y) -> (carry2, (dig :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet mid = dig::acc in\n(carry, mid) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in let mid = dig :: acc in (carry, mid) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet mid = dig::acc in\n(carry2, mid) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in let mid = dig :: acc in (carry2, mid) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet mid = dig::acc in\n(carry2, carry2::mid) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      let mid = dig :: acc in (carry2, (carry2 :: mid)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carry2, carry2::dig) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 206-209:\n  (carry2, carry2::dig) in\n                   ^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in (carry2, (carry2 :: dig)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carry2, carry2::dig::[]) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in (carry2, [carry2; dig]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch acc with\n| []   -> (carry2, carry2::dig::[])\n| x::y -> (carry2, carry2::dig::y) in \nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match acc with\n      | [] -> (carry2, [carry2; dig])\n      | x::y -> (carry2, (carry2 :: dig :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in (carryOut, (dig :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 113-115:\n  let sumInit = x1 + x2 + carry in\n                ^^\nError: Unbound value x1\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (d1,d2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in (carryOut, (dig :: acc)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = d1 + d2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (d1,d2) = x in\n      let sumInit = (d1 + d2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in (carryOut, (dig :: acc)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = d1 + d2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (d1,d2) = x in\n      let sumInit = (d1 + d2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in (carryOut, (dig :: acc)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = d1 + d2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet r = dig::acc in\n(carryOut, r) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (d1,d2) = x in\n      let sumInit = (d1 + d2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet r = dig::acc in\n(carryOut, r) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| _ -> bigAdd l (mulByDigit (i-1) l)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(i+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: Unbound value i\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 162-163:\n  (i+1, result) in\n   ^\nError: Unbound value i\n", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig) = x in\n    let prod = (mulByDigit dig l1) @ (clone 0 carry) in\n    let result = bigAdd prod acc in ((i + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig) = x in\n    let prod = (mulByDigit dig l1) @ (clone 0 carry) in\n    let result = bigAdd prod acc in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig) = x in\n    let prod = (mulByDigit dig l1) @ (clone 0 carry) in\n    let result = bigAdd prod acc in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ (clone 0 carry) in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig) = x in\n    let prod = (mulByDigit dig l1) @ (clone 0 carry) in\n    let result = bigAdd prod acc in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ (clone 0 carry) in\nlet result = bigAdd acc prod in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig) = x in\n    let prod = (mulByDigit dig l1) @ (clone 0 carry) in\n    let result = bigAdd acc prod in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet y = mulByDigit dig l1 @ (clone 0 carry) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig) = x in\n    let y = (mulByDigit dig l1) @ (clone 0 carry) in\n    let result = bigAdd acc y in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append mulByDigit dig2 l1 (clone 0 carry) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 90-101:\n  let y = List.append mulByDigit dig2 l1 (clone 0 carry) in\n          ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append mulByDigit dig2 l1 (clone 0 carry) in\n    let result = bigAdd acc y in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 carry) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append (mulByDigit dig2 l1) (clone 0 carry) in\n    let result = bigAdd acc y in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: Unbound value carry\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 176-181:\n  (carry+1, result) in\n   ^^^^^\nError: Unbound value carry\n", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroNum,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n    let result = bigAdd acc y in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd (y) (acc)) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroNum,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n    ((zeroNum + 1), (bigAdd y acc)) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd y acc) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroNum,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n    ((zeroNum + 1), (bigAdd y acc)) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd y acc) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroNum,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n    ((zeroNum + 1), (bigAdd y acc)) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd y acc) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroNum,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n    ((zeroNum + 1), (bigAdd y acc)) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
