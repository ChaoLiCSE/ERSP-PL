{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,n)::t -> if s = k then n else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,n)::t -> if s = k then n else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,n)::t -> if s = k then n else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(h,seen) = False then seen@ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 129-134:\n  let seen' = if List.mem(h,seen) = False then seen@ [h]  in\n                                    ^^^^^\nError: Unbound constructor False\nHint: Did you mean false?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = False then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(h,seen) = false then seen@ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 129-134:\n  let seen' = if List.mem(h,seen) = false then seen@ [h]  in\n                                    ^^^^^\nError: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then seen@ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 138-147:\n  let seen' = if List.mem h seen= false then seen@ [h]  in\n                                             ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then seen @ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 138-148:\n  let seen' = if List.mem h seen= false then seen @ [h]  in\n                                             ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then seen @ h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 145-146:\n  let seen' = if List.mem h seen= false then seen @ h in\n                                                    ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then seen @ [h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 138-148:\n  let seen' = if List.mem h seen= false then seen @ [h] in\n                                             ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then [h]@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 138-146:\n  let seen' = if List.mem h seen= false then [h]@seen in\n                                             ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,n)::t -> if s = k then n else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,n)::t -> if s = k then n else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then seen@ [h] else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then [h]@seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f with\n| (x,true) -> f x\n| (x,false) -> x", "out": "Characters 50-51:\n  | (x,true) -> f x\n                ^\nError: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec wwhile (f,b) = match f with | (x,true ) -> f x | (x,false ) -> x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f with\n|(x,true) -> wwhile(f x)\n| (x,false) -> x", "out": "Characters 56-57:\n  |(x,true) -> wwhile(f x)\n                      ^\nError: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,true ) -> wwhile (f x) | (x,false ) -> x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f with\n(n,boo) -> f b", "out": "Characters 47-48:\n  (n,boo) -> f b;;\n             ^\nError: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec wwhile (f,b) = match f with | (n,boo) -> f b;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f with\n| (x,true)->x", "out": "", "min": "\nlet rec wwhile (f,b) = match f with | (x,true ) -> x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f with\n| (x,false)->x", "out": "", "min": "\nlet rec wwhile (f,b) = match f with | (x,false ) -> x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f with\n| (x,false)->x\n| (x,true) -> wwhile(f,x)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "out": "Characters 54-55:\n  let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2);;\n                                                        ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "\nlet _ = fixpoint (collatz, 1) ", "out": "Characters 9-17:\n  let _ = fixpoint (collatz, 1) ;;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ = fixpoint (collatz, 1);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((\nlet (x,y) = f b in (x!=b)),b)", "out": "Characters 50-56:\n  let (x,y) = f b in (x!=b)),b);;\n                     ^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in x != b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((\nlet (x,y) = f b in (x<>b)),b)", "out": "Characters 50-56:\n  let (x,y) = f b in (x<>b)),b);;\n                     ^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in x <> b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((\nlet (x,y) = f b in (x>b or x<b)),b)", "out": "Characters 50-62:\n  let (x,y) = f b in (x>b or x<b)),b);;\n                     ^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x > b) or (x < b)), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let (x,y) = f b in\nif x<>b && y=true then (x,y)\nelse if x=b then ( x,false)),b)", "out": "Characters 72-77:\n  if x<>b && y=true then (x,y)\n                         ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let (x,y) = f b in\n      if (x <> b) && (y = true) then (x, y) else if x = b then (x, false)),\n      b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let (x,y) = f b in\nif x<>b && y=true then (x,true)\nelse if x=b then ( x,false)),b)", "out": "Characters 72-80:\n  if x<>b && y=true then (x,true)\n                         ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let (x,y) = f b in\n      if (x <> b) && (y = true) then (x, true) else if x = b then (x, false)),\n      b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "\nlet _ = fixpoint (collatz, 1) ", "out": "Characters 9-17:\n  let _ = fixpoint (collatz, 1) ;;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ = fixpoint (collatz, 1);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "\nlet _ = fixpoint (collatz, 1) ", "out": "Characters 9-17:\n  let _ = fixpoint (collatz, 1) ;;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ = fixpoint (collatz, 1);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "\nlet _ = fixpoint (collatz, 1) ", "out": "Characters 9-17:\n  let _ = fixpoint (collatz, 1) ;;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ = fixpoint (collatz, 1);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false) in f),b)", "out": "Characters 72-75:\n  let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false) in f),b);;\n                                                                          ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type int\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f f b =\n        if ((f b) = (b, true)) && ((b, true) = ((f b) - 1)) then (b, false) in\n      f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in f),b)", "out": "Characters 85-94:\n  let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in f),b);;\n                                                                                       ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f f b =\n        if ((f b) = (b, true)) && ((b, true) = (f (b - 1))) then (b, false) in\n      f), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b && (x,y)<>f (b-1))),b)", "out": "Characters 48-75:\n  let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b && (x,y)<>f (b-1))),b);;\n                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let (x,y) = f b in (x, ((x <> b) && ((x, y) <> (f (b - 1)))))), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b)),b)", "out": "Characters 48-57:\n  let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b)),b);;\n                                                  ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x <> b))), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x!=b)),b)", "out": "Characters 48-57:\n  let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x!=b)),b);;\n                                                  ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x != b))), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x>b||x<b)),b)", "out": "Characters 48-61:\n  let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x>b||x<b)),b);;\n                                                  ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let (x,y) = f b in (x, ((x > b) || (x < b)))), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<100)),b)", "out": "Characters 48-58:\n  let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<100)),b);;\n                                                  ^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x < 100))), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx<>x)in a),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (xx <> x)) in a), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx!=x)in a),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (xx != x)) in a), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (xx != x)) in a), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (xx != x)) in a), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx!=x)in a),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (xx != x)) in a), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,n)::t -> if s = k then n else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\" | VarY  -> \"y\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY@\"/\"@VarX\n| Cosine -> VarX@\"/\"@VarY", "out": "Characters 68-72:\n  | Sine -> VarY@\"/\"@VarX\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> VarY @ (\"/\" @ VarX)\n  | Cosine  -> VarX @ (\"/\" @ VarY);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY^\"/\"^VarX\n| Cosine -> VarX^\"/\"^VarY", "out": "Characters 68-72:\n  | Sine -> VarY^\"/\"^VarX\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> VarY ^ (\"/\" ^ VarX)\n  | Cosine  -> VarX ^ (\"/\" ^ VarY);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e", "out": "Characters 68-72:\n  | Sine ->  exprToString e\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString e\n  | Cosine  -> exprToString e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e", "out": "Characters 68-72:\n  | Sine ->  exprToString e\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString e\n  | Cosine  -> exprToString e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString VarX\n| Cosine -> exprToString e", "out": "Characters 68-72:\n  | Sine ->  exprToString VarX\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString VarX\n  | Cosine  -> exprToString e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine -> exprToString e", "out": "Characters 95-101:\n  | Cosine -> exprToString e;;\n    ^^^^^^\nError: The constructor Cosine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine  -> exprToString e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine e -> exprToString e;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "out": "Characters 153-162:\n  | Average e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\";;\n    ^^^^^^^^^\nError: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "Characters 321-324:\n  | Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\";;\n                                                ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           ((\"<\" exprToString e2) ^\n              (\" ? \" ^\n                 ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\"))))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let aa = exprToString Average(VarX, VarY)", "out": "Characters 9-21:\n  let aa = exprToString Average(VarX, VarY);;\n           ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarX, VarY);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let aa =exprToString Average(VarX, VarY)", "out": "Characters 8-20:\n  let aa =exprToString Average(VarX, VarY);;\n          ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarX, VarY);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let aa =exprToString VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let aa =exprToString Average(VarY,VarX)", "out": "Characters 8-20:\n  let aa =exprToString Average(VarY,VarX);;\n          ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarY, VarX);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2)\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"((\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2)\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine -> buildSine(e)", "out": "Characters 73-77:\n  | Sine -> buildSine(e);;\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine  -> buildSine e;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(e)", "out": "Characters 82-94:\n  | Sine e-> buildSine(e);;\n             ^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine e;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(x)", "out": "Characters 82-94:\n  | Sine e-> buildSine(x);;\n             ^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)", "out": "Characters 83-96:\n  | Sine e1-> buildSine(e1);;\n              ^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)", "out": "Characters 83-96:\n  | Sine e1-> buildSine(e1);;\n              ^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> 0.34*e", "out": "Characters 82-86:\n  | Sine e-> 0.34*e;;\n             ^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> 0.34 * e;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> build(pi*e)", "out": "Characters 88-90:\n  | Sine e-> build(pi*e);;\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> build (pi * e);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX | VarY  -> buildY;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX * 1.0\n| VarY -> buildY * 1.0", "out": "Characters 47-53:\n  | VarX -> buildX * 1.0\n            ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX * 1.0 | VarY  -> buildY * 1.0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX * 1.0", "out": "Characters 47-53:\n  | VarX -> buildX * 1.0;;\n            ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX * 1.0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX() * 1.0", "out": "Characters 47-55:\n  | VarX -> buildX() * 1.0;;\n            ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> (buildX ()) * 1.0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x * 1.0", "out": "Characters 51-54:\n  | VarX -> x * 1.0;;\n                ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x * 1.0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX()", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX ();;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e -> pi*e", "out": "Characters 73-75:\n  | Sine e -> pi*e;;\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> pi * e;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e -> buildSine(e)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> buildSine e;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> VarX\n| VarY -> VarY\n| Sine e -> buildSine(e)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> VarX | VarY  -> VarY | Sine e -> buildSine e;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> VarX\n| VarY -> VarY\n| Sine e -> buildSine(e)\n| Cosine e -> buildCosine (e)\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e -> buildSine e\n  | Cosine e -> buildCosine e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> VarX\n| VarY -> VarY\n| Sine e -> buildSine(e)\n| Cosine e -> buildCosine (e)\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e -> buildSine e\n  | Cosine e -> buildCosine e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "Characters 64-66:\n  assert (-1.0 <= rv && rv <= 1.0);\n                  ^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e -> buildSine e\n  | Cosine e -> buildCosine e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": "type"}, {"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e -> buildSine(e)\n| Cosine e -> buildCosine (e)\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> buildSine e\n  | Cosine e -> buildCosine e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e -> pi*e\n| Cosine e -> pi*e\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "out": "Characters 73-75:\n  | Sine e -> pi*e\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x*1.00\n| VarY -> y*1.00\n| Sine e -> pi*e\n| Cosine e -> pi*e\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "out": "Characters 49-53:\n  | VarX -> x*1.00\n              ^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x * 1.00\n  | VarY  -> y * 1.00\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> float*x\n| VarY -> float*y\n| Sine e -> pi*e\n| Cosine e -> pi*e\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "out": "Characters 46-51:\n  | VarX -> float*x\n            ^^^^^\nError: This expression has type int -> float\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float * x\n  | VarY  -> float * y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*e\n| Cosine e -> pi*e\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "out": "Characters 72-74:\n  | Sine e -> pi*e\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "out": "Characters 72-74:\n  | Sine e -> pi*x\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (e1+.e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "out": "Characters 118-120:\n  | Average (e1,e2)-> (e1+.e2)/2\n                       ^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float)(e1+e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "out": "Characters 125-127:\n  | Average (e1,e2)-> (float)(e1+e2)/2\n                              ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (float (e1 + e2)) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2\n| Times (e1, e2)-> float_of_int e1*.float_of_int e2\n| Thresh (e1,e2,e3,e4)->(float_of_int e1<float_of_int e2 ? float_of_int e3:float_of_int e4)", "out": "Characters 131-133:\n  | Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2\n                                    ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((float_of_int e1) +. (float_of_int e2)) / 2\n  | Times (e1,e2) -> (float_of_int e1) *. (float_of_int e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((float_of_int e1) < (float_of_int e2 ?float_of_int e3) : float_of_int\n                                                                  e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2) -> (e1+e2)/2 \n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "out": "Characters 72-74:\n  | Sine e -> pi*x\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (e1+.e2)/2 \n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "out": "Characters 119-121:\n  | Average (e1,e2) -> (e1+.e2)/2 \n                        ^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> buildAverage(e1,e2)", "out": "Characters 118-137:\n  | Average (e1,e2) -> buildAverage(e1,e2);;\n                       ^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> buildAverage (e1, e2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2) -> buildAverage(e1,e2)", "out": "Characters 72-74:\n  | Sine e -> pi*x\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> buildAverage (e1, e2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0", "out": "Characters 120-122:\n  | Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0;;\n                         ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((e1 * 1.00) + (e2 * 1.00)) /. 2.0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0", "out": "Characters 120-122:\n  | Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0;;\n                         ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((e1 * 1.00) +. (e2 * 1.00)) /. 2.0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)", "out": "Characters 133-138:\n  | Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n                                      ^^^^^\nError: Unbound value evail\nHint: Did you mean eval?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (evail (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (evail (e2, x, y));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.eval(e,x,y)\n| Cosine e-> pi*.eval(e,x,y)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, x, y))\n  | Cosine e -> pi *. (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> eval(e,x,y)\n| VarY -> eval(e,x,y)\n| Sine e -> pi*.eval(e,x,y)\n| Cosine e-> pi*.eval(e,x,y)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> eval (e, x, y)\n  | VarY  -> eval (e, x, y)\n  | Sine e -> pi *. (eval (e, x, y))\n  | Cosine e -> pi *. (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.eval(e,x,y)\n| Cosine e-> pi*.eval(e,x,y)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, x, y))\n  | Cosine e -> pi *. (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.e\n| Cosine e-> pi*.e\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. e\n  | Cosine e -> pi *. e\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.eval(e,VarX,VarY)\n| Cosine e-> pi*.eval(e,VarX,VarY)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, VarX, VarY))\n  | Cosine e -> pi *. (eval (e, VarX, VarY))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.eval(e,x,y)\n| Cosine e-> pi*.eval(e,x,y)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, x, y))\n  | Cosine e -> pi *. (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "Characters 38-42:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": "scope"}, {"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": "scope"}, {"in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (d1,k1,l1) =\n    match l1 with\n    | (s,n)::t -> if s = k1 then n else assoc (d1, k1, t)\n    | [] -> d1 in\n  helper (d, k, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse helper(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (d1,k1,l1) =\n    match l1 with\n    | (s,n)::t -> if s = k1 then n else helper (d1, k1, t)\n    | [] -> d1 in\n  helper (d, k, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse helper(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (d1,k1,l1) =\n    match l1 with\n    | (s,n)::t -> if s = k1 then n else helper (d1, k1, t)\n    | [] -> d1 in\n  helper (d, k, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then [h]@seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec ww (f1,b1) =\n    match f1 b1 with | (x,true ) -> ww (f1, x) | (x,false ) -> x in\n  ww (f, b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx!=x)in a),b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let rec ww (f1,b1) =\n    match f1 b1 with | (x,true ) -> ww (f1, x) | (x,false ) -> x in\n  ww (f, b);;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (xx != x)) in a), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nmatch rand depth with\n| (1,d) -> d=(d-1) && buildX()\n| (2,d) -> d=(d-1) && buildY()", "out": "Characters 75-83:\n  | (1,d) -> d=(d-1) && buildX()\n                        ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         bool\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand depth with\n  | (1,d) -> (d = (d - 1)) && (buildX ())\n  | (2,d) -> (d = (d - 1)) && (buildY ());;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet build(rand) = if rand=1 then buildX() else buildY()\nin (depth-1,depth>0)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let build rand = if rand = 1 then buildX () else buildY () in\n  ((depth - 1), (depth > 0));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet build(r) = if r=1 then buildX() else buildY() in (depth-1,depth>0)\nin build(r)", "out": "Characters 110-113:\n  in build(r);;\n          ^^^\nError: Unbound value r\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let build r = if r = 1 then buildX () else buildY () in\n    ((depth - 1), (depth > 0)) in\n  build r;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet buildd(r,d) = if r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(build(r,d))\nelse if r=4 then buildCosine(build(r,d))\nelse if r=5 then buildTimes(build(r1,d1),build(r2,d2))\nelse buildThresh(build(r1,d1), build(r2,2), build(r2,d2), build(r2,d2)) in (depth-1,depth>0)\nin buildd(rand,depth)", "out": "Characters 124-136:\n  else if r=3 then buildSine(build(r,d))\n                            ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((depth - 1), (depth > 0)) in\n  buildd (rand, depth);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet buildd(r,d) = \nif r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(build(r,d))\nelse if r=4 then buildCosine(build(r,d))\nelse if r=5 then buildTimes(build(r1,d1),build(r2,d2))\nelse buildThresh(build(r1,d1), build(r2,2), build(r2,d2), build(r2,d2)) in (d-1,d>0)\nin buildd(rand,depth)", "out": "Characters 125-137:\n  else if r=3 then buildSine(build(r,d))\n                            ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet buildd(r,d) = \nif r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(buildd(r,d))\nelse if r=4 then buildCosine(buildd(r,d))\nelse if r=5 then buildTimes(buildd(r1,d1),buildd(r2,d2))\nelse buildThresh(buildd(r1,d1), buildd(r2,2), buildd(r2,d2), buildd(r2,d2)) in (d-1,d>0)\nin buildd(rand,depth)", "out": "Characters 126-132:\n  else if r=3 then buildSine(buildd(r,d))\n                             ^^^^^^\nError: Unbound value buildd\nHint: Did you mean build, buildY or buildX?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (buildd (r, d))\n          else\n            if r = 4\n            then buildCosine (buildd (r, d))\n            else\n              if r = 5\n              then buildTimes ((buildd (r1, d1)), (buildd (r2, d2)))\n              else\n                buildThresh\n                  ((buildd (r1, d1)), (buildd (r2, 2)), (buildd (r2, d2)),\n                    (buildd (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet rec helper (r,d) = \nif r=1 then buildX()\nelse if r=2 then buildY()\nelse if r=3 then buildSine(helper(r1,d1))\nelse if r=4 then buildCosine(helper(r1,d1))\nelse if r=5 then buildAverage (helper(r1,d1),helper(r2,d2))\nelse if r=6 then buildTimes(helper(r1,d1),helper(r2,d2))\nelse buildTresh(helper(r1,d1),helper(r2,d2),helper(r3,d3),helper(r4,d4))\nin (d,d>=0)\nin helper(rand,depth)", "out": "Characters 136-138:\n  else if r=3 then buildSine(helper(r1,d1))\n                                    ^^\nError: Unbound value r1\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let rec helper (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (helper (r1, d1))\n          else\n            if r = 4\n            then buildCosine (helper (r1, d1))\n            else\n              if r = 5\n              then buildAverage ((helper (r1, d1)), (helper (r2, d2)))\n              else\n                if r = 6\n                then buildTimes ((helper (r1, d1)), (helper (r2, d2)))\n                else\n                  buildTresh\n                    ((helper (r1, d1)), (helper (r2, d2)), (helper (r3, d3)),\n                      (helper (r4, d4))) in\n    (d, (d >= 0)) in\n  helper (rand, depth);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet rec helper (r,d) = \nif r=1 then buildX()\nelse if r=2 then buildY()\nelse if r=3 then buildSine(helper(r,d))\nelse if r=4 then buildCosine(helper(r1,d1))\nelse if r=5 then buildAverage (helper(r1,d1),helper(r2,d2))\nelse if r=6 then buildTimes(helper(r1,d1),helper(r2,d2))\nelse buildTresh(helper(r1,d1),helper(r2,d2),helper(r3,d3),helper(r4,d4))\nin (d,d>=0)\nin helper(rand,depth)", "out": "Characters 178-180:\n  else if r=4 then buildCosine(helper(r1,d1))\n                                      ^^\nError: Unbound value r1\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let rec helper (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (helper (r, d))\n          else\n            if r = 4\n            then buildCosine (helper (r1, d1))\n            else\n              if r = 5\n              then buildAverage ((helper (r1, d1)), (helper (r2, d2)))\n              else\n                if r = 6\n                then buildTimes ((helper (r1, d1)), (helper (r2, d2)))\n                else\n                  buildTresh\n                    ((helper (r1, d1)), (helper (r2, d2)), (helper (r3, d3)),\n                      (helper (r4, d4))) in\n    (d, (d >= 0)) in\n  helper (rand, depth);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet buildd(r,d) = \nif r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(buildd(r1,d1-1))\nelse if r=4 then buildCosine(buildd(r1,d1-1))\nelse if r=5 then buildTimes(buildd(r1,d1),buildd(r2,d2))\nelse buildThresh(buildd(r1,d1), buildd(r2,2), buildd(r2,d2), buildd(r2,d2)) in (d-1,d>0)\nin buildd(rand,depth)", "out": "Characters 126-132:\n  else if r=3 then buildSine(buildd(r1,d1-1))\n                             ^^^^^^\nError: Unbound value buildd\nHint: Did you mean build, buildY or buildX?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (buildd (r1, (d1 - 1)))\n          else\n            if r = 4\n            then buildCosine (buildd (r1, (d1 - 1)))\n            else\n              if r = 5\n              then buildTimes ((buildd (r1, d1)), (buildd (r2, d2)))\n              else\n                buildThresh\n                  ((buildd (r1, d1)), (buildd (r2, 2)), (buildd (r2, d2)),\n                    (buildd (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if !List.mem h seen then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 111-119:\n  let seen' = if !List.mem h seen then [h]@seen' in\n                  ^^^^^^^^\nError: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h,seen)=false then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 128-133:\n  let seen' = if List.mem (h,seen)=false then [h]@seen' in\n                                   ^^^^^\nError: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = false then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(seen,h)=false then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 127-132:\n  let seen' = if List.mem(seen,h)=false then [h]@seen' in\n                                  ^^^^^\nError: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (seen, h)) = false then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(h,seen) then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 110-126:\n  let seen' = if List.mem(h,seen) then [h]@seen' in\n                 ^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(seen h) then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 110-126:\n  let seen' = if List.mem(seen h) then [h]@seen' in\n                 ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (seen h) then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 135-140:\n  let seen' = if List.mem h seen then [h]@seen' in\n                                          ^^^^^\nError: Unbound value seen'\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then [h]@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 131-139:\n  let seen' = if List.mem h seen then [h]@seen in\n                                      ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 133-137:\n  let seen' = if List.mem h seen then h@seen in\n                                        ^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then [h]@ seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 131-140:\n  let seen' = if List.mem h seen then [h]@ seen in\n                                      ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then [h]@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 131-139:\n  let seen' = if List.mem h seen then [h]@seen in\n                                      ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then h@[seen] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 142-146:\n  let seen' = if (List.mem h seen)=false then h@[seen] in\n                                                 ^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h @ [seen] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 141-145:\n  let seen' = if (List.mem h seen)=false then h@seen in\n                                                ^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen @ h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 146-147:\n  let seen' = if (List.mem h seen)=false then seen @ h in\n                                                     ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen @ [h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 139-149:\n  let seen' = if (List.mem h seen)=false then seen @ [h] in\n                                              ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen[] @ [h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 139-143:\n  let seen' = if (List.mem h seen)=false then seen[] @ [h] in\n                                              ^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then (seen []) @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen@[h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 139-147:\n  let seen' = if (List.mem h seen)=false then seen@[h] in\n                                              ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then [seen]@[h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 147-148:\n  let seen' = if (List.mem h seen)=false then [seen]@[h] in\n                                                      ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [seen] @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen@[h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 139-147:\n  let seen' = if (List.mem h seen)=false then seen@[h] in\n                                              ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen@[h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 139-147:\n  let seen' = if (List.mem h seen)=false then seen@[h] in\n                                              ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match rand depth with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))", "out": "Characters 129-130:\n  |2->buildSine(build(r,depth-1))\n                      ^\nError: This expression has type int * int -> int\n       but an expression was expected of type 'a -> (int * int -> int) * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand depth with\n  | (r,depth) ->\n      (match r (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (r, (depth - 1)))\n       | 3 -> buildCosine (build (r, (depth - 1)))\n       | 4 ->\n           buildAverage ((build (r, (depth - 1))), (build (r, (depth - 1))))\n       | 5 -> buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (r, (depth - 1))), (build (r, (depth - 1))),\n               (build (r, (depth - 1))), (build (r, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (d1,k1,l1) =\n    match l1 with\n    | (s,n)::t -> if s = k1 then n else assoc (d1, k1, t)\n    | [] -> d1 in\n  helper (d, k, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match rand depth with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "out": "Characters 129-130:\n  |2->buildSine(build(r,depth-1))\n                      ^\nError: This expression has type int * int -> int\n       but an expression was expected of type 'a -> (int * int -> int) * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match rand depth with\n    | (r,depth) ->\n        (match r (0, 6) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "out": "Characters 368-373:\n  |6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0);;\n                                                                                           ^^^^^\nError: Unbound value depth\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 6) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "out": "Characters 368-373:\n  |6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0);;\n                                                                                           ^^^^^\nError: Unbound value depth\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 7) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "out": "Characters 368-373:\n  |_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0);;\n                                                                                           ^^^^^\nError: Unbound value depth\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 7) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "out": "Characters 147-148:\n  |2->buildSine(build(r,depth-1))\n                      ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(_,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "out": "Characters 147-148:\n  |2->buildSine(build(r,depth-1))\n                      ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (_,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1)) in (depth, depth>=0)", "out": "Characters 414-419:\n  |_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1)) in (depth, depth>=0);;\n                                                                                                       ^^^^^\nError: Unbound value depth\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (rand, (depth - 1)))\n         | 3 -> buildCosine (build (rand, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         | 5 ->\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1/.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1/.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "Characters 129-136:\n  | ArcSine e -> 1/.sin(pi*.eval(e,x,y))\n    ^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor ArcSine does not belong to type expr\nHint: Did you mean Sine?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1 /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1 /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| ArcSine  of expr\n| ArcCosine of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| ArcSine e -> \"arcsine(1/sin(pi*\"^ exprToString e^\"))\"\n| ArcCosine e->\"arcCosine(1/cos(pi*\"^ exprToString e^\"))\"\n| Average (e1,e2) ->\"((\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2)\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | ArcSine e -> \"arcsine(1/sin(pi*\" ^ ((exprToString e) ^ \"))\")\n  | ArcCosine e -> \"arcCosine(1/cos(pi*\" ^ ((exprToString e) ^ \"))\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1/.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1/.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "Characters 142-143:\n  | ArcSine e -> 1/.sin(pi*.eval(e,x,y))\n                 ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1 /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1 /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1./.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1./.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1. /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1. /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (d1,k1,l1) =\n    match l1 with\n    | (s,n)::t -> if s = k1 then n else assoc (d1, k1, t)\n    | [] -> d1 in\n  helper (d, k, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (d1,k1,l1) =\n    match l1 with\n    | (s,n)::t -> if s = k1 then n else assoc (d1, k1, t)\n    | [] -> d1 in\n  helper (d, k, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1. /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1. /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (d1,k1,l1) =\n    match l1 with\n    | (s,n)::t -> if s = k1 then n else assoc (d1, k1, t)\n    | [] -> d1 in\n  helper (d, k, l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then [h]@seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\n(*\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1./.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1./.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)\n*) \"fail with\"", "out": "", "min": "\nlet rec eval (e,x,y) = \"fail with\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) =\n\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1./.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1./.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1. /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1. /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1. /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1. /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | ArcSine e -> \"arcsine(1/sin(pi*\" ^ ((exprToString e) ^ \"))\")\n  | ArcCosine e -> \"arcCosine(1/cos(pi*\" ^ ((exprToString e) ^ \"))\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
