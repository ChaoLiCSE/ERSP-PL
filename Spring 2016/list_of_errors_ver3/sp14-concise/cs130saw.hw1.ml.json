{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "Characters 15-26:\n  let digits n = digitsOfInt (abs n);;\n                 ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet digits n = digitsOfInt (abs n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = let x = 3 in x+2", "out": "", "min": "\nlet rec additivePersistence n = let x = 3 in x + 2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))", "out": "Characters 91-98:\n  else additivePersistence (a+1, sumList(digits n));;\n                                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))", "out": "Characters 91-98:\n  else additivePersistence (a+1, sumList(digits n));;\n                                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (0, n)\nelse additivePersistence (a+1, sumList(digits n))", "out": "Characters 91-98:\n  else additivePersistence (a+1, sumList(digits n));;\n                                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (0, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse (digitalRoot (sumList (digits n)))", "out": "Characters 61-68:\n  else (digitalRoot (sumList (digits n)));;\n                     ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))", "out": "Characters 91-98:\n  else additivePersistence (a+1, sumList(digits n));;\n                                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))\nin 4", "out": "Characters 134-135:\n  in 4;;\n     ^\nError: This expression has type int but an expression was expected of type\n         int * int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  4;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))\nin (4,5)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse intFun (a+1, sumList(digits n))\nin (4,5)", "out": "Characters 86-92:\n  else intFun (a+1, sumList(digits n))\n       ^^^^^^\nError: Unbound value intFun\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10 then (a, n) else intFun ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistenceDigitalRoot (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistenceDigitalRoot (a+1, sumList(digits n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistenceDigitalRoot (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistenceDigitalRoot ((a + 1), (sumList (digits n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence (n) = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistenceDigitalRoot (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistenceDigitalRoot ((a + 1), (sumList (digits n)));;\n\nlet rec additivePersistence n =\n  let (a,b) = additivePersistenceDigitalRoot (0, n) in b;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistenceDigitalRoot (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistenceDigitalRoot ((a + 1), (sumList (digits n)));;\n\nlet rec additivePersistence n =\n  let (a,b) = additivePersistenceDigitalRoot (0, n) in b;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigital (0, n)\nin a", "out": "Characters 38-64:\n  let (a, b) = additivePersistenceDigital (0, n)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistenceDigital\n", "min": "\nlet rec digitalRoot n = let (a,b) = additivePersistenceDigital (0, n) in a;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin a", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistenceDigitalRoot (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistenceDigitalRoot ((a + 1), (sumList (digits n)));;\n\nlet rec digitalRoot n =\n  let (a,b) = additivePersistenceDigitalRoot (0, n) in a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n[] -> []\n| x :: xs -> (listReverse xs) @ [x]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = failwith \"TBD\"", "out": "", "min": "\nlet palindrome w = failwith \"TBD\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindrome (w, p + 1)", "out": "", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindrome (w, (p + 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "out": "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 129-140:\n  else palindromeA (w, p + 1);;\n       ^^^^^^^^^^^\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n", "min": "\nlet palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "out": "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 129-140:\n  else palindromeA (w, p + 1);;\n       ^^^^^^^^^^^\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n", "min": "\nlet palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "out": "", "min": "\nlet rec palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "out": "", "min": "\nlet rec palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif ((List.length w) < (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "out": "", "min": "\nlet rec palindromeA (w,p) =\n  if\n    ((List.length w) < (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif ((List.length w) <= (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "out": "", "min": "\nlet rec palindromeA (w,p) =\n  if\n    ((List.length w) <= (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse false\nelse palindromeA (w, p + 1)", "out": "", "min": "\nlet rec palindromeA (w,p) =\n  if (List.length w) <= (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then true\n     else false)\n  else palindromeA (w, (p + 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "out": "Characters 129-139:\n  then palindrome (w, p + 1)\n       ^^^^^^^^^^\nError: Unbound value palindrome\nHint: Did you mean palindromeA?\n", "min": "\nlet rec palindromeA (w,p) =\n  if (List.length w) <= (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then palindrome (w, (p + 1))\n     else false)\n  else true;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "out": "", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec palindromeA (w,p) =\n  if (List.length w) < (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then palindrome (w, (p + 1))\n     else false)\n  else true;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "out": "", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec palindromeA (w,p) =\n  if (List.length w) < (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then palindrome (w, (p + 1))\n     else false)\n  else true;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "out": "", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec palindromeA (w,p) =\n  if (List.length w) < (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w ((List.length w) - p))\n     then palindrome (w, (p + 1))\n     else false)\n  else true;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "out": "", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec palindromeA (w,p) =\n  if (List.length w) < (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then palindrome (w, (p + 1))\n     else false)\n  else true;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "out": "", "min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec palindromeA (w,p) =\n  if (List.length w) > (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then palindrome (w, (p + 1))\n     else false)\n  else true;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindromeA (w, p + 1)\nelse false\nelse true", "out": "", "min": "\nlet rec palindromeA (w,p) =\n  if (List.length w) > (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then palindromeA (w, (p + 1))\n     else false)\n  else true;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = palindromeA (explode w, 0)", "out": "Characters 32-39:\n  let palindrome w = palindromeA (explode w, 0);;\n                                  ^^^^^^^\nError: Unbound value explode\n", "min": "\nlet rec palindromeA (w,p) =\n  if (List.length w) > (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then palindromeA (w, (p + 1))\n     else false)\n  else true;;\n\nlet palindrome w = palindromeA ((explode w), 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = palindromeA (explode w, 0)", "out": "Characters 32-39:\n  let palindrome w = palindromeA (explode w, 0);;\n                                  ^^^^^^^\nError: Unbound value explode\n", "min": "\nlet rec palindromeA (w,p) =\n  if (List.length w) > (2 * p)\n  then\n    (if (List.nth w p) = (List.nth w (((List.length w) - 1) - p))\n     then palindromeA (w, (p + 1))\n     else false)\n  else true;;\n\nlet palindrome w = palindromeA ((explode w), 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin a", "out": "Characters 46-76:\n  let (a, b) = additivePersistenceDigitalRoot (0, n)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistenceDigitalRoot\n", "min": "\nlet rec additivePersistence n =\n  let (a,b) = additivePersistenceDigitalRoot (0, n) in a;;\n", "type": "scope"}, {"in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b", "out": "Characters 38-68:\n  let (a, b) = additivePersistenceDigitalRoot (0, n)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistenceDigitalRoot\n", "min": "\nlet rec digitalRoot n =\n  let (a,b) = additivePersistenceDigitalRoot (0, n) in b;;\n", "type": "scope"}, {"in": "let rec listReverse l = match l with\n[] -> []\n| x :: xs -> (listReverse xs) @ [x]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs -> (listReverse xs) @ [x];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "type": ""}]}
