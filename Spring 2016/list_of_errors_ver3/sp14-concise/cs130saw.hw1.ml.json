{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 15-26:\n  let digits n = digitsOfInt (abs n);;\n                 ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet digits n = digitsOfInt (abs n);;\n", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = let x = 3 in x+2"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 91-98:\n  else additivePersistence (a+1, sumList(digits n));;\n                                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 91-98:\n  else additivePersistence (a+1, sumList(digits n));;\n                                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 91-98:\n  else additivePersistence (a+1, sumList(digits n));;\n                                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (0, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (0, n)\nelse additivePersistence (a+1, sumList(digits n))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 61-68:\n  else (digitalRoot (sumList (digits n)));;\n                     ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse (digitalRoot (sumList (digits n)))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 91-98:\n  else additivePersistence (a+1, sumList(digits n));;\n                                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-135:\n  in 4;;\n     ^\nError: This expression has type int but an expression was expected of type\n         int * int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  4;;\n", "in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))\nin 4"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))\nin (4,5)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 86-92:\n  else intFun (a+1, sumList(digits n))\n       ^^^^^^\nError: Unbound value intFun\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10 then (a, n) else intFun ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse intFun (a+1, sumList(digits n))\nin (4,5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistenceDigitalRoot (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistenceDigitalRoot (a+1, sumList(digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence (n) = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-64:\n  let (a, b) = additivePersistenceDigital (0, n)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistenceDigital\n", "min": "\nlet rec digitalRoot n = let (a,b) = additivePersistenceDigital (0, n) in a;;\n", "in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigital (0, n)\nin a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n[] -> []\n| x :: xs -> (listReverse xs) @ [x]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = failwith \"TBD\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindrome (w, p + 1)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 129-140:\n  else palindromeA (w, p + 1);;\n       ^^^^^^^^^^^\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n", "min": "\nlet palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "in": "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 129-140:\n  else palindromeA (w, p + 1);;\n       ^^^^^^^^^^^\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n", "min": "\nlet palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "in": "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = palindromeA (['a','b', 'c'], 0);;\n          ^^^^^^^^^^^\nError: Unbound value palindromeA\n", "min": "\nlet _ = palindromeA ([('a', 'b', 'c')], 0);;\n", "in": "let rec palindromeA (w, p) = \nif ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif ((List.length w) < (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif ((List.length w) <= (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nif ((List.nth w p) = (List.nth w (List.length w - 1 - p)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindromeA (w, p + 1)\nelse false\nelse true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = palindromeA (explode w, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = palindromeA (explode w, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin a"}, {"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b"}, {"type": "scope", "out": "Characters 8-19:\n  let _ = digitalRoot 9876;;\n          ^^^^^^^^^^^\nError: Unbound value digitalRoot\n", "min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec listReverse l = match l with\n[] -> []\n| x :: xs -> (listReverse xs) @ [x]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs"}]}
