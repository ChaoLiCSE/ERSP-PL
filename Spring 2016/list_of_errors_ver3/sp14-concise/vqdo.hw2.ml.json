{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> -1\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (-1)\n  | h::t -> if (snd h) = k then fst h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (snd h) = k then fst h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile(f,b') else b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]", "out": "Characters 197-205:\n  List.rev (helper ([],l))\n  ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l)) removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9]\n    [1; 6; 2; 4; 12; 13; 9];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "removeDuplicates\n[1;6;2;4;12;2;13;6;9]", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile(f,b') else b'", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((fun b -> (f b, (f b) = b)) , b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = \"s\"", "out": "", "min": "\nlet rec exprToString e = \"s\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (snd h) = k then fst h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\" | VarY  -> \"y\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" + exprToString y\n| Thresh (a,b,c,d) -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d", "out": "Characters 80-89:\n  | Sine x -> \"sin(pi*\" + exprToString x + \")\"\n              ^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> (\"sin(pi*\" + (exprToString x)) + \")\"\n  | Cosine x -> (\"cos(pi*\" + (exprToString x)) + \")\"\n  | Average (x,y) ->\n      (((\"((\" + (exprToString x)) + \"*\") + (exprToString y)) + \")/2)\"\n  | Times (x,y) -> ((exprToString x) + \"*\") + (exprToString y)\n  | Thresh (a,b,c,d) ->\n      (((((\"(\" + (exprToString a)) + \"<\") + (exprToString b)) +\n          (\"?\" exprToString c))\n         + \":\")\n        + (exprToString d);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" exprToString c ^ \":\" ^ exprToString d", "out": "Characters 358-361:\n  ^ \"?\" exprToString c ^ \":\" ^ exprToString d;;\n    ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (snd h) = k then fst h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" + exprToString y\n| Thresh (a,b,c,d) -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d", "out": "Characters 80-89:\n  | Sine x -> \"sin(pi*\" + exprToString x + \")\"\n              ^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> (\"sin(pi*\" + (exprToString x)) + \")\"\n  | Cosine x -> (\"cos(pi*\" + (exprToString x)) + \")\"\n  | Average (x,y) ->\n      (((\"((\" + (exprToString x)) + \"*\") + (exprToString y)) + \")/2)\"\n  | Times (x,y) -> ((exprToString x) + \"*\") + (exprToString y)\n  | Thresh (a,b,c,d) ->\n      (((((\"(\" + (exprToString a)) + \"<\") + (exprToString b)) +\n          (\"?\" exprToString c))\n         + \":\")\n        + (exprToString d);;\n", "type": "type"}, {"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d", "out": "Characters 251-265:\n  | Times (x,y) -> exprToString x + \"*\" ^ exprToString y\n                   ^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> ((exprToString x) + \"*\") ^ (exprToString y)\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d", "out": "Characters 357-360:\n  ^\"?\" exprToString c ^ \":\" ^ exprToString d;;\n   ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 96-99:\n  | Cos u ->  cos (pi *. (eval u))\n    ^^^\nError: This variant pattern is expected to have type expr\n       The constructor Cos does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval u))\n  | Cos u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 90-91:\n  | Sine u -> sin (pi *. (eval u))\n                               ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval u))\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 85-86:\n  | Sine u -> pi *. (eval u)\n                          ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval u\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 84-85:\n  | Sine u -> pi *. eval u\n                         ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 109-110:\n  | Cosine u ->  cos (pi *. (eval u))\n                                  ^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 85-86:\n  | Sine u -> pi *. (eval u)\n                          ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi * (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 73-75:\n  | Sine u -> pi * (eval u)\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi * (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 85-86:\n  | Sine u -> pi *. (eval u)\n                          ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u) * 1 * 1\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 85-86:\n  | Sine u -> pi *. (eval u) * 1 * 1\n                          ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> ((pi *. (eval u)) * 1) * 1\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 125-126:\n  | Cosine u ->  cos (pi *. (eval u))\n                                  ^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 190-191:\n  | Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2\n                                                           ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "out": "Characters 277-278:\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n                                 ^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) \nthen eval (u,x,y) \nelse eval (v,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (snd h) = k then fst h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))", "out": "Characters 194-250:\n  | 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         ((Average (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 3 ->\n         ((Times (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 4 ->\n         ((Thresh (build (rand, (depth - 1)))), (build (rand, (depth - 1))),\n           (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))", "out": "Characters 260-314:\n  | 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         ((Times (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 4 ->\n         ((Thresh (build (rand, (depth - 1)))), (build (rand, (depth - 1))),\n           (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), \n(build (rand, depth-1)), (build (rand, depth-1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n\nlet _ = fixpoint ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "wwhile fptest 0", "out": "Characters 7-13:\n  wwhile fptest 0;;\n         ^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type\n         (('a -> 'b) -> ('a -> 'b) * bool) * ('a -> 'b)\n", "min": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "wwhile fptest (0, false)", "out": "Characters 7-13:\n  wwhile fptest (0, false);;\n         ^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type\n         (('a -> 'b) -> ('a -> 'b) * bool) * ('a -> 'b)\n", "min": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest (0, false);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "wwhile (fptest, 0)", "out": "Characters 8-14:\n  wwhile (fptest, 0);;\n          ^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile (fptest, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((fun b -> (f b, (f b) != b)) , b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (fptest, 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (fptest, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((fun b -> (f b, (f b) != b)) , b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\n(*assert (-1.0 <= rv && rv <= 1.0);*)\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\n(*assert (-1.0 <= rv && rv <= 1.0);*)\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. eval (u,x,y))\n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) \nthen eval (u,x,y) \nelse eval (v,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,2) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,5) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), \n(build (rand, depth-1)), (build (rand, depth-1)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 2)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 5) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 2)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 5) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 2)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 5) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,2) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), \n(build (rand, depth-1)), (build (rand, depth-1)))", "out": "Characters 71-75:\n  if rand(0,2) = 0 then VarX\n                        ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 2)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "scope"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}, {"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,2) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,5) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), \n(build (rand, depth-1)), (build (rand, depth-1)))", "out": "Characters 71-75:\n  if rand(0,2) = 0 then VarX\n                        ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 2)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 5) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": "scope"}, {"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": "scope"}, {"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Printf.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet result = f b in\nwwhile ((fun b -> (result, result != b)) , b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let result = f b in wwhile ((fun b  -> (result, (result != b))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Halve    of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Wow      of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Halve x -> \"(\" ^ exprToString ^ \")/2\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d\n| Wow (x,y,z) -> \"sqrt(\" ^ \"abs(\" ^ exprToString x ^ \")*\" ^ \"abs(\" ^ exprToString y ^ \")*\" ^ \"abs(\" ^ exprToString z ^ \"))\"", "out": "Characters 179-191:\n  | Halve x -> \"(\" ^ exprToString ^ \")/2\"\n                     ^^^^^^^^^^^^\nError: This expression has type expr -> string\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Halve x -> \"(\" ^ (exprToString ^ \")/2\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))))\n  | Wow (x,y,z) ->\n      \"sqrt(\" ^\n        (\"abs(\" ^\n           ((exprToString x) ^\n              (\")*\" ^\n                 (\"abs(\" ^\n                    ((exprToString y) ^\n                       (\")*\" ^ (\"abs(\" ^ ((exprToString z) ^ \"))\"))))))));;\n", "type": "type"}, {"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Halve x -> \"(\" ^ exprToString x ^ \")/2\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d\n| Wow (x,y,z) -> \"sqrt(\" ^ \"abs(\" ^ exprToString x ^ \")*\" ^ \"abs(\" ^ exprToString y ^ \")*\" ^ \"abs(\" ^ exprToString z ^ \"))\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Halve x -> \"(\" ^ ((exprToString x) ^ \")/2\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))))\n  | Wow (x,y,z) ->\n      \"sqrt(\" ^\n        (\"abs(\" ^\n           ((exprToString x) ^\n              (\")*\" ^\n                 (\"abs(\" ^\n                    ((exprToString y) ^\n                       (\")*\" ^ (\"abs(\" ^ ((exprToString z) ^ \"))\"))))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildHalve(e1, e2)\t\t   = Halve(e1,e2)", "out": "Characters 34-41:\n  let buildHalve(e1, e2)\t\t   = Halve(e1,e2);;\n                                    ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildHalve (e1,e2) = Halve (e1, e2);;\n", "type": "type"}, {"in": "let buildWow(e1, e2, e3)\t   = Wow(e1, e2, e3)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildWow (e1,e2,e3) = Wow (e1, e2, e3);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildHalve(e)\t\t   = Halve(e)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildHalve e = Halve e;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. eval (u,x,y))\n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) \nthen eval (u,x,y) \nelse eval (v,x,y)\n| Halve (u) -> eval(u,x,y) /. 2.0\n| Wow (u,v,w) -> sqrt(abs(eval(u,x,y)) *. abs(eval(v,x,y)) *. abs(eval(w,x,y)))", "out": "Characters 405-418:\n  | Wow (u,v,w) -> sqrt(abs(eval(u,x,y)) *. abs(eval(v,x,y)) *. abs(eval(w,x,y)));;\n                           ^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y)\n  | Halve u -> (eval (u, x, y)) /. 2.0\n  | Wow (u,v,w) ->\n      sqrt\n        (((abs (eval (u, x, y))) *. (abs (eval (v, x, y)))) *.\n           (abs (eval (w, x, y))));;\n", "type": "type"}, {"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. eval (u,x,y))\n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) \nthen eval (u,x,y) \nelse eval (v,x,y)\n| Halve (u) -> eval(u,x,y) /. 2.0\n| Wow (u,v,w) -> sqrt(abs_float(eval(u,x,y)) *. abs_float(eval(v,x,y)) *. abs_float(eval(w,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y)\n  | Halve u -> (eval (u, x, y)) /. 2.0\n  | Wow (u,v,w) ->\n      sqrt\n        (((abs_float (eval (u, x, y))) *. (abs_float (eval (v, x, y)))) *.\n           (abs_float (eval (w, x, y))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = let result = f b in\nwwhile ((fun b -> (result, result != b)) , b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let result = f b in wwhile ((fun b  -> (result, (result != b))), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let result = f b in wwhile ((fun b  -> (result, (result != b))), b);;\n\nlet _ = fixpoint ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
