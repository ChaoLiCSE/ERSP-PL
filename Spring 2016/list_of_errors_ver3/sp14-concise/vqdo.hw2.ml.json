{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> -1\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile(f,b') else b'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 197-205:\n  List.rev (helper ([],l))\n  ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l)) removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9]\n    [1; 6; 2; 4; 12; 13; 9];;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "removeDuplicates\n[1;6;2;4;12;2;13;6;9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile(f,b') else b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun b -> (f b, (f b) = b)) , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \"s\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-89:\n  | Sine x -> \"sin(pi*\" + exprToString x + \")\"\n              ^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> (\"sin(pi*\" + (exprToString x)) + \")\"\n  | Cosine x -> (\"cos(pi*\" + (exprToString x)) + \")\"\n  | Average (x,y) ->\n      (((\"((\" + (exprToString x)) + \"*\") + (exprToString y)) + \")/2)\"\n  | Times (x,y) -> ((exprToString x) + \"*\") + (exprToString y)\n  | Thresh (a,b,c,d) ->\n      (((((\"(\" + (exprToString a)) + \"<\") + (exprToString b)) +\n          (\"?\" exprToString c))\n         + \":\")\n        + (exprToString d);;\n", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" + exprToString y\n| Thresh (a,b,c,d) -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 358-361:\n  ^ \"?\" exprToString c ^ \":\" ^ exprToString d;;\n    ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" exprToString c ^ \":\" ^ exprToString d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-89:\n  | Sine x -> \"sin(pi*\" + exprToString x + \")\"\n              ^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> (\"sin(pi*\" + (exprToString x)) + \")\"\n  | Cosine x -> (\"cos(pi*\" + (exprToString x)) + \")\"\n  | Average (x,y) ->\n      (((\"((\" + (exprToString x)) + \"*\") + (exprToString y)) + \")/2)\"\n  | Times (x,y) -> ((exprToString x) + \"*\") + (exprToString y)\n  | Thresh (a,b,c,d) ->\n      (((((\"(\" + (exprToString a)) + \"<\") + (exprToString b)) +\n          (\"?\" exprToString c))\n         + \":\")\n        + (exprToString d);;\n", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" + exprToString y\n| Thresh (a,b,c,d) -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d"}, {"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 251-265:\n  | Times (x,y) -> exprToString x + \"*\" ^ exprToString y\n                   ^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> ((exprToString x) + \"*\") ^ (exprToString y)\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 357-360:\n  ^\"?\" exprToString c ^ \":\" ^ exprToString d;;\n   ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-99:\n  | Cos u ->  cos (pi *. (eval u))\n    ^^^\nError: This variant pattern is expected to have type expr\n       The constructor Cos does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval u))\n  | Cos u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 90-91:\n  | Sine u -> sin (pi *. (eval u))\n                               ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval u))\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-86:\n  | Sine u -> pi *. (eval u)\n                          ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-85:\n  | Sine u -> pi *. eval u\n                         ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval u\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-110:\n  | Cosine u ->  cos (pi *. (eval u))\n                                  ^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-86:\n  | Sine u -> pi *. (eval u)\n                          ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  | Sine u -> pi * (eval u)\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi * (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi * (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-86:\n  | Sine u -> pi *. (eval u)\n                          ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-86:\n  | Sine u -> pi *. (eval u) * 1 * 1\n                          ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> ((pi *. (eval u)) * 1) * 1\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u) * 1 * 1\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 125-126:\n  | Cosine u ->  cos (pi *. (eval u))\n                                  ^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 190-191:\n  | Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2\n                                                           ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 277-278:\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n                                 ^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) \nthen eval (u,x,y) \nelse eval (v,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (snd h) = k then fst h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 194-250:\n  | 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         ((Average (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 3 ->\n         ((Times (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 4 ->\n         ((Thresh (build (rand, (depth - 1)))), (build (rand, (depth - 1))),\n           (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 260-314:\n  | 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         ((Times (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 4 ->\n         ((Thresh (build (rand, (depth - 1)))), (build (rand, (depth - 1))),\n           (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), \n(build (rand, depth-1)), (build (rand, depth-1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 7-13:\n  wwhile fptest 0;;\n         ^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type\n         (('a -> 'b) -> ('a -> 'b) * bool) * ('a -> 'b)\n", "min": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest 0;;\n", "in": "wwhile fptest 0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 7-13:\n  wwhile fptest (0, false);;\n         ^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type\n         (('a -> 'b) -> ('a -> 'b) * bool) * ('a -> 'b)\n", "min": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest (0, false);;\n", "in": "wwhile fptest (0, false)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 8-14:\n  wwhile (fptest, 0);;\n          ^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile (fptest, 0);;\n", "in": "wwhile (fptest, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun b -> (f b, (f b) != b)) , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint (fptest, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun b -> (f b, (f b) != b)) , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\n(*assert (-1.0 <= rv && rv <= 1.0);*)\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\n(*assert (-1.0 <= rv && rv <= 1.0);*)\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. eval (u,x,y))\n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) \nthen eval (u,x,y) \nelse eval (v,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,2) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,5) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), \n(build (rand, depth-1)), (build (rand, depth-1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,2) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), \n(build (rand, depth-1)), (build (rand, depth-1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,2) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,5) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), \n(build (rand, depth-1)), (build (rand, depth-1)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet result = f b in\nwwhile ((fun b -> (result, result != b)) , b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr1\nHint: Did you mean sampleExpr2 or sampleExpr?\nError: Unbound value sampleExpr1\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-25:\n  let _ = eval (sampleExpr1,0.5,0.2);;\n                ^^^^^^^^^^^\nError: Unbound value sampleExpr1\nHint: Did you mean sampleExpr2 or sampleExpr?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}, {"type": "", "out": "", "min": "", "in": "assoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-5:\n  0.232 mod 0.12;;\n  ^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet _ = 0.232 mod 0.12;;\n", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}, {"type": "", "out": "", "min": "", "in": "assoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Halve    of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Wow      of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Halve x -> \"(\" ^ exprToString ^ \")/2\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d\n| Wow (x,y,z) -> \"sqrt(\" ^ \"abs(\" ^ exprToString x ^ \")*\" ^ \"abs(\" ^ exprToString y ^ \")*\" ^ \"abs(\" ^ exprToString z ^ \"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Halve x -> \"(\" ^ exprToString x ^ \")/2\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d\n| Wow (x,y,z) -> \"sqrt(\" ^ \"abs(\" ^ exprToString x ^ \")*\" ^ \"abs(\" ^ exprToString y ^ \")*\" ^ \"abs(\" ^ exprToString z ^ \"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildHalve(e1, e2)\t\t   = Halve(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildHalve(e)\t\t   = Halve(e)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. eval (u,x,y))\n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) \nthen eval (u,x,y) \nelse eval (v,x,y)\n| Halve (u) -> eval(u,x,y) /. 2.0\n| Wow (u,v,w) -> sqrt(abs(eval(u,x,y)) *. abs(eval(v,x,y)) *. abs(eval(w,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. eval (u,x,y))\n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) \nthen eval (u,x,y) \nelse eval (v,x,y)\n| Halve (u) -> eval(u,x,y) /. 2.0\n| Wow (u,v,w) -> sqrt(abs_float(eval(u,x,y)) *. abs_float(eval(v,x,y)) *. abs_float(eval(w,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = let result = f b in\nwwhile ((fun b -> (result, result != b)) , b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    -> d\n| h::t  -> if (fst h) = k then snd h else assoc (d, k, t)"}]}
