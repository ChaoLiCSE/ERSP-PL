{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + sumList;;\n", "out": "Characters 57-64:\n  [] -> 0 | h::t -> h + sumList;;\n                        ^^^^^^^\nError: This expression has type int list -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + sumList;;\n", "out": "Characters 57-64:\n  [] -> 0 | h::t -> h + sumList;;\n                        ^^^^^^^\nError: This expression has type int list -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n/10 n%10 :: []", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | n -> [((digitsOfInt n) / (10 n)) % 10];;\n", "out": "Characters 70-71:\n  0 -> [] | n -> digitsOfInt n/10 n%10 :: [];;\n                                   ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n/10 :: []", "min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [(digitsOfInt n) / 10];;\n", "out": "Characters 52-65:\n  0 -> [] | n -> digitsOfInt n/10 :: [];;\n                 ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n :: []", "min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [digitsOfInt n];;\n", "out": "Characters 52-65:\n  0 -> [] | n -> digitsOfInt n :: [];;\n                 ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> [digitsOfInt n/10]", "min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [(digitsOfInt n) / 10];;\n", "out": "Characters 53-66:\n  0 -> [] | n -> [digitsOfInt n/10];;\n                  ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n%10]", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n % 10];;\n", "out": "Characters 79-80:\n  | _  -> digitsOfInt (n/10) @  [n%10];;\n                                  ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n_  -> digitsOfInt (n/10) @  [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  match n with | _ -> (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> n mod 10::digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> n mod (10 * (n/10))::digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | _ -> (n mod (10 * (n / 10))) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> n mod 10::digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | _ -> digitsOfInt (n / 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (hDigitsofInt n) =\n      ((match n with | 0 -> [] | _ -> cat (digitsOfInt (n / 10)) (n mod 10)));;\n", "out": "Characters 47-59:\n  else hDigitsofInt n = \n       ^^^^^^^^^^^^\nError: Unbound value hDigitsofInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse hDigitsofInt n", "min": "\nlet rec digitsOfInt n = if n = 0 then [0] else hDigitsofInt n;;\n", "out": "Characters 47-59:\n  else hDigitsofInt n;;\n       ^^^^^^^^^^^^\nError: Unbound value hDigitsofInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n_  -> cat (digitsOfInt (n/10)) (n mod 10)\n| 0  -> []", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  match n with | _ -> cat (digitsOfInt (n / 10)) (n mod 10) | 0 -> [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> cat (digitsOfInt (n / 10)) (n mod 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else (match n with | 0 -> [] | _ -> cat (digitsOfInt (n / 10)) (n mod 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else (match n with | 0 -> [] | _ -> cat (digitsOfInt (n / 10)) (n mod 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> cat (digitsOfInt (n / 10)) (n mod 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [0] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  match n with | 0 -> [0] | _ -> cat (digitsOfInt (n / 10)) (n mod 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> cat (digitsOfInt (n / 10)) (n mod 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse fun help n  ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (fun help  ->\n       fun n  -> match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10));;\n", "out": "Characters 47-121:\n  .....fun help n  ->\n  match n with\n  0  -> [] \n  | _  -> cat (help (n/10)) (n mod 10)..\nError: This expression should not be a function, the expected type is\nint list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse help n", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n\nelse\nadditivePersistence (sumList (digits n) )", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else additivePersistence (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "digitalRoot", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else additivePersistence (sumList (digits n));;\n\nlet _ = digitalRoot;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n mod 10\nelse\nadditivePersistence (sumList (digits n) )", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n mod 10 else additivePersistence (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n\nelse\n0 + additivePersistence (sumList (digits n) )", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else 0 + (additivePersistence (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n\nelse\n0 + additivePersistence (sumList (digits n) )", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else 0 + (additivePersistence (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n\nelse\n0 + digitalRoot (sumList (digits n) )", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else 0 + (digitalRoot (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> (cat l h)::t", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat l h) :: t;;\n", "out": "Characters 70-71:\n  | h::t -> (cat l h)::t;;\n                       ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> (cat t h)::l", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat t h) :: l;;\n", "out": "Characters 70-71:\n  | h::t -> (cat t h)::l;;\n                       ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse ((cat l h)::t)", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse ((cat l h) :: t);;\n", "out": "Characters 72-81:\n  | h::t -> listReverse ((cat l h)::t);;\n                         ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse (t::(cat l h))", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (t :: (cat l h));;\n", "out": "Characters 72-73:\n  | h::t -> listReverse (t::(cat l h));;\n                         ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse ((cat l h))", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (cat l h);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse (cat l h)", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (cat l h);;\n", "out": "Characters 72-75:\n  | h::t -> listReverse (cat l h);;\n                         ^^^\nError: Unbound value cat\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat ( listReverse l) t", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat (listReverse l) t;;\n", "out": "Characters 59-62:\n  | h::t -> cat ( listReverse l) t;;\n            ^^^\nError: Unbound value cat\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat h (listReverse (t))", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat h (listReverse t);;\n", "out": "Characters 59-62:\n  | h::t -> cat h (listReverse (t));;\n            ^^^\nError: Unbound value cat\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat l (listReverse (t) h)", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat l (listReverse t h);;\n", "out": "Characters 59-62:\n  | h::t -> cat l (listReverse (t) h);;\n            ^^^\nError: Unbound value cat\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat listReverse (t) h", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> cat listReverse t h;;\n", "out": "Characters 59-62:\n  | h::t -> cat listReverse (t) h;;\n            ^^^\nError: Unbound value cat\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat (listReverse(t)) h", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat (listReverse t) h;;\n", "out": "Characters 59-62:\n  | h::t -> cat (listReverse(t)) h;;\n            ^^^\nError: Unbound value cat\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let reverse = listReverse l", "min": "\nlet reverse = listReverse l;;\n", "out": "Characters 14-25:\n  let reverse = listReverse l;;\n                ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let reverse = listReverse l", "min": "\nlet reverse = listReverse l;;\n", "out": "Characters 14-25:\n  let reverse = listReverse l;;\n                ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let reverse = listReverse l", "min": "\nlet reverse = listReverse l;;\n", "out": "Characters 14-25:\n  let reverse = listReverse l;;\n                ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nexplode w = listReverse (explode w)", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": "Characters 32-43:\n  explode w = listReverse (explode w);;\n              ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nexplode w = listReverse (explode w)", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": "Characters 32-43:\n  explode w = listReverse (explode w);;\n              ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse help n", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat (listReverse(t)) h", "min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat (listReverse t) h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
