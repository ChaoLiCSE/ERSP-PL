{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sqsum xs = \nmatch xs with\nh::t -> (h*h) + (sqsum t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-70:\n  | h::t -> (h*h) + (sqsum t);;\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "in": "let rec sqsum xs = \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-70:\n  | h::t -> (h*h) + (sqsum t);;\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "in": "let rec sqsum xs = \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-70:\n  | h::t -> (h*h) + (sqsum t);;\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "in": "let rec sqsum xs = \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sqsum xs = \nmatch xs with\n[] -> 0\n| h::t -> (h*h) + (sqsum t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-75:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs = let f a x = a * a in let base = [] in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = (a*a) in\nlet base = [] in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = match x with\n[] -> 0\n| h::t -> a + h\nin\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-70:\n  | h::t -> (h*h) + (sqsum t);;\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "in": "let rec sqsum xs = \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)"}, {"type": "scope", "out": "Characters 52-53:\n  let base = a + 1 in\n             ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = a + 1 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = a + 1 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 52-53:\n  let base = a + 1 in\n             ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = a + 1 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = a + 1 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-99:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "min": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> h x in \nlet base = fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 97-98:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "min": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> h x in \nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 100-101:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b list) list -> 'a -> 'b list\n       but an expression was expected of type\n         ('a -> 'b list) list -> 'a -> ('a -> 'b list) list\n       Type 'b list is not compatible with type ('a -> 'b list) list \n", "min": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | h::t -> h x in\n  let base = 3 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = match a with\n[] -> []\n| h::t -> (h x) \nin\nlet base = 3 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 125-126:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "min": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> (h x) in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = match a with\n[] -> []\n| h::t -> h::[] in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun a -> a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun g b -> g b) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun a -> a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-88:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun x -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 88-91:\n  let f a x = a ^ sep ^ \" \" x in\n                        ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (\" \" x)) in\n      let base = [] in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" x in\nlet base = [] in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 146-150:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (\" \" ^ x)) in\n      let base = [] in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = [] in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value ssepConcat\nHint: Did you mean sepConcat?\nError: Unbound value ssepConcat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 23-33:\n  let stringOfList f l = ssepConcat (f l);;\n                         ^^^^^^^^^^\nError: Unbound value ssepConcat\nHint: Did you mean sepConcat?\n", "min": "\nlet stringOfList f l = ssepConcat (f l);;\n", "in": "let stringOfList f l = ssepConcat (f l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat (f l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = List.map f l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 34-47:\n  let stringOfList f l = List.map f (sepConcat l);;\n                                    ^^^^^^^^^^^^^\nError: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "in": "let stringOfList f l = List.map f (sepConcat l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-38:\n  let stringOfList f l = \"[\" ^ sepConcat ^ \";\" ^ List.map f l ^ \"]\";;\n                               ^^^^^^^^^\nError: This expression has type string -> string list -> string\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat ^ (\";\" ^ ((List.map f l) ^ \"]\")));;\n", "in": "let stringOfList f l = \"[\" ^ sepConcat ^ \";\" ^ List.map f l ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-39:\n  let stringOfList f l = \"[\" ^ (sepConcat \";\" List.map f l) ^ \"]\";;\n                                ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (sepConcat \";\" List.map f l) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 53-62:\n  then x :: (clone x n-1)\n             ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = let i = 0 in if i < n then x :: ((clone x n) - 1) else [];;\n", "in": "let rec clone x n = let i = 0 in\nif i < n\nthen x :: (clone x n-1)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-57:\n  then (clone x n-1) :: x :: []\n        ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = let i = 0 in if i < n then [(clone x n) - 1; x] else [];;\n", "in": "let rec clone x n = let i = 0 in\nif i < n\nthen (clone x n-1) :: x :: []\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = let i = 0 in\nif i < n\nthen x :: ( clone x (n-1) )\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = if List.length l1 > List.length l2\nthen true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \ntrue\nelse \nfalse"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \nclone 0 length_diff\nelse \n[-100]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \n(clone 0 length_diff)\nelse \n[-100]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \ntrue\nelse \nfalse"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = let i = 0 in\nif i < n\nthen x :: ( clone x (n-1) )\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 155-166:\n  length_diff;;\n  ^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         bool\n", "min": "\nlet padZero l1 l2 =\n  let length_diff = (List.length l1) - (List.length l2) in\n  if length_diff < 0\n  then length_diff = ((List.length l1) - (List.length l2))\n  else length_diff;;\n", "in": "let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \nlength_diff = (List.length l1 - List.length l2)\nelse \nlength_diff"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = if List.length l1 < List.length l2\nthen true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n =\nif n > 0\nthen x :: ( clone x (n-1) )\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = if List.length l1 < List.length l2\nthen\nclone 0 (List.length l2 - List.length l1)\nelse\nclone 0 (List.length l1 - List.length l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = if List.length l1 < List.length l2\nthen\nclone 0 (List.length l2 - List.length l1) :: l1\nelse\nclone 0 (List.length l1 - List.length l2) :: l2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = if List.length l1 < List.length l2\nthen\nclone 0 (List.length l2 - List.length l1) :: l1\nelse\nclone 0 (List.length l1 - List.length l2) :: l2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = if List.length l1 < List.length l2\nthen\n( List.append ( clone 0 (List.length l2 - List.length l1) ) l1, l2)\nelse\n(l1, List.append ( clone 0 (List.length l1 - List.length l2) ) l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = if List.length l1 < List.length l2\nthen\n( List.append ( clone 0 (List.length l2 - List.length l1) ) l1, l2)\nelse\n(l1, List.append ( clone 0 (List.length l1 - List.length l2) ) l2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-79:\n  then h = 0\n       ^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a list\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then h = 0 else false;;\n", "in": "let rec removeZero l =\nmatch l with\n| [] -> []\n| h :: t -> \nif h = 0\nthen h = 0\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l =\nmatch l with\n| [] -> false\n| h :: t -> \nif h = 0\nthen h = 0\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l =\nmatch l with\n| [] -> []\n| h :: t -> \nif h = 0\nthen []\nelse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l =\nmatch l with\n| [] -> []\n| h :: t -> \nif h = 0\nthen removeZero t\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x (a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun x a -> x (a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun x a -> x a) x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = ( (fun x a -> x a) x a ) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun x a -> x a) x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-95:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "min": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun a x -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  (fun x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  (fun a x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  x (a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  (x (a) ) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 128-154:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = List.rev l1 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (List.rev l1) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 116-142:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = 0 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = 0 in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 116-142:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = 0 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = 0 in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l =\nmatch l with\n| [] -> []\n| h :: t -> \nif h = 0\nthen removeZero t\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> 0\n| h::t -> (h*i)/10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-93:\n  | h::t -> ( (h*i)/10 + List.rev i t );;\n                         ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (List.rev i t);;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> 0\n| h::t -> ( (h*i)/10 + List.rev i t )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> 0\n| h::t -> ( (h*i)/10 + mulByDigit i t )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-123:\n  | h::t -> ( (h*i)/10 + mulByDigit i t ) :: (h*i mod 10) :: [];;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> [((h * i) / 10) + (mulByDigit i t); (h * i) mod 10];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> 0\n| h::t -> ( (h*i)/10 + mulByDigit i t ) :: (h*i mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-100:\n  | h::t -> ( (h*i)/10 + mulByDigit i t ) :: (h*i mod 10) :: [];;\n                         ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [((h * i) / 10) + (mulByDigit i t); (h * i) mod 10];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> ( (h*i)/10 + mulByDigit i t ) :: (h*i mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (h*i mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-89:\n  | h::t -> (mulByDigit i t) :: (h*i mod 10) :: [];;\n            ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [mulByDigit i t; (h * i) mod 10];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i t) :: (h*i mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> List.append (mulByDigit i t) [h*i mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> h*i mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (h*i mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (h*i mod 10) :: h*i/10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 89-99:\n  | h::t -> (h*i mod 10) :: h*i/10 + h;;\n                            ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((h * i) mod 10) :: (((h * i) / 10) + h);;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (h*i mod 10) :: h*i/10 + h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (h*i mod 10) :: h*i/10 + h :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (h*i mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-89:\n  | h::t -> (mulByDigit i t) (h*i mod 10) :: [];;\n            ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [(mulByDigit i t) ((h * i) mod 10)];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i t) (h*i mod 10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> List.append (mulByDigit i t) ( (h*i) :: [] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (l) with\n| []   -> []\n| h::t -> List.append (mulByDigit i t) ( (h*i) :: [] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (l) with\n| []   -> []\n| h::t -> List.append ( (h*i) :: [] ) (mulByDigit i t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n| []   -> []\n| h::t -> List.append ( (h*i) :: [] ) (mulByDigit i t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n| []   -> []\n| h::m::t -> m"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-65:\n  | h::t -> h*i;;\n            ^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::t -> h * i;;\n", "in": "let rec mulByDigit i l = \nmatch l with\n| []   -> []\n| h::t -> h*i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n| []   -> 0\n| h::t -> h*i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n| []   -> 0\n| h::m::t -> m"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n| []   -> []\n| h::m::t -> t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n| []   -> []\n| h::m::t -> m::t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n| []   -> 0\n| h::m::t -> h*i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (h*i)/10 :: ( (h*i mod 10) + m*i ) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 92-110:\n  | h::m::t -> (h*i) mod 10 :: ( (h*i)/10 ) + m*i;;\n                               ^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t -> ((h * i) mod 10) :: (((h * i) / 10) + (m * i));;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (h*i) mod 10 :: ( (h*i)/10 ) + m*i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> ( (h*i) mod 10 ) :: ( (h*i)/10 ) + m*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> ( (h*i) mod 10 ) :: ( (h*i)/10 ) + (m*i) mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-89:\n  | h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [];;\n                ^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a list -> 'b list list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      [(mulByDigit m)\n      ::\n      t;\n      ((h * i) / 10) + ((m * i) mod 10);\n      (h * i) mod 10];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-92:\n  | h::m::t -> (mulByDigit m::t) @ ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [];;\n                              ^\nError: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'b list) list\n       The type variable 'a occurs inside 'a list -> 'b list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      ((mulByDigit m) :: t) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) @ ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-92:\n  | h::m::t -> (mulByDigit m::t) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] );;\n                              ^\nError: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'b list) list\n       The type variable 'a occurs inside 'a list -> 'b list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      ((mulByDigit m) :: t) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 90-91:\n  | h::m::t -> (mulByDigit i m::t) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] );;\n                             ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      ((mulByDigit i m) :: t) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit i m::t) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit i (m::t)) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-110:\n  | h::m::t -> (mulByDigit i (m::t)) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] );;\n                                            ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | []::[] -> []\n  | h::m::t ->\n      (mulByDigit i (m :: t)) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []::[]   -> []\n| h::m::t -> (mulByDigit i (m::t)) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| _::[]   -> []\n| h::m::t -> (mulByDigit i (m::t)) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 11-36:\n  List.split (padZero [9;9] [1;0;0;2]);;\n             ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type ('a * 'b) list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.split (padZero [9; 9] [1; 0; 0; 2]);;\n", "in": "List.split (padZero [9;9] [1;0;0;2])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 171-172:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a -> int * int -> int * 'a\n       but an expression was expected of type 'a -> int * int -> 'a\n       The type variable 'a occurs inside int * 'a\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> ((h1 + h2), a) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> (h1 + h2, a)\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 168-172:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 150-176:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> h1 + h2 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 152-178:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> h1 + h2 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 172-173:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a -> int * int -> 'a * int\n       but an expression was expected of type 'a -> int * int -> 'a\n       The type variable 'a occurs inside 'a * int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (a, (h1 + h2)) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> (a, h1 + h2)\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 146-172:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> a\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 201-202:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int * int -> int * int -> int\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type int is not compatible with type int * int \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> ((v1 + h1) + v2) + h2) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> (v1+h1+v2+h2)\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 236-257:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> ((v1 + h1), (v2 + h2))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> (v1+h1, v2+h2)\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 204-205:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int * int -> int * int -> (int * int) list\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type (int * int) list is not compatible with type int * int \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> [((v1 + h1), (v2 + h2))]) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> [(v1+h1, v2+h2)]\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) ->\nmatch x with\n(h1,h2)-> ( (h1+h2)/10 :: list1, (h1+h2) mod 10 :: list2 )\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) ->\nmatch x with\n(h1,h2)-> \nmatch list1 with\nl1h::l2t -> ( (h1+h2)/10 :: list1, (l1h + (h1+h2) mod 10) :: list2 )\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) ->\nmatch x with\n(h1,h2)-> \nmatch list1 with\nl1h::l2t -> ( (h1+h2)/10 :: list1, (l1h + (h1+h2) mod 10) :: list2 )\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> (list1,list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 181-182:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (list1,list2) -> list1 in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> list1\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> (list1, list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> match list1 with\n[] -> ([], [])\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-111:\n  [] -> ([], [])\n  ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) -> (match (list1, list2) with | [] -> ([], [])) in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> match (list1, list2) with\n[] -> ([], [])\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> ([],[])\n| (list1, list2) -> (list1, list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> ([],[])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> ([],[])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 164-169:\n  | (list1, list2) -> (list1, list2)\n                       ^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> (list1, list2)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n(h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n| (list1, list2) -> (list1, list2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n(h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 103-110:\n  | (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n    ^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | [] -> a\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> ([1], [1])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| [] -> a\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-117:\n  | (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n    ^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | [] -> ([], [])\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> ([1], [1])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| [] -> ([], [])\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 121-123:\n  | (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n                 ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | ([],[]) -> a\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| ([],[]) -> a\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list1, list2) -> ([1], [1])\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list1, list2) -> a\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list1, list2) -> (list1, list2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2::lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> (lt1, lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 119-121:\n  | (h1,h2) -> ((h1+h2+lh1)/10 :: lt1, (h1+h2+lh1) mod 10 :: lt2)\n                 ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (((((h1 + h2) + lh1) / 10) :: lt1),\n                 ((((h1 + h2) + lh1) mod 10) :: lt2))\n           | ([],[]) ->\n               (match x with\n                | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10]))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> match x with\n| (h1,h2) -> ((h1+h2+lh1)/10 :: lt1, (h1+h2+lh1) mod 10 :: lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 211-218:\n  | ([],[]) -> match x with\n    ^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (match h1 with\n                | x::y ->\n                    (match h2 with\n                     | a::b ->\n                         (((((x + a) + lh1) / 10) :: lt1),\n                           ((((x + a) + lh1) mod 10) :: lt2))\n                     | ([],[]) ->\n                         (match x with\n                          | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10]))))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> match x with\n| (h1,h2) -> match h1 with\nx::y -> match h2 with \na::b -> ((x+a+lh1)/10 :: lt1, (x+a+lh1) mod 10 :: lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 338-353:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (match h1 with\n                | x::y ->\n                    (match h2 with\n                     | a::b ->\n                         (((((x + a) + lh1) / 10) :: lt1),\n                           ((((x + a) + lh1) mod 10) :: lt2))))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> match x with\n| (h1,h2) -> match h1 with\nx::y -> match h2 with \na::b -> ((x+a+lh1)/10 :: lt1, (x+a+lh1) mod 10 :: lt2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 181-182:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list -> 'a * 'a -> 'a list * 'a list\n       but an expression was expected of type 'a list -> 'a * 'a -> 'a list\n       Type 'a list * 'a list is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (v1,v2) -> ((v1 :: a), (v2 :: a)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> (v1::a, v2::a)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 188-189:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list -> 'a * 'a -> 'a list * 'a list\n       but an expression was expected of type 'a list -> 'a * 'a -> 'a list\n       Type 'a list * 'a list is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (v1,v2) -> ((v1 :: a), (v2 :: a)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> ( ( v1::a), (v2::a) )\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(h1::t1, h2::t2) -> (v1 :: h1::t1, v2::h2::t2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-109:\n  ([], []) -> (v1 :: a, v2::a)\n                     ^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) -> (match a with | ([],[]) -> ((v1 :: a), (v2 :: a))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n([], []) -> (v1 :: a, v2::a)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> (v1 :: list1, v2::list2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 281-296:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               ((List.append list1 v1), (List.append list2 v2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> (List.append list1 v1, List.append list2 v2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 287-302:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               ((List.append list1 v1), (List.append list2 v2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> ( (List.append list1 v1), (List.append list2 v2) )\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 259-274:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with | (list1,list2) -> ((list1 @ v1), (list2 @ v2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> ( list1@v1, list2@v2 )\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> ( v1::list1, v2::list2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> (list1, v2 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> (list1, (v1+v2) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )\n| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )\n| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 307-312:\n  let args = List.rev (List.combine l1 l2) :: (0,0) in\n                                              ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = (List.rev (List.combine l1 l2)) :: (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )\n| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.rev (List.combine l1 l2) :: (0,0) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 287-295:\n  let args = List.append (List.rev (List.combine l1 l2)  (0,0) ) in\n                          ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2) (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )\n| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.append (List.rev (List.combine l1 l2)  (0,0) ) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 319-324:\n  let args = List.append (List.rev (List.combine l1 l2))  (0,0) in\n                                                          ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )\n| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.append (List.rev (List.combine l1 l2))  (0,0) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )\n| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )\n| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in\nlet base = ([], []) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )\n| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in\nlet base = ([], []) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> h*i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-97:\n  | h::t -> mulByDigit i (List.rev l) ::  h*i :: [];;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [mulByDigit i (List.rev l); h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> mulByDigit i (List.rev l) ::  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> mulByDigit i (List.rev l) @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> mulByDigit i (List.rev t) @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 104-105:\n  | h::t -> (mulByDigit i (List.rev t) ) :: 0 @  h*i :: [];;\n                                            ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) :: 0) @ [h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) ) :: 0 @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 104-105:\n  | h::t -> (mulByDigit i (List.rev t) ) :: 0 @  h*i :: [];;\n                                            ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) :: 0) @ [h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) ) :: 0 @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 102-103:\n  | h::t -> (mulByDigit i (List.rev t) :: 0 ) @  h*i :: [];;\n                                          ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) :: 0) @ [h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) :: 0 ) @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 101-102:\n  | h::t -> (mulByDigit i (List.rev t) @ 0)  @  h*i :: [];;\n                                         ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) @ 0) @ [h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) @ 0)  @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) @ [0])  @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-98:\n  | h::t -> (mulByDigit i (List.rev t) *10)  @  h*i :: [];;\n             ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) @ [h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) *10)  @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> mulByDigit i (List.rev t)  @  h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-98:\n  | h::t -> (mulByDigit i (List.rev t) * 10 )  h*i;;\n             ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> (((mulByDigit i (List.rev t)) * 10) h) * i;;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) * 10 )  h*i"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-104:\n  | h::t -> (mulByDigit i (List.rev t) * 10 )  h*i;;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (((mulByDigit i (List.rev t)) * 10) h) * i;;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> (mulByDigit i (List.rev t) * 10 )  h*i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> (mulByDigit i (List.rev t) * 10 ) + h*i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-132:\n  | h::t -> (mulByDigit i (List.rev (List.map (fun x -> x*10 :: []) t) ) ) @ h*i :: [];;\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> [x * 10]) t))) @ [h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev (List.map (fun x -> x*10 :: []) t) ) ) @ h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> (mulByDigit i (List.rev t) * 10 ) + h*i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 233-242:\n  | h1::t1 -> helper t1 :: h1 mod 10 :: []\n              ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper lst =\n             match lst with | [] -> [] | h1::t1 -> [helper t1; h1 mod 10] in\n           helper [h]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper lst = match lst with\n| [] -> []\n| h1::t1 -> helper t1 :: h1 mod 10 :: []\nin helper [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper lst = match lst with\n| [] -> []\n| h1::t1 -> helper t1 @ h1 mod 10 :: []\nin helper [h]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 193-206:\n  | h::t -> let rec helper v = (helper v/10) @ h1 mod 10 :: []\n                               ^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper v = ((helper v) / 10) @ [h1 mod 10] in helper h);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper v = (helper v/10) @ h1 mod 10 :: []\nin helper h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 194-202:\n  | h::t -> let rec helper v = (helper v/10) :: h1 mod 10 :: []\n                                ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> let rec helper v = [(helper v) / 10; h1 mod 10] in helper h);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper v = (helper v/10) :: h1 mod 10 :: []\nin helper h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 193-206:\n  | h::t -> let rec helper v = helper (v/10) :: h1 mod 10 :: []\n                               ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> let rec helper v = [helper (v / 10); h1 mod 10] in helper h);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper v = helper (v/10) :: h1 mod 10 :: []\nin helper h"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 209-211:\n  | h::t -> let rec helper v = helper (v/10) @ h1 mod 10 :: []\n                                               ^^\nError: Unbound value h1\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper v = (helper (v / 10)) @ [h1 mod 10] in helper h);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper v = helper (v/10) @ h1 mod 10 :: []\nin helper h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper v = helper (v/10) @ v mod 10 :: []\nin helper h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 262-263:\n  in helper h;;\n            ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper h);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper acc v = if v = 0 then acc else helper (v mod 10 :: acc) (v/10)\nin helper h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper acc v = if v = 0 then acc else helper (v mod 10 :: acc) (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 174-175:\n  | h::t -> h;;\n            ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 161-162:\n  | [] -> 0\n          ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> 0\n       | h::t -> h);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> 0\n| h::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if v = 0 then acc else helper (v mod 10 :: acc) (v/10)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = v mod 10 :: acc\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = \nif v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 209-221:\n  in helper [] h1;;\n     ^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h1::t1 -> let rec helper acc v = v = 0 in helper [] h1);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = v = 0\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if v = 0 then [1] else [0] \n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = [v]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if v = 0 then [1] else [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if v != 0 then [1] else [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if v > 0 then [1] else [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if (v < 0) then [1] else [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if (v = 0) then [1] else [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if (v > 0) then [1] else [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = [v]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-137:\n  | h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> false\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h1::t1 -> let rec helper acc v = [v] = [0] in helper [] h1);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> false\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = [v] = [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> let rec helper acc v = \nif v = 0 \nthen \n0 :: acc\nelse \nhelper ((v mod 10) :: acc) (v/10)\nin (mulByDigit i (List.rev t) * 10 ) + h*i"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 170-203:\n  in helper (mulByDigit i (List.rev t) * 10 ) + h*i;;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      (helper ((mulByDigit i (List.rev t)) * 10)) + (h * i);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> let rec helper acc v = \nif v = 0 \nthen \n0 :: acc\nelse \nhelper ((v mod 10) :: acc) (v/10)\nin helper (mulByDigit i (List.rev t) * 10 ) + h*i"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 221-232:\n  in helper [] n;;\n     ^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with\n       | n ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] n);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> match (mulByDigit i (List.rev t) * 10 ) + h*i with\n| n -> let rec helper acc v = \nif v = 0 \nthen \n0 :: acc\nelse \nhelper ((v mod 10) :: acc) (v/10)\nin helper [] n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-104:\n  | h::t -> match (mulByDigit i (List.rev t) * 10 ) + h*i with\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with\n       | n ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] n);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev t) * 10 ) + h*i with\n| n -> let rec helper acc v = \nif v = 0 \nthen \n0 :: acc\nelse \nhelper ((v mod 10) :: acc) (v/10)\nin helper [] n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-105:\n  | h::t -> match [(mulByDigit i (List.rev t) * 10 ) + h*i] with\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match [((mulByDigit i (List.rev t)) * 10) + (h * i)] with\n       | x::y ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] x);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match [(mulByDigit i (List.rev t) * 10 ) + h*i] with\n| x::y -> let rec helper acc v = \nif v = 0 \nthen \n0 :: acc\nelse \nhelper ((v mod 10) :: acc) (v/10)\nin helper [] x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-105:\n  | h::t -> match ((mulByDigit i (List.rev t) * 10 ) + h*i) :: [] with\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match [((mulByDigit i (List.rev t)) * 10) + (h * i)] with\n       | x::y ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] x);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match ((mulByDigit i (List.rev t) * 10 ) + h*i) :: [] with\n| x::y -> let rec helper acc v = \nif v = 0 \nthen \n0 :: acc\nelse \nhelper ((v mod 10) :: acc) (v/10)\nin helper [] x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-100:\n  | h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) :: [];;\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [((mulByDigit i (List.rev t)) * 10) + (h * i)];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-100:\n  | h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i );;\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-100:\n  | h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i );;\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 112-122:\n  helper (v mod 10)::acc (v/10)\n         ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else (helper (v mod 10)) :: (acc (v / 10)) in\n      helper [] h;;\n", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper (v mod 10)::acc (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin helper [] (h*i)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin helper [] (h*i) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin mulByDigit i t @ (helper [] (h*i) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 256-257:\n  | h::t -> h;;\n            ^\nError: This expression has type int list\n       but an expression was expected of type int list list\n", "min": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| h::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| h::t -> [h]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 282-297:\n  adder ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []);;\n                                                                   ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        [helper [] (h * i)];;\n", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin let rec adder x = match x with\n[] -> []\n| h::t -> bigAdd h (adder t)\nin \nadder ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 217-303:\n  adder ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) @ []);;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        ((helper [] (h * i)) @ []);;\n", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin let rec adder x = match x with\n[] -> []\n| h::t -> bigAdd h (adder t)\nin \nadder ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) @ [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) @ [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 293-308:\n  adder ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []);;\n                                                                   ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        [helper [] (h * i)];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> bigAdd h (adder t)\nin \nadder ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 228-319:\n  adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) );;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 55-58:\n  [] -> int list []\n        ^^^\nError: Unbound value int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> int list []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x =\n        match x with | [] -> int list [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> int list []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> int list []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 228-319:\n  adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) );;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 213-304:\n  adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) );;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> h in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> h\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> [h]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 210-228:\n  | h::t -> [bigAdd h (adder t)]\n             ^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x =\n        match x with | [] -> [] | h::t -> [bigAdd h (adder t)] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> [bigAdd h (adder t)]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 236-327:\n  adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) );;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 210-232:\n  | h::t -> [( bigAdd h (adder t) )]\n             ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x =\n        match x with | [] -> [] | h::t -> [bigAdd h (adder t)] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> [( bigAdd h (adder t) )]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 236-327:\n  adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) );;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n[adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 349-350:\n  h::t -> h;;\n          ^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (match [adder\n                ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                   [helper [] (h * i)])]\n       with\n       | h::t -> h);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \nmatch [adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )] with\nh::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n[adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 305-320:\n  adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) );;\n                                                                     ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> [0]\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [0] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> [0]\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> [0]\n| h::t -> ( bigAdd h (adder t) )\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 244-328:\n  adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) @ []) );;\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> [0]\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [0] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           ((helper [] (h * i)) @ []));;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> [0]\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> [0]\n| h::t -> ( bigAdd h (adder t) )\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) @ []) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 236-327:\n  adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) );;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) @ [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) ) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 236-326:\n  adder (( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) ) :: []);;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \nadder (( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) ) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 236-318:\n  adder ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) );;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        (helper [] (h * i));;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \nadder ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 4-5:\n  if h = 0\n     ^\nError: Unbound value h\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = if h = 0 then removeZero t;;\n", "in": "\nif h = 0\nthen removeZero t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-86:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int\n       Type int is not compatible with type int -> int \n", "min": "\nlet f a b a = a * b;;\n\nlet pipe fs =\n  let f a x = f (x a) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = f(x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 92-96:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "min": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a x -> (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-88:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun x -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 355-356:\n  adder (h::t);;\n         ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (h :: t));;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 272-273:\n  | x::y -> x;;\n            ^\nError: This expression has type int list\n       but an expression was expected of type int list list\n", "min": "\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y -> x);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 358-359:\n  adder (h::t);;\n         ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (h :: t));;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 351-363:\n  adder (x::y);;\n  ^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (x::y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \n[adder (x::y)]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-113:\n  | h::t -> ((List.rev (List.map (fun x->x*10) t ) ) ) + h*i;;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (List.rev (List.map (fun x  -> x * 10) t)) + (h * i);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ((List.rev (List.map (fun x->x*10) t ) ) ) + h*i"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-126:\n  | h::t -> ((List.rev (List.map (fun x->x*10) t ) ) ) @ h*i  :: [];;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (List.rev (List.map (fun x  -> x * 10) t)) @ [h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ((List.rev (List.map (fun x->x*10) t ) ) ) @ h*i  :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-128:\n  | h::t -> ((List.rev (List.map (fun x->x*10) t ) ) ) @ (h*i  :: []);;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (List.rev (List.map (fun x  -> x * 10) t)) @ [h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ((List.rev (List.map (fun x->x*10) t ) ) ) @ (h*i  :: [])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-139:\n  | h::t -> ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) :: h*i :: [];;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> [mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)); h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) :: h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-127:\n  | h::t -> ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) :: h*i :: [];;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)); h * i];;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) :: h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-147:\n  | h::t -> sqsum (( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ h*i :: []);;\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      sqsum\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> sqsum (( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ h*i :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> [sqsum (( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ h*i :: [])]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-106:\n  | h::t -> match ( (mulByDigit i (List.rev t) * 10 ) + h*i ) with\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with | n -> [n]);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match ( (mulByDigit i (List.rev t) * 10 ) + h*i ) with\n| n -> [n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "sqsum [81000;8100;810;81]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 352-353:\n  adder (x::y);;\n         ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               (helper [] (h * i))\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i)) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (x::y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nhelper (v mod 10 :: acc) (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \n[1]\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nhelper ( (v mod 10) :: acc) (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 153-154:\n  | h::t -> h;;\n            ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> h :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 221-223:\n  in helper [] h;;\n            ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v = if v = 0 then acc else v mod 10 in\n           helper [] h);;\n", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: []\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: [0]\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \n[1]\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \n(v mod 10) :: acc\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-8:\n  List.map (fun x -> x*10 ) [1;2;3]\n  ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet _ = (List.map (fun x  -> x * 10) [1; 2; 3] 8100) mod 10;;\n", "in": "List.map (fun x -> x*10 ) [1;2;3]\n\n(* match (List.rev l) with\n| []   -> 0\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) *)\n\n(* let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (x::y)\n*)\n\n8100 mod 10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \n(v mod 10) :: acc\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \n(0) :: acc\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \n[1]\nelse \n(0) :: acc\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-160:\n  in helper [] mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: [];;\n     ^^^^^^\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        match v with | [] -> [] | h::t -> if h = 0 then acc else 0 :: acc in\n      (helper [] mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [h * i];;\n", "in": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> \nlet rec helper acc v = \nmatch v with\n[] -> []\n| h::t -> if h = 0\nthen \nacc\nelse \n(0) :: acc\nin helper [] mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 351-363:\n  adder (x::y);;\n  ^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (x::y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch l with\n| [] -> []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch l with\n| [] -> []\n| h::t -> [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> h::t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> h :: []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 172-173:\n  | h::t -> if v = 0\n               ^\nError: Unbound value v\n", "min": "\nlet rec helper acc v = if v = 0 then acc else helper [v mod 10] (v / 10);;\n\nlet _ =\n  let rec mulByDigit i l =\n    match List.rev l with\n    | [] -> []\n    | h::t ->\n        (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                 [h * i]\n         with\n         | [] -> []\n         | h::t -> if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10)) in\n  helper [] h;;\n", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> if v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t ->  h :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 252-261:\n  in helper [];;\n     ^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper []);;\n", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t ->  let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t ->  let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin (helper [] h)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> (helper [] h)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> (helper [] 9000)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> (helper [] 9000)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] 9000"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 229-232:\n  List.fold_left f base lst;;\n                        ^^^\nError: Unbound value lst\nHint: Did you mean fst, lsl or lsr?\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in let base = 0 in List.fold_left f base lst);;\n", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base lst"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 207-235:\n  List.fold_left f base (h::t);;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in\n           let base = 0 in List.fold_left f base (h :: t));;\n", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base (h::t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\n[List.fold_left f base (h::t)]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> a :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n(v mod 10 :: acc)\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n( (v mod 10) mod 10 ) :: (v mod 10 :: acc)\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n( (v/10) mod 10 ) :: (v mod 10 :: acc)\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 338-355:\n  ( (v/10) mod 10 ) :: (v mod 10 :: acc) :: acc\n                       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in\n           let base = 0 in\n           (match [List.fold_left f base (h :: t)] with\n            | [] -> []\n            | a::b ->\n                let rec helper acc v =\n                  if v = 0\n                  then acc\n                  else ((v / 10) mod 10) :: ((v mod 10) :: acc) :: acc in\n                helper [] a));;\n", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n( (v/10) mod 10 ) :: (v mod 10 :: acc) :: acc\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n( (v/10) mod 10 ) :: (v mod 10) :: acc\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n( (v/10) mod 10 ) :: (v mod 10) :: acc\nin helper [] 11106"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n( (v/10) mod 10 ) :: (v mod 10) :: acc\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 162-172:\n  helper (v mod 10) :: acc (v/10)\n         ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let f a x = a + x in\n      let base = 0 in\n      let rec helper acc v =\n        if v = 0 then acc else (helper (v mod 10)) :: (acc (v / 10)) in\n      helper []\n        [List.fold_left f base\n           ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n              [h * i])];;\n", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10) :: acc (v/10)\nin helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 200-294:\n  in helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])]);;\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let f a x = a + x in\n      let base = 0 in\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper []\n        [List.fold_left f base\n           ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n              [h * i])];;\n", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] (List.hd [List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n(v mod 10) :: acc\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n( (v/10) mod 10) :: (v mod 10) :: acc\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n(v mod 10) :: ( (v/10) mod 10) :: []\nin helper [] a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| c::d -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n(c mod 10) :: ( (c/10) mod 10) :: []\nin helper [] c"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| c::d -> let rec helper acc v = \nc :: []\nin helper [] c"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| c::d -> let rec helper acc v = \nv:: []\nin helper [] c"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| c::d -> let rec helper acc v = \nv mod 10 :: []\nin helper [] c"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| c::d -> let rec helper acc v = \n(v/10) :: v mod 10 :: v :: []\nin helper [] c"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 95-99:\n  match [List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])] with\n                          ^^^^\nError: Unbound value base\n", "min": "\nlet f a b a = a * b;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match [List.fold_left f base\n                ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                   [h * i])]\n       with\n       | [] -> []\n       | c::d ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] c);;\n", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nmatch [List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])] with\n[] -> [] \n| c::d -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] c"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 \nin match [List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])] with\n[] -> [] \n| c::d -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] c"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] (h*i)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-160:\n  in bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) helper [] (h*i);;\n     ^^^^^^\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) helper\n        [] (h * i);;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) helper [] (h*i)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-217:\n  in bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) ));;\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)));;\n", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) ))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (c, bigAdd d (mulByDigit k v)) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (c, bigAdd d (mulByDigit k v)) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 261-265:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int * 'a) list\n       but an expression was expected of type ('b list * int list) list\n       Type int is not compatible with type 'b list \n", "min": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = x in\nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 259-260:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = (a, x) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = (a, x) in\nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 267-268:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a -> 'b -> 'a list * 'b list\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a list * 'b list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = ([a], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = (a::[], x::[]) in\nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (c, bigAdd d (mulByDigit k v)) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 288-292:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int * 'a) list\n       but an expression was expected of type ('b list * int list) list\n       Type int is not compatible with type 'b list \n", "min": "\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> (k, v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> (k,v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "bigAdd [0] [9;9;9;9;9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "bigAdd (bigAdd [0] [9;9;9;9;9]) [1]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 271-275:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int * 'a) list\n       but an expression was expected of type int list\n       Type int * 'a is not compatible with type int \n", "min": "\nlet bigMul l1 l2 =\n  let f a x = ([0], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = ([0], [x]) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 262-266:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int * 'a) list\n       but an expression was expected of type ('b list * int list) list\n       Type int is not compatible with type 'b list \n", "min": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = x in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> ([k],v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> (v,[k]) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, k :: d) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, k :: d) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (s, res) = List.fold_left f base args in\n(s,res)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, k :: d) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 331-335:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int * 'a) list\n       but an expression was expected of type (int list * 'b) list\n       Type int is not compatible with type int list \n", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, (bigMul k v) :: d) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 326-330:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int * 'a) list\n       but an expression was expected of type (int list * 'b) list\n       Type int is not compatible with type int list \n", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, (bigMul k v)) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, k :: d) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 327-331:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int * 'a) list\n       but an expression was expected of type (int list * 'b) list\n       Type int is not compatible with type int list \n", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, (bigMul k v) ) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, (mulByDigit k v) ) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, (mulByDigit k v) ) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (r, res) = List.fold_left f base args in\n(r, res)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (d, (mulByDigit k v) ) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (r, res) = List.fold_left f base args in\n(r, res)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (d :: c, (mulByDigit k v) ) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (r, res) = List.fold_left f base args in\n(r, res)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "mulByDigit 90000 [9;9;9;9;9;]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\nh::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> h*i :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] (h*i)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::m::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (helper [] (m*i)) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::m::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (helper [] ((m*10)*i)) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let somef i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let somef i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (somef i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::m::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (helper [] ((m*10)*i)) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::m::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (helper [] ((m*10)*i)) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let mulBuDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "mulByDigit 90000 [9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let mulBuDigit i l = match (List.rev l) with\n| [] -> [0]\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "bigAdd [] [100]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let mulBuDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let mulBuDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let mulBuDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "mulByDigit 90000 [9;9;9;9;9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "mulByDigit 90000 [9;9;9;9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "mulByDigit 90000 [9;9;9]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::m::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (helper [] ((m*10)*i)) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd [0] (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> \nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 8-17:\n  [1,0] @ clone 0 1;;\n          ^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = [(1, 0)] @ (clone 0 1);;\n", "in": "[1,0] @ clone 0 1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 8-19:\n  [1,0] @ (clone 0 1);;\n          ^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = [(1, 0)] @ (clone 0 1);;\n", "in": "[1,0] @ (clone 0 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "[1;0] @ (clone 0 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "[1;0] @ (clone 0 3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 112-131:\n  (numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes)) in\n                                                                     ^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1),\n          (bigAdd ((mulByDigit x l1) @ ((clone 0 numZeroes) prevRes)))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes)) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 92-135:\n  (numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) prevRes)) in\n                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1),\n          (bigAdd (((mulByDigit x l1) @ (clone 0 numZeroes)) prevRes))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) prevRes)) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 92-135:\n  (numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) (prevRes) )) in\n                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1),\n          (bigAdd (((mulByDigit x l1) @ (clone 0 numZeroes)) prevRes))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) (prevRes) )) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ ( sepConcat \"; \" (List.map f l) ) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 98-101:\n  (numZeroes, prevRes) -> ( numZeroes+1, bigAdd (i*x @ (clone 0 numZeroes)) (prevRes) ) in\n                                                 ^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1), (bigAdd ((i * x) @ (clone 0 numZeroes)) prevRes)) in\n  let base = (0, []) in let (_,res) = List.fold f base (List.rev l) in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd (i*x @ (clone 0 numZeroes)) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 99-104:\n  (numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( (i*x) @ (clone 0 numZeroes)) (prevRes) ) in\n                                                  ^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1), (bigAdd ((i * x) @ (clone 0 numZeroes)) prevRes)) in\n  let base = (0, []) in let (_,res) = List.fold f base (List.rev l) in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( (i*x) @ (clone 0 numZeroes)) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value h\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 102-103:\n  (numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*h] @ (clone 0 numZeroes) ) (prevRes) ) in\n                                                     ^\nError: Unbound value h\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1), (bigAdd ([i * h] @ (clone 0 numZeroes)) prevRes)) in\n  let base = (0, []) in let (_,res) = List.fold f base (List.rev l) in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*h] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value List.fold\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 180-189:\n  let (_,res) = List.fold f base (List.rev l) in\n                ^^^^^^^^^\nError: Unbound value List.fold\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1), (bigAdd ([i * x] @ (clone 0 numZeroes)) prevRes)) in\n  let base = (0, []) in let (_,res) = List.fold f base (List.rev l) in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold_left f base (List.rev l) in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
