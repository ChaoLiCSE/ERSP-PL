{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsofInt n/10s", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsofInt n) / (10 s));;\n", "out": "Characters 57-68:\n  let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsofInt n/10s;;\n                                                           ^^^^^^^^^^^\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10s", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / (10 s));;\n", "out": "Characters 57-70:\n  let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10s;;\n                                                           ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n", "out": "Characters 57-70:\n  let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10;;\n                                                           ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = if n <= 0 then [] else digitsOfInt (n/10):: n mod 10", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 47-65:\n  let rec digitsOfInt n = if n <= 0 then [] else digitsOfInt (n/10):: n mod 10;;\n                                                 ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10 @ digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ (digitsOfInt (n / 10));;\n", "out": "Characters 47-55:\n  let rec digitsOfInt n = if n <= 0 then [] else n mod 10 @ digitsOfInt (n/10);;\n                                                 ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n []", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else digitsHelper n [];;\n", "out": "Characters 47-59:\n  let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n [];;\n                                                 ^^^^^^^^^^^^\nError: Unbound value digitsHelper\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n []", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else digitsHelper n [];;\n", "out": "Characters 47-59:\n  let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n [];;\n                                                 ^^^^^^^^^^^^\nError: Unbound value digitsHelper\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l\nin\nif n<=0 then [] else digitsHelper n []", "min": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (((n / 10) n) mod 10) :: l in\n  if n <= 0 then [] else digitsHelper n [];;\n", "out": "Characters 69-75:\n  let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l\n                                                  ^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "min": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n", "out": "Characters 69-75:\n  let rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)\n                                                  ^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "min": "\nlet digitsOfInt n =\n  let rec digitsHelper n l =\n    if n = 0 then l else digitsHelper (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "min": "\nlet digitsOfInt n =\n  let rec digitsHelper n l =\n    if n = 0 then l else digitsHelper (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList n)\nin\ndigHelper n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let rec digHelper n = if n < 10 then n else digHelper (sumList n) in\n  digHelper n;;\n", "out": "Characters 88-89:\n  let rec digHelper n = if n < 10 then n else digHelper (sumList n)\n                                                                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))\nin\ndigHelper n", "min": "\nlet digitsOfInt n =\n  let rec digitsHelper n l =\n    if n = 0 then l else digitsHelper (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let rec digHelper n =\n    if n < 10 then n else digHelper (sumList (digitsOfInt n)) in\n  digHelper n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t h::l2\nin\nlistHelper l []", "min": "\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> (listHelper t h) :: l2 in\n  listHelper l [];;\n", "out": "Characters 86-100:\n  | h::t -> listHelper t h::l2\n            ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t (h::l2)\nin\nlistHelper l []", "min": "\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let palindrome w = if listReverse explode w = explode w then true else false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "out": "Characters 22-33:\n  let palindrome w = if listReverse explode w = explode w then true else false;;\n                        ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = if (listReverse (explode w)) = explode w then true else false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = function\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = function | [] -> 0 | h::t -> h + (sumList t);;\n", "out": "Characters 54-63:\n  | h::t -> h + sumList t;;\n                ^^^^^^^^^\nError: This expression has type int list -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
