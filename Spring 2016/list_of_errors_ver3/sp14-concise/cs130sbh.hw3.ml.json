{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x**2 in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 31-32:\n  let f a x = x**2 in\n                 ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs = let f a x = x ** 2 in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 71-75:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs =\n  let f a x = x ** 2.0 in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x**.2.0 in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 29-32:\n  let f a x = x**.2.0 in\n               ^^^\nError: Unbound value **.\nHint: Did you mean *. or **?\n", "min": "\nlet sqsum xs =\n  let f a x = x **. 2.0 in let base = 0 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0.0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = x ** 2.0 in let base = 0.0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = base + x in\nlet base = x*x in\nList.fold_left f base xs", "out": "Characters 28-32:\n  let f a x = base + x in\n              ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = base + x in let base = x * x in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = z in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = z in\n             ^\nError: Unbound value z\n", "min": "\nlet pipe fs = let f a x = x a in let base = z in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x  in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun c->c in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x c = c in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x-> x a in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "Characters 80-81:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "min": "\nlet pipe fs = let f a x x = x a in let base b = b in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun c->x c in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun c->x a c in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x c = x a c in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun c->x a c in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x c = x a c in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun c->x (a c) in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x c = x (a c) in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun c->x (a c) in\nlet base = fun b->b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x c = x (a c) in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map sepConcat \";\" l", "out": "Characters 23-31:\n  let stringOfList f l = List.map sepConcat \";\" l;;\n                         ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \";\" l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0\nthen []\nelse [x] :: clone x (n-1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0\nthen []\nelse x :: clone x (n-1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (lenth1 > length2)\nthen List.append (clone 0 (length1 - length2)), length2\nelse List.append (clone 0 (length2 - length1)), length1", "out": "Characters 89-95:\n  if (lenth1 > length2)\n      ^^^^^^\nError: Unbound value lenth1\nHint: Did you mean length1?\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if lenth1 > length2\n  then ((List.append (clone 0 (length1 - length2))), length2)\n  else ((List.append (clone 0 (length2 - length1))), length1);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen List.append (clone 0 (length1 - length2)), length2\nelse List.append (clone 0 (length2 - length1)), length1", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then ((List.append (clone 0 (length1 - length2))), length2)\n  else ((List.append (clone 0 (length2 - length1))), length1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0\nthen []\nelse x :: clone x (n-1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen List.append (clone 0 (length1 - length2)), l2\nelse List.append (clone 0 (length2 - length1)), l1", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then ((List.append (clone 0 (length1 - length2))), l2)\n  else ((List.append (clone 0 (length2 - length1))), l1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen List.append (clone 0 (length1 - length2)), l2\nelse List.append (clone 0 (length2 - length1)), l1", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then ((List.append (clone 0 (length1 - length2))), l2)\n  else ((List.append (clone 0 (length2 - length1))), l1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen List.append (clone 0 (length1 - length2)) l2\nelse List.append (clone 0 (length2 - length1)) l1", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then List.append (clone 0 (length1 - length2)) l2\n  else List.append (clone 0 (length2 - length1)) l1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen l1, List.append (clone 0 (length1 - length2)) l2\nelse l2, List.append (clone 0 (length2 - length1)) l1", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else (l2, (List.append (clone 0 (length2 - length1)) l1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen List.append (clone 0 (length1 - length2)) l2, l1\nelse l2, List.append (clone 0 (length2 - length1)) l1", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then ((List.append (clone 0 (length1 - length2)) l2), l1)\n  else (l2, (List.append (clone 0 (length2 - length1)) l1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen l1, List.append (clone 0 (length1 - length2)) l2\nelse List.append (clone 0 (length2 - length1)) l1, l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else ((List.append (clone 0 (length2 - length1)) l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> \n[]\n| h::t -> \nif h = 0\nthen removeZero t\nelse l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
