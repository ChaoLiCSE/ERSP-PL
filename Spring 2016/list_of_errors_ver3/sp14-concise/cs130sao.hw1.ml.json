{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList xs = function [] -> int", "min": "\nlet rec sumList xs = function | [] -> int;;\n", "out": "Characters 36-39:\n  let rec sumList xs = function [] -> int;;\n                                      ^^^\nError: Unbound value int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + t;;\n", "out": "Characters 56-57:\n  | h::t -> h + t;;\n                ^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t in xs", "min": "\nlet _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;\n", "out": "Characters 56-57:\n  | h::t -> h + t in xs;;\n                ^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nList.fold_left (+) xs", "min": "\nlet rec sumList xs = List.fold_left (+) xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nList.fold_left (+) xs", "min": "\nlet rec sumList xs = List.fold_left (+) xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nList.fold_left (+)", "min": "\nlet rec sumList xs = List.fold_left (+);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nList.fold_left (+)", "min": "\nlet rec sumList xs = List.fold_left (+);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| x :: xs -> List.fold_left x + xs", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::xs -> (List.fold_left x) + xs;;\n", "out": "Characters 58-74:\n  | x :: xs -> List.fold_left x + xs;;\n               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'b list -> 'a\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[] -> 0", "min": "\nlet rec sumList xs = match xs with | [] -> 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + sum t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sum t);;\n", "out": "Characters 57-60:\n  | h::t -> h + sum t;;\n                ^^^\nError: Unbound value sum\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> 1", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> 1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList xs = match xs with\n[] -> int\n| h::t -> 1", "min": "\nlet rec sumList xs = match xs with | [] -> int | h::t -> 1;;\n", "out": "Characters 41-44:\n  [] -> int\n        ^^^\nError: Unbound value int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = match n with\nn -> n::[]", "min": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 ::[]", "min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [n / 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 :: digitsOfInt n", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | n -> (n / 10) :: (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfIn n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n / 10 with | 0 -> [0] | _ -> digitsOfIn n []);;\n", "out": "Characters 79-89:\n  | _ -> digitsOfIn n [];;\n         ^^^^^^^^^^\nError: Unbound value digitsOfIn\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n / 10 with | 0 -> [0] | _ -> digitsOfInt n []);;\n", "out": "Characters 79-90:\n  | _ -> digitsOfInt n [];;\n         ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n / 10 with | 0 -> [0] | _ -> digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "out": "Characters 73-91:\n  _ -> digitsOfInt (n/10)::[];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10) ::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "out": "Characters 73-91:\n  _ -> digitsOfInt (n/10) ::[];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitOfInt (n/10) :: []", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitOfInt (n / 10)];;\n", "out": "Characters 46-56:\n  else digitOfInt (n/10) :: [];;\n       ^^^^^^^^^^\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) :: []", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "out": "Characters 46-64:\n  else digitsOfInt (n/10) :: [];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) :: (n mod 10)[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) :: ((n mod 10) []);;\n", "out": "Characters 46-64:\n  else digitsOfInt (n/10) :: (n mod 10)[];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10:: x) in match n with\n0 -> [0]\n| _ -> loop n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n x = if n = 0 then x else loop (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n x = if n = 0 then x else loop (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n x = if n = 0 then x else loop (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then [0]\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n x =\n       if n = 0 then [0] else loop (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) \nin match n with\n0 -> [0]\n| _ -> loop n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n x = if n = 0 then x else loop (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec addPersist n x =\n       if n = 0 then x else addPersist ((n / 10) + (n mod 10)) (1 + x) in\n     match n with | 0 -> 0 | _ -> 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec addPersist n x =\n       if n = 0 then x else addPersist ((n / 10) + (n mod 10)) (1 + x) in\n     match n with | 0 -> 0 | _ -> 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec addPersist n x =\n       if n = 0 then x else addPersist (n / 10) (1 + x) in\n     match n with | 0 -> 0 | _ -> 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n 1", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec addPersist n x =\n       if n = 0 then x else addPersist (n / 10) (1 + x) in\n     match n with | 0 -> 0 | _ -> addPersist n 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n 0", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec addPersist n x =\n       if n = 0 then x else addPersist (n / 10) (1 + x) in\n     match n with | 0 -> 0 | _ -> addPersist n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec addPersist n x =\n       if n = 0 then x else addPersist (n / 10) (1 + x) in\n     match n with | 0 -> 0 | _ -> addPersist n (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n/10) (n mod 10::x) \nin match n with\n0 -> [0]\n| _ -> r_digitsOfInt n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec r_digitsOfInt n x =\n       if n = 0 then x else r_digitsOfInt (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> r_digitsOfInt n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec r_digitsOfInt n x =\n       if n = 0 then x else r_digitsOfInt (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> r_digitsOfInt n []);;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> m\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> m | _ -> r_digitalRoot n 0);;\n", "out": "Characters 153-154:\n  0 -> m\n       ^\nError: Unbound value m\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digital root m 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digital root m 0 | _ -> r_digitalRoot n 0);;\n", "out": "Characters 153-162:\n  0 -> r_digital root m 0\n       ^^^^^^^^^\nError: Unbound value r_digital\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot m 0 | _ -> r_digitalRoot n 0);;\n", "out": "Characters 167-168:\n  0 -> r_digitalRoot m 0\n                     ^\nError: Unbound value m\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n < 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n m);;\n", "out": "Characters 178-179:\n  | _ -> r_digitalRoot n m;;\n                         ^\nError: Unbound value m\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n < 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse if n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0\n       then 0\n       else if n < 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse if n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n (n mod 10)", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0\n       then 0\n       else if n < 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n (n mod 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot \n| _ -> r_digitalRoot n (n mod 10)", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot | _ -> r_digitalRoot n (n mod 10));;\n", "out": "Characters 154-167:\n  0 -> r_digitalRoot \n       ^^^^^^^^^^^^^\nError: This expression has type int -> int -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m \n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot m | _ -> r_digitalRoot n 0);;\n", "out": "Characters 168-169:\n  0 -> r_digitalRoot m \n                     ^\nError: Unbound value m\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 6", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 6);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n 6", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 123 | _ -> r_digitalRoot n 6);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n -1", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 123 | _ -> (r_digitalRoot n) - 1);;\n", "out": "Characters 166-181:\n  | _ -> r_digitalRoot n -1;;\n         ^^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n (-1)", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 123 | _ -> r_digitalRoot n (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then 0 else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n < 0 && m != 0 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if (n < 0) && (m != 0)\n       then n\n       else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n < 0) && (m != 0) then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if (n < 0) && (m != 0)\n       then n\n       else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n < 9) && (m != 0) then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if (n < 9) && (m != 0)\n       then n\n       else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 && m != 0 then n + m\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if (n <= 9) && (m != 0)\n       then n + m\n       else\n         if (n = 0) && (m > 9)\n         then r_digitalRoot m 0\n         else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n+m) <= 9 then n + m\nelse if (n+m) > 9 then r_digitalRoot (n+m) 0\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if (n + m) <= 9\n       then n + m\n       else\n         if (n + m) > 9\n         then r_digitalRoot (n + m) 0\n         else\n           if (n = 0) && (m > 9)\n           then r_digitalRoot m 0\n           else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if (n = 0) && (m > 9)\n       then r_digitalRoot m 0\n       else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n + m <= 9 then n + m\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n / 10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if (n + m) <= 9\n       then n + m\n       else\n         if (n = 0) && (m > 9)\n         then r_digitalRoot m 0\n         else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if (n + m) <= 9\n       then x\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 x\n         else r_addPersist (n / 10) ((n mod 10) + m) x in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if (n + m) <= 9\n       then x\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 x\n         else r_addPersist (n / 10) ((n mod 10) + m) x in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if (n + m) <= 9\n       then 0\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 x\n         else r_addPersist (n / 10) ((n mod 10) + m) x in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if (n + m) <= 9\n       then 0\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) (1 + x) in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if (n + m) <= 9\n       then x\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) (1 + x) in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif  n <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if n <= 9\n       then x\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) (1 + x) in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif  n <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if n <= 9\n       then 0\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) (1 + x) in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 && x = (-1) then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n = 0\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if ((n + m) <= 9) && (x = (-1))\n       then 0\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) (1 + x) in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 && x = (-1) then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n <= 9\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if ((n + m) <= 9) && (x = (-1))\n       then 0\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) (1 + x) in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n <= 9\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if (n + m) <= 9\n       then x\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) (1 + x) in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "min": "\nlet rec additivePersistence n =\n  if n <= 9\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if (n + m) <= 9\n       then x\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) x in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 (-1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 1", "min": "\nlet rec additivePersistence n =\n  if n <= 9\n  then 0\n  else\n    (let rec r_addPersist n m x =\n       if (n + m) <= 9\n       then x\n       else\n         if (n = 0) && (m > 9)\n         then r_addPersist m 0 (1 + x)\n         else r_addPersist (n / 10) ((n mod 10) + m) x in\n     match n with | 0 -> 0 | _ -> r_addPersist n 0 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n[] -> []\n| h::t -> listReverse t ::h", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "out": "Characters 56-69:\n  | h::t -> listReverse t ::h;;\n            ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n + m) <= 9 then n + m\nelse if (n = 0) && (m > 9) then r_digitalRoot m 0\nelse r_digitalRoot (n / 10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if (n + m) <= 9\n       then n + m\n       else\n         if (n = 0) && (m > 9)\n         then r_digitalRoot m 0\n         else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h::[]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| h::t -> [] @ h @ digitsOfInt t", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | h::t -> [] @ (h @ (digitsOfInt t)));;\n", "out": "Characters 72-76:\n  | h::t -> [] @ h @ digitsOfInt t;;\n    ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [0] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 0 then digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0 then [0] else if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": "Characters 84-121:\n  else if n > 0 then digitsOfInt (n / 10) @ (n mod 10)::[];;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [n]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) :: (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "out": "Characters 69-89:\n  else digitsOfInt (n / 10) :: (n mod 10)::[];;\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[] \nin match n with \n0 -> [0]\n| _ -> digitsOfInt n @ []", "min": "\nlet _ =\n  let rec digitsOfInt n =\n    if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10] in\n  match n with | 0 -> [0] | _ -> (digitsOfInt n) @ [];;\n", "out": "Characters 95-96:\n  in match n with \n           ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) :: (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "out": "Characters 47-67:\n  else digitsOfInt (n / 10) :: (n mod 10)::[];;\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [0] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: x) \nin match n with\n0 -> [0]\n| _ -> r_digitsOfInt n []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec r_digitsOfInt n x =\n       if n = 0 then x else r_digitsOfInt (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> r_digitsOfInt n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \norig_Esplode = esplode w", "min": "\nlet palindrome w = orig_Esplode = (esplode w);;\n", "out": "Characters 20-32:\n  orig_Esplode = esplode w;;\n  ^^^^^^^^^^^^\nError: Unbound value orig_Esplode\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let palindrome w = \nif w = [] then true", "min": "\nlet palindrome w = if w = [] then true;;\n", "out": "Characters 35-39:\n  if w = [] then true;;\n                 ^^^^\nError: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = match w with\n[] -> true\n| _ -> false", "min": "\nlet palindrome w = match w with | [] -> true | _ -> false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nmatch n with\n| [] -> []\n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | 0 -> [0]\n  | _ -> (digitsOfInt (n / 10)) @ (n mod 10);;\n", "out": "Characters 51-52:\n  | 0 -> [0]\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n", "out": "Characters 102-112:\n  | _ -> digitsOfInt (n / 10) @ (n mod 10);;\n                                ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "out": "Characters 79-99:\n  | _ -> digitsOfInt (n / 10) :: (n mod 10);;\n         ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n", "out": "Characters 79-99:\n  | _ -> digitsOfInt (n / 10) :: (n mod 10 ::[]);;\n         ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ -> if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10]);;\n", "out": "Characters 101-139:\n  if (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[]);;\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ -> if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10] else []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ -> if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10] else []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence sumList n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "out": "Characters 80-99:\n  else 1 + additivePersistence sumList n;;\n           ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList n)", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList n));;\n", "out": "Characters 109-110:\n  else 1 + additivePersistence (sumList n);;\n                                        ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 9 then 0\nelse if sumList (digitsOfInt n) < 9 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 9\n  then 0\n  else\n    if (sumList (digitsOfInt n)) < 9\n    then 1\n    else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10 ::[])", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 9 then 0\nelse if sumList (digitsOfInt n) < 9 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 9\n  then 0\n  else\n    if (sumList (digitsOfInt n)) < 9\n    then 1\n    else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    if (sumList (digitsOfInt n)) < 9\n    then sumList (digitsOfInt n)\n    else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)\nelse digitalRoot (sumList (digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    if (sumList (digitsOfInt n)) < 9\n    then sumList (digitsOfInt n)\n    else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nmatch w with\n| []    -> true\n| h1::t1 -> \nmatch listReverse t1 with\n| h2::t2 -> if h1 = h2 then palindrome t2 \nelse false", "min": "\nlet palindrome w = match w with | [] -> true | _ -> false;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  match w with\n  | [] -> true\n  | h1::_ ->\n      (match listReverse w with\n       | h2::_ -> if h1 = h2 then palindrome w else false);;\n\nlet palindrome w =\n  match w with\n  | [] -> true\n  | h1::t1 ->\n      (match listReverse t1 with\n       | h2::t2 -> if h1 = h2 then palindrome t2 else false);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> false", "min": "\nlet palindrome w = match w with | [] -> true | _ -> false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> listReverse t @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (esplode w))", "min": "\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (esplode w) (reverseList (esplode w));;\n", "out": "Error: Unbound value esplode\nHint: Did you mean explode?\nError: Unbound value esplode\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 204-211:\n  r_palindrome (esplode w) (reverseList (esplode w));;\n                ^^^^^^^\nError: Unbound value esplode\nHint: Did you mean explode?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (esplode w) (reverseList (explode w));;\n", "out": "Characters 204-211:\n  r_palindrome (esplode w) (reverseList (explode w));;\n                ^^^^^^^\nError: Unbound value esplode\nHint: Did you mean explode?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (explode w) (reverseList (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (reverseList (explode w));;\n", "out": "Characters 216-227:\n  r_palindrome (explode w) (reverseList (explode w));;\n                            ^^^^^^^^^^^\nError: Unbound value reverseList\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (reverseList (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (reverseList (explode w));;\n", "out": "Characters 217-228:\n  r_palindrome (explode w) (reverseList (explode w));;\n                            ^^^^^^^^^^^\nError: Unbound value reverseList\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[])          -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (_,_)    -> false \nin\nr_palindrome (explode w) (listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (_,_) -> false in\n  r_palindrome (explode w) (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10) (n mod 10 ::[]))", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;\n", "out": "Characters 56-67:\n  else append (digitsOfInt (n / 10) (n mod 10 ::[]));;\n               ^^^^^^^^^^^\nError: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10) ) (n mod 10 ::[])", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": "Characters 80-88:\n  else append (digitsOfInt (n / 10) ) (n mod 10 ::[]);;\n                                       ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ((n mod 10) ::[])", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": "Characters 79-89:\n  else append (digitsOfInt (n / 10)) ((n mod 10) ::[]);;\n                                      ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": "Characters 79-87:\n  else append (digitsOfInt (n / 10)) [n mod 10];;\n                                      ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ([n mod 10])", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": "Characters 80-88:\n  else append (digitsOfInt (n / 10)) ([n mod 10]);;\n                                       ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ((n mod 10 ::[]))", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": "Characters 80-88:\n  else append (digitsOfInt (n / 10)) ((n mod 10 ::[]));;\n                                       ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "min": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": "Characters 79-87:\n  else append (digitsOfInt (n / 10)) (n mod 10 :: []);;\n                                      ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "min": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> helper t l (h :: acc) in\n  helper x l [];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "min": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> append (listReverse t) [h]", "min": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "min": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "min": "\nlet rec append x l = match x with | [] -> l | h::t -> h :: (append t l);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec append x l = match x with | [] -> l | h::t -> h :: (append t l);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
