{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 36-39:\n  let rec sumList xs = function [] -> int;;\n                                      ^^^\nError: Unbound value int\n", "min": "\nlet rec sumList xs = function | [] -> int;;\n", "in": "let rec sumList xs = function [] -> int"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-57:\n  | h::t -> h + t;;\n                ^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + t;;\n", "in": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-57:\n  | h::t -> h + t in xs;;\n                ^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;\n", "in": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t in xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nList.fold_left (+) xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nList.fold_left (+) xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nList.fold_left (+)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nList.fold_left (+)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-74:\n  | x :: xs -> List.fold_left x + xs;;\n               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'b list -> 'a\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::xs -> (List.fold_left x) + xs;;\n", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| x :: xs -> List.fold_left x + xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[] -> 0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 57-60:\n  | h::t -> h + sum t;;\n                ^^^\nError: Unbound value sum\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sum t);;\n", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + sum t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> 1"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 41-44:\n  [] -> int\n        ^^^\nError: Unbound value int\n", "min": "\nlet rec sumList xs = match xs with | [] -> int | h::t -> 1;;\n", "in": "let rec sumList xs = match xs with\n[] -> int\n| h::t -> 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = match n with\nn -> n::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 ::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 :: digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 79-89:\n  | _ -> digitsOfIn n [];;\n         ^^^^^^^^^^\nError: Unbound value digitsOfIn\nHint: Did you mean digitsOfInt?\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n / 10 with | 0 -> [0] | _ -> digitsOfIn n []);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfIn n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-90:\n  | _ -> digitsOfInt n [];;\n         ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n / 10 with | 0 -> [0] | _ -> digitsOfInt n []);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> ::[] digitsOfInt (n / 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-91:\n  _ -> digitsOfInt (n/10)::[];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10) ::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-91:\n  _ -> digitsOfInt (n/10) ::[];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitOfInt (n/10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-56:\n  else digitOfInt (n/10) :: [];;\n       ^^^^^^^^^^\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-64:\n  else digitsOfInt (n/10) :: [];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop (n/10) (n mod 10::lis) = match n with\n0 -> [0]\n| _ -> loop n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-64:\n  else digitsOfInt (n/10) :: (n mod 10)[];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) :: ((n mod 10) []);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse let rec loop (n/10) (n mod 10::x) in match n with \n0 -> [0]\n| _ -> loop n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10:: x) in match n with\n0 -> [0]\n| _ -> loop n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then [0]\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 8-15:\n  let _ = sumList [1; 3; 5; 7; 9; 11]\n          ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11] ((1 mod 10) :: 4);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) \nin match n with\n0 -> [0]\n| _ -> loop n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) in match n with \n0 -> 0\n| _ -> 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n/10) (n mod 10::x) \nin match n with\n0 -> [0]\n| _ -> r_digitsOfInt n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 153-154:\n  0 -> m\n       ^\nError: Unbound value m\n", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> m | _ -> r_digitalRoot n 0);;\n", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digital root m 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 153-162:\n  0 -> r_digital root m 0\n       ^^^^^^^^^\nError: Unbound value r_digital\n", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digital root m 0 | _ -> r_digitalRoot n 0);;\n", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 167-168:\n  0 -> r_digitalRoot m 0\n                     ^\nError: Unbound value m\n", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot m 0 | _ -> r_digitalRoot n 0);;\n", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 178-179:\n  | _ -> r_digitalRoot n m;;\n                         ^\nError: Unbound value m\n", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n < 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n m);;\n", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse if n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse if n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot \n| _ -> r_digitalRoot n (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-167:\n  0 -> r_digitalRoot \n       ^^^^^^^^^^^^^\nError: This expression has type int -> int -> int\n       but an expression was expected of type int\n", "min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot | _ -> r_digitalRoot n (n mod 10));;\n", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m \n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 6"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n 6"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n -1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 166-181:\n  | _ -> r_digitalRoot n -1;;\n         ^^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 123 | _ -> (r_digitalRoot n) - 1);;\n", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n < 0 && m != 0 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n < 0) && (m != 0) then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n < 9) && (m != 0) then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 && m != 0 then n + m\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n+m) <= 9 then n + m\nelse if (n+m) > 9 then r_digitalRoot (n+m) 0\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n + m <= 9 then n + m\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n / 10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif  n <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif  n <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 && x = (-1) then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 && x = (-1) then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\nif l = [] then []\nelse let rec r_listReverse l x = match l with\n[] -> []\n| h::t -> r_listReverse t []::h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-69:\n  | h::t -> listReverse t ::h;;\n            ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| h::t -> [] @ h @ digitsOfInt t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-76:\n  | h::t -> [] @ h @ digitsOfInt t;;\n    ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | h::t -> [] @ (h @ (digitsOfInt t)));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0, then [0]\nelse _ -> digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse _ -> digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse in n > 0 then digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 0 then digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [n]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) :: (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-89:\n  else digitsOfInt (n / 10) :: (n mod 10)::[];;\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 @ [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[] \nin match n with \n0 -> [0]\n| _ -> digitsOfInt n @ []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) :: (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet orig_Esplode = esplode w"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 20-32:\n  orig_Esplode = esplode w;;\n  ^^^^^^^^^^^^\nError: Unbound value orig_Esplode\n", "min": "\nlet palindrome w = orig_Esplode = (esplode w);;\n", "in": "let palindrome w = \nif w = [] then true\nelse\nlet orig_Esplode = esplode w and\nlet reverse_Esplode = explode reverseList w in \nlet rec r_palindrome orig_Esplode revserse_Esplode = \nlet h1 = h::orig_Esplode \nand h2 = h::reverse_Esplode\nif h1 = h2 then r_panlindrome orig_Esplode reverse_Esplode\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 35-39:\n  if w = [] then true;;\n                 ^^^^\nError: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n", "min": "\nlet palindrome w = if w = [] then true;;\n", "in": "let palindrome w = match w with\n[] -> true\n| _ -> false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| [] -> []\n| 0 -> [0]\n| _ -> = digitsOfInt (n / 10) @ (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 51-52:\n  | 0 -> [0]\n    ^\nError: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n", "min": "\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | 0 -> [0]\n  | _ -> (digitsOfInt (n / 10)) @ (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 102-112:\n  | _ -> digitsOfInt (n / 10) @ (n mod 10);;\n                                ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-99:\n  | _ -> digitsOfInt (n / 10) :: (n mod 10);;\n         ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-99:\n  | _ -> digitsOfInt (n / 10) :: (n mod 10 ::[]);;\n         ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 101-139:\n  if (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[]);;\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ -> if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 36-43:\n  if sumList digitsOfInt n < 9 then 0\n     ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList digitsOfInt n) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence sumList n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-99:\n  else 1 + additivePersistence sumList n;;\n           ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-110:\n  else 1 + additivePersistence (sumList n);;\n                                        ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList n));;\n", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n < 9 then 0\nelse if sumList (digitsOfInt n) < 9 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n < 9 then 0\nelse if sumList (digitsOfInt n) < 9 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)\nelse digitalRoot (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nmatch w with\n| []    -> true\n| h1::t1 -> \nmatch listReverse t1 with\n| h2::t2 -> if h1 = h2 then palindrome t2 \nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet rec r_palindrome w = \nmatch w with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| h2::t2 ->\nif h1 = h2 then reverseList t2\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet ex = esplode w \nand let rev_ex = reverseList ex in\nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value esplode\nHint: Did you mean explode?\nError: Unbound value esplode\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 204-211:\n  r_palindrome (esplode w) (reverseList (esplode w));;\n                ^^^^^^^\nError: Unbound value esplode\nHint: Did you mean explode?\n", "min": "\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (esplode w) (reverseList (esplode w));;\n", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 204-211:\n  r_palindrome (esplode w) (reverseList (explode w));;\n                ^^^^^^^\nError: Unbound value esplode\nHint: Did you mean explode?\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (esplode w) (reverseList (explode w));;\n", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (explode w) (reverseList (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 216-227:\n  r_palindrome (explode w) (reverseList (explode w));;\n                            ^^^^^^^^^^^\nError: Unbound value reverseList\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (reverseList (explode w));;\n", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (reverseList (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 217-228:\n  r_palindrome (explode w) (reverseList (explode w));;\n                            ^^^^^^^^^^^\nError: Unbound value reverseList\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (reverseList (explode w));;\n", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[])          -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (_,_)    -> false \nin\nr_palindrome (explode w) (listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10) (n mod 10 ::[]))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-67:\n  else append (digitsOfInt (n / 10) (n mod 10 ::[]));;\n               ^^^^^^^^^^^\nError: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10) ) (n mod 10 ::[])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-88:\n  else append (digitsOfInt (n / 10) ) (n mod 10 ::[]);;\n                                       ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ((n mod 10) ::[])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-89:\n  else append (digitsOfInt (n / 10)) ((n mod 10) ::[]);;\n                                      ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 79-87:\n  else append (digitsOfInt (n / 10)) [n mod 10];;\n                                      ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ([n mod 10])"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-88:\n  else append (digitsOfInt (n / 10)) ([n mod 10]);;\n                                       ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ((n mod 10 ::[]))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-65:\n  | h::t -> append listReverse t [h];;\n            ^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> append (listReverse t) [h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
