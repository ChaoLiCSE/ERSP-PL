{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fs a in\nlet base = fs x in\nList.fold_left f base fs", "out": "Characters 49-50:\n  let base = fs x in\n                ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = fs a in let base = fs x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fs a in\nlet base = fs in\nList.fold_left f base fs", "out": "Characters 69-73:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet pipe fs = let f a x = fs a in let base = fs in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fs a x in\nlet base = fs a in\nList.fold_left f base fs", "out": "Characters 51-52:\n  let base = fs a in\n                ^\nError: Unbound value a\n", "min": "\nlet pipe fs =\n  let f a x = fs a x in let base = fs a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fs a x in\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 75-77:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type int -> 'a -> int\n       but an expression was expected of type 'a list\n", "min": "\nlet pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fs a in\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type int -> int\n       but an expression was expected of type 'a list\n", "min": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fs x in\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a -> int\n       but an expression was expected of type 'a list\n", "min": "\nlet pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "out": "Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 1 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = y in\n             ^\nError: Unbound value y\n", "min": "\nlet pipe fs = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs= \nlet f a x = x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs= \nlet f a x = x in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a + x in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "Characters 79-83:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a + x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "Characters 81-85:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs =\n  let f a x = a + (x a) in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x + x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "Characters 35-36:\n  let f a x = a x + x a in\n                      ^\nError: This expression has type ('a -> 'b) -> int\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) -> int\n", "min": "\nlet pipe fs =\n  let f a x = (a x) + (x a) in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x' y -> x a + a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "Characters 91-92:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type int -> (int -> int) -> 'a -> 'b -> int\n       but an expression was expected of type int -> (int -> int) -> int\n       Type 'a -> 'b -> int is not compatible with type int \n", "min": "\nlet pipe fs =\n  let f a x x' y = (x a) + a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun a -> x a  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun c -> x a  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x c = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun a -> x a + a  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x a = (x a) + a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun a -> x a + x in\nlet base = fun x -> x  in\nList.fold_left f base fs", "out": "Characters 42-43:\n  let f a x = fun a -> x a + x in\n                             ^\nError: This expression has type 'a -> int\n       but an expression was expected of type int\n", "min": "\nlet pipe fs =\n  let f a x a = (x a) + x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs y = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe []", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "Characters 26-27:\n  let cat = pipe [(fun x -> x + x )];;\n                            ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "Characters 26-27:\n  let cat = pipe [(fun x -> x + x )];;\n                            ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "Characters 26-27:\n  let cat = pipe [(fun x -> x + x )];;\n                            ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l", "out": "Characters 159-160:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ a in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ x in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ x) in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a ^ sep ^ x in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (a ^ (sep ^ x))) in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a ^ x in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (a ^ x)) in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep in\nlet base = sepConcat sep t in\nlet l = h::t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = sepConcat sep t in let l = h :: t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ a in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ a ^ sep ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ (sep ^ x)) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat sep t ^ sep ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (sepConcat sep t) ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat sep t ^ sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (sepConcat sep t) ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> f h ^ stringOfList f t", "out": "Characters 61-73:\n  | h::t -> f h ^ stringOfList f t;;\n                  ^^^^^^^^^^^^\nError: Unbound value stringOfList\n", "min": "\nlet stringOfList f l =\n  match l with | [] -> \"\" | h::t -> (f h) ^ (stringOfList f t);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = x ^ a in\nlet base = f h in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f' a x = x ^ a in\n      let base = f h in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = f x ^ a in\nlet base = f h in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f' a x = (f x) ^ a in\n      let base = f h in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = a ^ f x in\nlet base = f h in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f' a x = a ^ (f x) in\n      let base = f h in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = \"[\" ^ a ^ \"; \" ^ f x in\nlet base = f h ^ \"]\" in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f' a x = \"[\" ^ (a ^ (\"; \" ^ (f x))) in\n      let base = (f h) ^ \"]\" in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = a ^ \"; \" ^ f x in\nlet base = \"[\" ^ f h ^ \"]\" in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f' a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ ((f h) ^ \"]\") in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = a ^ \"; \" ^ f x ^ \"]\" in\nlet base = \"[\" ^ f h ^ \"]\" in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f' a x = a ^ (\"; \" ^ ((f x) ^ \"]\")) in\n      let base = \"[\" ^ ((f h) ^ \"]\") in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"]\"\n| h::t -> \nlet f' a x = a ^ \"; \" ^ f x in\nlet base = \"[\" ^ f h in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"]\"\n  | h::t ->\n      let f' a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f h) in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"]\"\n| h::t -> \nlet f' a x = a ^ \"]; \" ^ f x in\nlet base = \"[\" ^ f h in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"]\"\n  | h::t ->\n      let f' a x = a ^ (\"]; \" ^ (f x)) in\n      let base = \"[\" ^ (f h) in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"]\"\n| h::t -> \nlet f' a x = a ^ \"; \" ^ f x in\nlet base = \"[\" ^ f h in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"]\"\n  | h::t ->\n      let f' a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f h) in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"]\"\n| h::t -> \nlet f' a x = a ^ \"; \" ^ f x in\nlet base = \"[\" ^ f h ^\"]\" in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"]\"\n  | h::t ->\n      let f' a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ ((f h) ^ \"]\") in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"]\"\n| h::t -> \nlet f' a x = a ^ \"; \" ^ f x in\nlet base = \"[\" ^ f h in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"]\"\n  | h::t ->\n      let f' a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f h) in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = match l with\n[] -> \"[]]\"\n| h::t -> \nlet f' a x = a ^ \"; \" ^ f x in\nlet base = \"[\" ^ f h in\nlet l = t in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]]\"\n  | h::t ->\n      let f' a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f h) in let l = t in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet rec helper f l = match l with\n[] -> \"\"\n| h::t -> f h ^ helper f t \nin\nhelper f l", "out": "", "min": "\nlet stringOfList f l =\n  let rec helper f l = match l with | [] -> \"\" | h::t -> (f h) ^ (helper f t) in\n  helper f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x = a ^ \"; \" ^ f x in\nlet base = \"[]\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = a ^ (\"; \" ^ (f x)) in\n  let base = \"[]\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x = a ^ \"; \" ^ f x in\nlet base = \"[\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = a ^ (\"; \" ^ (f x)) in\n  let base = \"[\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x = if a = \"\" then f x else a ^ \"; \" ^ f x in\nlet base = \"[\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = if a = \"\" then f x else a ^ (\"; \" ^ (f x)) in\n  let base = \"[\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x = \"; \" ^ f x in\nlet base = \"[\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = \"; \" ^ (f x) in let base = \"[\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x =  a ^ \"; \" ^ f x in\nlet base = \"[\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = a ^ (\"; \" ^ (f x)) in\n  let base = \"[\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x =  a ^ \"; \" ^ f x in\nlet base = \"[\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = a ^ (\"; \" ^ (f x)) in\n  let base = \"[\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x =  a ^ \"; \" ^ f x in\nlet base = \"[\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = a ^ (\"; \" ^ (f x)) in\n  let base = \"[\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "", "min": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "Characters 26-27:\n  let cat = pipe [(fun x -> x + x )];;\n                            ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x ( x a ) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = x (x a) in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x ( x a ) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = x (x a) in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "Characters 26-27:\n  let cat = pipe [(fun x -> x + x )];;\n                            ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs =\n  let f a x = x (x a) in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fs a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 82-84:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type 'b list\n", "min": "\nlet pipe fs = let f a x = fs a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a + x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 78-82:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x + x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type (int -> int) -> int -> int\n       but an expression was expected of type\n         (int -> int) -> int -> int -> int\n       Type int is not compatible with type int -> int \n", "min": "\nlet pipe fs =\n  let f a x = (a x) + x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 81-82:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "min": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 81-82:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "min": "\nlet pipe fs = let f a x y = a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "", "min": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y-> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = (a,x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet pipe fs =\n  let f a x = (a, x) in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 90-91:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "min": "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )]", "out": "Characters 26-27:\n  let cat = pipe [(fun x -> x + x )];;\n                            ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let cat = pipe [(fun x -> x + x )] 3", "out": "Characters 26-27:\n  let cat = pipe [(fun x -> x + x )] 3;;\n                            ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)] 3;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y -> x ( a y ) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x =  a ^ \"; \" ^ f x in\nlet base = \"[\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = a ^ (\"; \" ^ (f x)) in\n  let base = \"[\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x =  a ^ \"; \" ^ f x in\nlet base = \"[\" in\nList.fold_left f' base l", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = a ^ (\"; \" ^ (f x)) in\n  let base = \"[\" in List.fold_left f' base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x = a ^ x in\nlet base = \"]\" in\nList.fold_right f' l base", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = a ^ x in let base = \"]\" in List.fold_right f' l base;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nlet f' a x = (f a) ^ x in\nlet base = \"]\" in\nList.fold_right f' l base", "out": "", "min": "\nlet stringOfList f l =\n  let f' a x = (f a) ^ x in let base = \"]\" in List.fold_right f' l base;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^\nlet f' a x = (f a) ^ x in\nlet base = \"]\" in\nList.fold_right f' l base", "out": "", "min": "\nlet stringOfList f l =\n  \"[\" ^\n    (let f' a x = (f a) ^ x in let base = \"]\" in List.fold_right f' l base);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^\nlet f' a x = (f a) ^ \";\" ^ x in\nlet base = \"]\" in\nList.fold_right f' l base", "out": "", "min": "\nlet stringOfList f l =\n  \"[\" ^\n    (let f' a x = (f a) ^ (\";\" ^ x) in\n     let base = \"]\" in List.fold_right f' l base);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^\nlet f' a x = \nif x = \"]\"\nthen (f a) ^ x \nelse (f a) ^ \";\" ^ x in\nlet base = \"]\" in\nList.fold_right f' l base", "out": "", "min": "\nlet stringOfList f l =\n  \"[\" ^\n    (let f' a x = if x = \"]\" then (f a) ^ x else (f a) ^ (\";\" ^ x) in\n     let base = \"]\" in List.fold_right f' l base);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^\nlet f' a x = \nif x = \"]\"\nthen (f a) ^ x \nelse (f a) ^ \"; \" ^ x in\nlet base = \"]\" in\nList.fold_right f' l base", "out": "", "min": "\nlet stringOfList f l =\n  \"[\" ^\n    (let f' a x = if x = \"]\" then (f a) ^ x else (f a) ^ (\"; \" ^ x) in\n     let base = \"]\" in List.fold_right f' l base);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0 then\n[]\nelse\nx :: clone x ( n - 1 )", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.size l1 > List.size l2 then\n( l1, List.append( clone 0 ((List.size l1) - (List.size l2)), l2  ))\nelse if List.size l1 < List.size l2 then\n( List.append( clone 0 ((List.size l2) - (List.size l1)) l1 ), l2  )\nelse\n( l1, l2 )", "out": "Characters 28-37:\n  if List.size l1 > List.size l2 then\n     ^^^^^^^^^\nError: Unbound value List.size\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.size l1) > (List.size l2)\n  then (l1, (List.append ((clone 0 ((List.size l1) - (List.size l2))), l2)))\n  else\n    if (List.size l1) < (List.size l2)\n    then ((List.append (clone 0 ((List.size l2) - (List.size l1)) l1)), l2)\n    else (l1, l2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append( clone 0 ((List.length l1) - (List.length l2)), l2  ))\nelse if List.length l1 < List.length l2 then\n( List.append( clone 0 ((List.length l2) - (List.length l1)) l1 ), l2  )\nelse\n( l1, l2 )", "out": "Characters 82-136:\n  ( l1, List.append( clone 0 ((List.length l1) - (List.length l2)), l2  ))\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append ((clone 0 ((List.length l1) - (List.length l2))), l2)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1)) - (List.length l2)), l2  )\nelse if List.length l1 < List.length l2 then\n( List.append( clone 0 ((List.length l2) - (List.length l1)) l1 ), l2  )\nelse\n( l1, l2 )", "out": "Characters 84-110:\n  ( l1, List.append (clone 0 ((List.length l1)) - (List.length l2)), l2  )\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append ((clone 0 (List.length l1)) - (List.length l2))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2)), l2  ))\nelse if List.length l1 < List.length l2 then\n( List.append( clone 0 ((List.length l2) - (List.length l1)) l1 ), l2  )\nelse\n( l1, l2 )", "out": "Characters 83-136:\n  ( l1, List.append (clone 0 ((List.length l1) - (List.length l2)), l2  ))\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append ((clone 0 ((List.length l1) - (List.length l2))), l2)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append clone 0 ((List.length l1) - (List.length l2)), l2 )\nelse if List.length l1 < List.length l2 then\n( List.append( clone 0 ((List.length l2) - (List.length l1)) l1 ), l2  )\nelse\n( l1, l2 )", "out": "Characters 71-82:\n  ( l1, List.append clone 0 ((List.length l1) - (List.length l2)), l2 )\n        ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append clone 0 ((List.length l1) - (List.length l2))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "clone 0 5", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 0 5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "clone 0 5", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 0 5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "List.append clone 0 5 a", "out": "Characters 0-11:\n  List.append clone 0 5 a;;\n  ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone 0 5 a;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "List.append clone( 0 5 ) a", "out": "Characters 0-11:\n  List.append clone( 0 5 ) a;;\n  ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone (0 5) a;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "clone 0 5", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 0 5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let c = clone 0 5", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet c = clone 0 5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "List.append (clone 0 5) a", "out": "", "min": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append (clone 0 5) a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( List.append( clone 0 ((List.length l2) - (List.length l1)) l1 ), l2  )\nelse\n( l1, l2 )", "out": "Characters 182-254:\n  ( List.append( clone 0 ((List.length l2) - (List.length l1)) l1 ), l2  )\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type\n         'c list * (int list -> int list) * 'd list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( List.append (clone 0 ((List.length l1) - (List.length l2))), l1,  l2 )\nelse\n( l1, l2 )", "out": "Characters 184-243:\n  ( List.append (clone 0 ((List.length l1) - (List.length l2))), l1,  l2 )\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l1) - (List.length l2)))), l1, l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( List.append (clone 0 ((List.length l1) - (List.length l2))) l1,  l2 )\nelse\n( l1, l2 )", "out": "Characters 182-253:\n  ( List.append (clone 0 ((List.length l1) - (List.length l2))) l1,  l2 )\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type\n         'c list * (int list -> int list) * 'd list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l1) - (List.length l2))) l1), l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )\nelse\n( l1, l2 )", "out": "Characters 182-255:\n  ( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type\n         'c list * (int list -> int list) * 'd list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l1) - (List.length l2))) l1), l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((List.length l1) - (List.length l2))) l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( List.append clone 0 ( -1 * diffsize ) l1,  l2 )", "out": "Characters 145-156:\n  ( List.append clone 0 ( -1 * diffsize ) l1,  l2 );;\n    ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append clone 0 ((-1) * diffsize) l1), l2);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( List.append (clone 0 ( -1 * diffsize )) l1,  l2 )", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = failwith \"to be implemented\"", "out": "", "min": "\nlet rec removeZero l = failwith \"to be implemented\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n[] -> []\n| h::t -> \nif h = 0 then\nremoveZero t\nelse\nt", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n[] -> []\n| h::t -> \nif h = 0 then\nremoveZero t\nelse\nh::t", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 209-235:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ( [], ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a )\n| _ -> ( [], a )\nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 239-240:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int list * int list -> 'a list * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type 'a list * int list is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) ->\n          ([], (((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a))\n      | _ -> ([], a) in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 209-235:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 258-273:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = ([],[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 222-226:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 200-226:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = ([],[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 222-226:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 110-130:\n  | (h1, h2) -> removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))::a\n                                               ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> removeZero ((((h1 + h2) / 10 )::(( h1 + h2) mod 10 )))::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 111-131:\n  | (h1, h2) -> removeZero ((((h1 + h2) / 10 )::(( h1 + h2) mod 10 )))::a\n                                                ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero ((((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))))::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 112-132:\n  | (h1, h2) -> (removeZero ((((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))))::a\n                                                 ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))) :: a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 111-131:\n  | (h1, h2) -> (removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))) :: a\n                                                ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::[(( h1 + h2) mod 10 )])) :: a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 263-284:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero [(h1 + h2) / 10; (h1 + h2) mod 10]) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) ->  \nif ((h1 + h2) / 10 ) = 0 then\n(( h1 + h2) mod 10 )::a\nelse\n((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) ->\n          if ((h1 + h2) / 10) = 0\n          then ((h1 + h2) mod 10) :: a\n          else ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2) ->\n(((x1 + x2 + h1) / 10 ),(( x1 + x2 + h1 ) mod 10 )::h2)\n| _ -> a \nin\nlet base = (0,[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (h1,h2) ->\n               ((((x1 + x2) + h1) / 10), ((((x1 + x2) + h1) mod 10) :: h2))\n           | _ -> a) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2) ->\n(((x1 + x2 + h1) / 10 ),(( x1 + x2 + h1 ) mod 10 )::h2)\nin\nlet base = (0,[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (h1,h2) ->\n               ((((x1 + x2) + h1) / 10), ((((x1 + x2) + h1) mod 10) :: h2))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n[] -> []\n| h::t -> \nif h = 0 then\nremoveZero t\nelse\nh::t", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2) ->\n( ((x1 + x2 + h1) / 10 ) , (( x1 + x2 + h1 ) mod 10 )::h2)\n| _ -> match a with\n(h1, h2) -> ( h1, h1::h2)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (h1,h2) ->\n               ((((x1 + x2) + h1) / 10), ((((x1 + x2) + h1) mod 10) :: h2))\n           | _ -> (match a with | (h1,h2) -> (h1, (h1 :: h2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (h1, h2) -> match x with\n(x1, x2) ->\n( ((x1 + x2 + h1) / 10 ) , (( x1 + x2 + h1 ) mod 10 )::h2)\n\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1,h2) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + h1) / 10), ((((x1 + x2) + h1) mod 10) :: h2))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2) ->\n( ((x1 + x2 + h1) / 10 ) , (( x1 + x2 + h1 ) mod 10 )::h2)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (h1,h2) ->\n               ((((x1 + x2) + h1) / 10), ((((x1 + x2) + h1) mod 10) :: h2))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2) ->\n( ((x1 + x2 + h1) / 10 ) , (( x1 + x2 + h1 ) mod 10 )::h2)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (h1,h2) ->\n               ((((x1 + x2) + h1) / 10), ((((x1 + x2) + h1) mod 10) :: h2))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , sum::( sum mod 10 )::t2)\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (h1,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), (sum :: (sum mod 10) :: t2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(_, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , sum::( sum mod 10 )::t2)\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), (sum :: (sum mod 10) :: t2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(_, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , sum::( sum mod 10 )::t2)\n| (_,_) -> (0,[0])\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), (sum :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(_, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , (sum / 10)::( sum mod 10 )::t2)\n| (_,_) -> (0,[0])\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = failwith \"to be implemented\"", "out": "", "min": "\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = bigAdd l l + mulByDigit (i - 1) l", "out": "Characters 25-35:\n  let rec mulByDigit i l = bigAdd l l + mulByDigit (i - 1) l;;\n                           ^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (bigAdd l l) + (mulByDigit (i - 1) l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = bigAdd bigAdd (l l) (mulByDigit (i - 1) l)", "out": "Characters 25-31:\n  let rec mulByDigit i l = bigAdd bigAdd (l l) (mulByDigit (i - 1) l);;\n                           ^^^^^^\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd bigAdd (l l) (mulByDigit (i - 1) l);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = bigAdd (bigAdd (l l), (mulByDigit (i - 1) l))", "out": "Characters 32-70:\n  let rec mulByDigit i l = bigAdd (bigAdd (l l), (mulByDigit (i - 1) l));;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd ((bigAdd (l l)), (mulByDigit (i - 1) l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = bigAdd (bigAdd (l l)) (mulByDigit (i - 1) l)", "out": "Characters 43-44:\n  let rec mulByDigit i l = bigAdd (bigAdd (l l)) (mulByDigit (i - 1) l);;\n                                             ^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd (bigAdd (l l)) (mulByDigit (i - 1) l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(_, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , (sum / 10)::( sum mod 10 )::t2)\n| (_,_) -> (0,[0])\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| _ -> bigAdd ((bigAdd) l l) (mulByDigit (i - 1) l )", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| _ -> bigAdd ((bigAdd) l l) (mulByDigit (i - 1) l )", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = match i with\n0 -> []\n| _ -> bigAdd l (mulByDigit (i - 1) l )", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(_, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , (sum / 10)::( sum mod 10 )::t2)\n| (_,_) -> (0,[0])\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10))::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 146-160:\n  ( ( h1 + 1 , (mul / 10))::( mul mod 10 )::t2)\n                            ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int * int\n", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::\n               (mul mod 10) :: t2\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10))::(( mul mod 10 )::t2))\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 147-161:\n  ( ( h1 + 1 , (mul / 10))::(( mul mod 10 )::t2))\n                             ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int * int\n", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::\n               (mul mod 10) :: t2\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in\n             ((h1 + 1), ((mul / 10) :: (mul mod 10) :: t2))\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 + h2 in\n( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = (x1 * x2) + h2 in\n             ((h1 + 1), ((mul / 10) :: (mul mod 10) :: t2))\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( l1', l2' ) = x in\nlet ( pos, total ) = a in\nmatch l2' with\n[] -> []\n| h::t -> ( pos + 1,  bigAdd (mulByDigit (10 ** pos * h) l2) total ) in\nlet base = (0,[0]) in\nlet args = (List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 117-175:\n  | h::t -> ( pos + 1,  bigAdd (mulByDigit (10 ** pos * h) l2) total ) in\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with\n    | [] -> []\n    | h::t -> ((pos + 1), (bigAdd (mulByDigit ((10 ** pos) * h) l2) total)) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( l1', l2' ) = x in\nlet ( pos, total ) = a in\nmatch l2' with\n[] -> []\n| h::t -> ( (pos + 1),  (bigAdd (mulByDigit (10 ** pos * h) l2) total) ) in\nlet base = (0,[0]) in\nlet args = (List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 117-179:\n  | h::t -> ( (pos + 1),  (bigAdd (mulByDigit (10 ** pos * h) l2) total) ) in\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with\n    | [] -> []\n    | h::t -> ((pos + 1), (bigAdd (mulByDigit ((10 ** pos) * h) l2) total)) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( l1', l2' ) = x in\nlet ( pos, total ) = a in\nmatch l2' with\n[] -> []\n| h::t -> ( (pos + 1),  (\\total ) in\nlet base = (0,[0]) in\nlet args = (List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 132-133:\n  | h::t -> ( (pos + 1),  (\\total ) in\n                           ^\nError: Illegal character (\\\\)\n", "min": "", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( l1', l2' ) = x in\nlet ( pos, total ) = a in\nmatch l2' with\n[] -> []\n| h::t -> ( (pos + 1),  (\\total ) in\nlet base = (0,[0]) in\nlet args = (List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 132-133:\n  | h::t -> ( (pos + 1),  (\\total ) in\n                           ^\nError: Illegal character (\\\\)\n", "min": "", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( l1', l2' ) = x in\nlet ( pos, total ) = a in\nmatch l2' with\n[] -> []\n| h::t -> ( (pos + 1),  (total) ) in\nlet base = (0,[0]) in\nlet args = (List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 117-140:\n  | h::t -> ( (pos + 1),  (total) ) in\n            ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with | [] -> [] | h::t -> ((pos + 1), total) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet bigMul l1 l2 =\n  let f a x = let (pos,total) = a in ((pos + 1), l2) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit pos l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (pos,total) = a in ((pos + 1), (mulByDigit pos l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10 ** pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 83-85:\n  ( pos + 1, mulByDigit ( 10 ** pos) l2 ) in \n                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (pos,total) = a in ((pos + 1), (mulByDigit (10 ** pos) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10.0 ** pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 91-94:\n  ( pos + 1, mulByDigit ( 10.0 ** pos) l2 ) in \n                                  ^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in ((pos + 1), (mulByDigit (10.0 ** pos) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10.0 ** float_of_int pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 81-108:\n  ( pos + 1, mulByDigit ( 10.0 ** float_of_int pos) l2 ) in \n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1), (mulByDigit (10.0 ** (float_of_int pos)) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1), (mulByDigit (int_of_float (10.0 ** (float_of_int pos))) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos) * x) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1),\n      (mulByDigit ((int_of_float (10.0 ** (float_of_int pos))) * x) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, bigAdd (mulByDigit (int_of_float (10.0 ** float_of_int pos) * x) l2) total ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1),\n      (bigAdd\n         (mulByDigit ((int_of_float (10.0 ** (float_of_int pos))) * x) l2)\n         total)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
