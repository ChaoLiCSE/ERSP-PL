{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = t in\nif List.mem seen' seen\nthen helper (seen, rest')\nelse helper (seen'::seen,rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f, 1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f, 3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 3);;\n", "in": "wwhile (f, 3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 3);;\n", "in": "wwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-6:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 2);;\n", "in": "wwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-6:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 2);;\n", "in": "wwhile (f, 3)"}, {"type": "scope", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 3);;\n", "in": "let fixpoint (f,b) =\nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 59-67:\n  else fixpoint (f, b');;\n       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "in": "let rec fixpoint (f,b) =\nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec fixpoint (f,b) = \nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec fixpoint (f,b) = \nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint_helper f b = \nlet b' = f b in\n(b', b = b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint_helper (fun x -> x+1) 3"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec fixpoint (f,b) = wwhile (fixpoint_helper f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 25-31:\n  let rec fixpoint (f,b) = wwhile (fixpoint_helper f, b);;\n                           ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint_helper f b = let b' = f b in (b', (b = b'));;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint_helper (fun x -> x-1)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-15:\n  fixpoint_helper (fun x -> x-1);;\n  ^^^^^^^^^^^^^^^\nError: Unbound value fixpoint_helper\n", "min": "\nlet _ = fixpoint_helper (fun x  -> x - 1);;\n", "in": "fixpoint_helper (fun x -> x+1) 3"}, {"type": "scope", "out": "Characters 0-15:\n  fixpoint_helper (fun x -> x+1) 3;;\n  ^^^^^^^^^^^^^^^\nError: Unbound value fixpoint_helper\n", "min": "\nlet _ = fixpoint_helper (fun x  -> x + 1) 3;;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint_helper f, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (fixpoint_helper f, b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\n", "in": "wwhile (f, 3)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 3);;\n", "in": "wwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint_helper f b = \nlet b' = f b in\n(b', b != b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| Varx      -> \"x\"\n| VarY      -> \"y\"\n| Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cos e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 40-44:\n  | Varx      -> \"x\"\n    ^^^^\nError: Unbound constructor Varx\nHint: Did you mean VarX or VarY?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Varx  -> \"x\"\n  | VarY  -> \"y\"\n  | Sin e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cos e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cos e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-81:\n  | Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n    ^^^\nError: This variant pattern is expected to have type expr\n       The constructor Sin does not belong to type expr\nHint: Did you mean Sine?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sin e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cos e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 158-172:\n  | Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n    ^^^^^^^^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 103-107:\n  | Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n                             ^^^^\nError: Unbound value expr\nHint: Did you mean exp?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 200-212:\n  | Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n                              ^^^^^^^^^^^^\nError: Unbound value esprToString\nHint: Did you mean exprToString?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x'+y')/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 88-90:\n  | Average (x', y') -> (x'+y')/2;;\n                         ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x' + y') / 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x'+ eval y')/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-95:\n  | Average (x', y') -> (eval x'+ eval y')/2;;\n                              ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval x') + (eval y')) / 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x' y + eval x y')/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-95:\n  | Average (x', y') -> (eval x' y + eval x y')/2;;\n                              ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b) * ('a -> 'b)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval x' y) + (eval x y')) / 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-97:\n  | Average (x', y') -> (eval VarX x' y + eval VarY x y')/2;;\n                              ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval VarX x' y) + (eval VarY x y')) / 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 88-106:\n  | Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2;;\n                         ^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval (VarX, x', y)) + (eval (VarY, x, y'))) / 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x'+y')/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 88-90:\n  | Average (x', y') -> (x'+y')/2;;\n                         ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x' + y') / 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x+y)/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 34-37:\n  let _ = eval (Average(VarX,VarY), 0.5, 0.5);;\n                                    ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x + y) / 2;;\n\nlet _ = eval ((Average (VarX, VarY)), 0.5, 0.5);;\n", "in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x+y)/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 34-37:\n  let _ = eval (Average(VarX,VarY), 0.5, 0.5);;\n                                    ^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x + y) / 2;;\n\nlet _ = eval ((Average (VarX, VarY)), 0.5, 0.5);;\n", "in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y)/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-66:\n  | Average (x', y') -> (x +. y)/2;;\n                        ^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) / 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x .+ y)/2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-66:\n  | Average (x', y') -> (x +. y)/2;;\n                        ^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) / 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) ./ 2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-71:\n  | Average (x', y') -> (x +. y) /. 2;;\n                                    ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin(pi *. eval(e'))\n| Cosine e'\t\t-> cos(pi *. eval(e'))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-68:\n  | Sine e'\t\t-> sin(pi *. eval(e'))\n                              ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n", "in": "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin (pi *. eval(e'))\n| Cosine e'\t\t-> cos (pi *. eval(e'))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-69:\n  | Sine e'\t\t-> sin (pi *. eval(e'))\n                               ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n", "in": "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times   (x', y')\t-> x *. y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times   (x', y')\t-> x *. y\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-12:\n  let _ = rand;;\n          ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\nlet _ = rand;;\n", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()\nelse\nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()\nelse\nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet num = rand in\nif depth = 0\nthen \nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()\nelse\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,6) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,6) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Divides  of expr * expr\n| Cubes    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Divides  of expr * expr\n| Cubes    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot of expr\n| FunckyCube of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt eval(e',x,y)\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e',x,x)) (sqrt eval(e',x,y)) (sqrt eval(e',y,y)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 411-421:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e',x,x)) (sqrt eval(e',x,y)) (sqrt eval(e',y,y)));;\n    ^^^^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor FunckyRoot does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt eval (e', x, y)\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot of expr\n| FunckyRoot of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyCube (e1,e2,e3)   -> \n\"sqrt(sqrt(\"^exprToString e1^\")+sqrt(\"^exprToString e2^\")+sqrt(\"^exprToString e3^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 478-488:\n  | FunckyCube (e1,e2,e3)   -> \n    ^^^^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor FunckyCube does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckyCube (e1,e2,e3) ->\n      \"sqrt(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")+sqrt(\" ^\n              ((exprToString e2) ^ (\")+sqrt(\" ^ ((exprToString e3) ^ \"))\")))));;\n", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyRoot (e1,e2,e3)   -> \n\"sqrt(sqrt(\"^exprToString e1^\")+sqrt(\"^exprToString e2^\")+sqrt(\"^exprToString e3^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 391-395:\n  | SquareRoot e'\t\t-> sqrt eval(e',x,y)\n                      ^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt eval (e', x, y)\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y)(\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e',x,x)) (sqrt eval(e',x,y)) (sqrt eval(e',y,y)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 445-449:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e',x,x)) (sqrt eval(e',x,y)) (sqrt eval(e',y,y)));;\n                                    ^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e',x,x))) (sqrt (eval(e',x,y))) (sqrt (eval(e',y,y))))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 456-458:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e',x,x))) (sqrt (eval(e',x,y))) (sqrt (eval(e',y,y))));;\n                                               ^^\nError: Unbound value e'\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e', x, x))) (sqrt (eval (e', x, y)))\n           (sqrt (eval (e', y, y))));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(ee3,y,y))))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 444-465:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(ee3,y,y))));;\n                                   ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\n           (sqrt (eval (ee3, y, y))));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(e3,y,y))))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 444-465:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(e3,y,y))));;\n                                   ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\n           (sqrt (eval (e3, y, y))));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> (sqrt (eval(e1,x,x))) *.  (sqrt (eval(e2,x,y))) *. (sqrt (eval(e3,y,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyRoot (e1,e2,e3)   -> \n\"sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*sqrt(\"^exprToString e3^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot of expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This expression has type expr/4327\n       but an expression was expected of type expr/3809\nError: This expression has type expr/4495\n       but an expression was expected of type expr/4485\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 551-571:\n  | 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1));;\n                         ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr/4327\n       but an expression was expected of type expr/3809\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckyRoot\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot of expr\n| FunckySine of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckySine (e1,e2,e3)   -> \"sin(\"^exprToString e1^\")*sine(\"^exprToString e2^\")*sin(\"^exprToString e3^\"))\"*"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildY()                       = VarY"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckySine (e1,e2,e3) -> sin (eval(e1,x,x)) *.  sin (eval(e2,x,y)) *. sin (eval(e3,y,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckySine (e1,e2,e3) -> sin (eval(e1,x,x)) *.  sin (eval(e2,x,y)) *. sin (eval(e3,y,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot  of expr\n| DivideByOne of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 440-441:\n  | DivideByOne (e1,e2,e3) -> 1 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) );;\n                              ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 448-460:\n  | DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) );;\n                                      ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) -. eval(e2,x,y) -. eval(e3,x,y) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| DivideByOne (e1,e2,e3)   -> \"(1/(\"^exprToString e1^\"*\"^exprToString e2^\"*\"^exprToString e3^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y))  (1.0 /. eval(e2,x,y))  (1.0 /. eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 444-465:\n  | DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y))  (1.0 /. eval(e2,x,y))  (1.0 /. eval(e3,x,y)));;\n                                  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        ((1.0 /. (eval (e1, x, y))) (1.0 /. (eval (e2, x, y)))\n           (1.0 /. (eval (e3, x, y))));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) + (1.0 /. eval(e2,x,y)) + (1.0 /. eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 444-465:\n  | DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) + (1.0 /. eval(e2,x,y)) + (1.0 /. eval(e3,x,y)));;\n                                  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) + (1.0 /. (eval (e2, x, y)))) +\n           (1.0 /. (eval (e3, x, y))));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt ( 1 /. eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (1.0 /. eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> cos(sqrt (1.0 /. eval(e',x,y)))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> cos(pi *. sqrt (1.0 /. eval(e',x,y)))\n| DivideByOne (e1,e2,e3) -> sin(pi *. (1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot  of expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (abs (eval(e',x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (cos( pi *. (eval(e',x,y))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareCosine  of expr\n| SquareSinCos  of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareCosine e'\t     -> \"sqrt(cos(pi*\"^exprToString e'^\"))\"\n| SquareSinCos (e1,e2,e3)   ->\n\"Sqrt(Sin(Cos(\"^exprToString e1^\")*cos(pi*\"^exprToString e2^\")*cos(pi*\"^exprToString e3^\")))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt (cos( pi *. (eval(e',x,y))))\n| SquareSinCos (e1,e2,e3) -> sqrt(sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This expression has type expr/6967\n       but an expression was expected of type expr/6204\nError: This expression has type expr/7094\n       but an expression was expected of type expr/7085\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 505-527:\n  | 7 -> buildSquareRoot(build(rand, depth-1));;\n                        ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr/6967\n       but an expression was expected of type expr/6204\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))\n| 8 -> buildSquareSinCos(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt (abs_float cos( pi *. (eval(e',x,y))))\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 400-409:\n  | SquareCosine e'\t\t -> sqrt (abs_float cos( pi *. (eval(e',x,y))))\n                               ^^^^^^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float cos (pi *. (eval (e', x, y))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt (abs_float (cos( pi *. (eval(e',x,y))))\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 476-485:\n  | SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))));;\n                                    ^^^^^^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)"}]}
