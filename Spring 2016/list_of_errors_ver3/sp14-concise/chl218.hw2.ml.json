{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = t in\nif List.mem seen' seen\nthen helper (seen, rest')\nelse helper (seen'::seen,rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = t in\n        if List.mem seen' seen\n        then helper (seen, rest')\n        else helper ((seen' :: seen), rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 2)", "out": "", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 1)", "out": "", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = wwhile (f, 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 3)", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 3);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 3)", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 3);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 2)", "out": "Characters 0-6:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 2)", "out": "Characters 0-6:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 3)", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 3);;\n", "type": "scope"}, {"in": "let fixpoint (f,b) =\nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')", "out": "Characters 59-67:\n  else fixpoint (f, b');;\n       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) =\nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')", "out": "", "min": "\nlet rec fixpoint (f,b) =\n  let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec fixpoint (f,b) =\n  let b' = f b in if b' = b then b else fixpoint (f, b');;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b)", "out": "", "min": "\nlet rec fixpoint (f,b) =\n  let b' = f b in if b' = b then b else fixpoint (f, b');;\n\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = \nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b)", "out": "", "min": "\nlet rec fixpoint (f,b) =\n  let b' = f b in if b' = b then b else fixpoint (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec fixpoint (f,b) =\n  let b' = f b in if b' = b then b else fixpoint (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = \nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')", "out": "", "min": "\nlet rec fixpoint (f,b) =\n  let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint_helper f b = \nlet b' = f b in\n(b', b = b')", "out": "", "min": "\nlet fixpoint_helper f b = let b' = f b in (b', (b = b'));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint_helper (fun x -> x+1) 3", "out": "", "min": "\nlet fixpoint_helper f b = let b' = f b in (b', (b = b'));;\n\nlet _ = fixpoint_helper (fun x  -> x + 1) 3;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec fixpoint (f,b) = wwhile (fixpoint_helper f, b)", "out": "Characters 25-31:\n  let rec fixpoint (f,b) = wwhile (fixpoint_helper f, b);;\n                           ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint_helper f b = let b' = f b in (b', (b = b'));;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet rec fixpoint (f,b) =\n  let b' = f b in if b' = b then b else fixpoint (f, b');;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint_helper (fun x -> x-1)", "out": "Characters 0-15:\n  fixpoint_helper (fun x -> x-1);;\n  ^^^^^^^^^^^^^^^\nError: Unbound value fixpoint_helper\n", "min": "\nlet _ = fixpoint_helper (fun x  -> x - 1);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "fixpoint_helper (fun x -> x+1) 3", "out": "Characters 0-15:\n  fixpoint_helper (fun x -> x+1) 3;;\n  ^^^^^^^^^^^^^^^\nError: Unbound value fixpoint_helper\n", "min": "\nlet _ = fixpoint_helper (fun x  -> x + 1) 3;;\n", "type": "scope"}, {"in": "let fixpoint (f,b) = wwhile (fixpoint_helper f, b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (fixpoint_helper f, b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 3)", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 3);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 2)", "out": "Characters 0-6:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = wwhile (f, 2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "wwhile (f, 2)", "out": "Characters 0-6:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet _ = wwhile (f, 2);;\n", "type": "scope"}, {"in": "wwhile (f, 3)", "out": "Characters 0-6:\n  wwhile (f, 3);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet _ = wwhile (f, 3);;\n", "type": "scope"}, {"in": "let fixpoint_helper f b = \nlet b' = f b in\n(b', b = b')", "out": "", "min": "\nlet fixpoint_helper f b = let b' = f b in (b', (b = b'));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (g, 0)", "out": "Characters 0-8:\n  fixpoint (g, 0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (g, 0)", "out": "Characters 0-8:\n  fixpoint (g, 0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "type": "scope"}, {"in": "let temp = fixpoint_helper g", "out": "", "min": "\nlet fixpoint_helper f b = let b' = f b in (b', (b = b'));;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet temp = fixpoint_helper g;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint_helper f b = \nlet b' = f b in\n(b', b != b')", "out": "", "min": "\nlet fixpoint_helper f b = let b' = f b in (b', (b != b'));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "fixpoint (g, 0)", "out": "Characters 0-8:\n  fixpoint (g, 0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "type": "scope"}, {"in": "let temp = fixpoint_helper g", "out": "", "min": "\nlet fixpoint_helper f b = let b' = f b in (b', (b != b'));;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet temp = fixpoint_helper g;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| Varx      -> \"x\"\n| VarY      -> \"y\"\n| Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cos e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "Characters 40-44:\n  | Varx      -> \"x\"\n    ^^^^\nError: Unbound constructor Varx\nHint: Did you mean VarX or VarY?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Varx  -> \"x\"\n  | VarY  -> \"y\"\n  | Sin e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cos e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cos e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "Characters 78-81:\n  | Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n    ^^^\nError: This variant pattern is expected to have type expr\n       The constructor Sin does not belong to type expr\nHint: Did you mean Sine?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sin e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cos e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "Characters 158-172:\n  | Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n    ^^^^^^^^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "Characters 103-107:\n  | Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n                             ^^^^\nError: Unbound value expr\nHint: Did you mean exp?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "Characters 200-212:\n  | Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n                              ^^^^^^^^^^^^\nError: Unbound value esprToString\nHint: Did you mean exprToString?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x'+y')/2", "out": "Characters 88-90:\n  | Average (x', y') -> (x'+y')/2;;\n                         ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x' + y') / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x'+ eval y')/2", "out": "Characters 93-95:\n  | Average (x', y') -> (eval x'+ eval y')/2;;\n                              ^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval x') + (eval y')) / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x' y + eval x y')/2", "out": "Characters 93-95:\n  | Average (x', y') -> (eval x' y + eval x y')/2;;\n                              ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b) * ('a -> 'b)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval x' y) + (eval x y')) / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2", "out": "Characters 93-97:\n  | Average (x', y') -> (eval VarX x' y + eval VarY x y')/2;;\n                              ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval VarX x' y) + (eval VarY x y')) / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2", "out": "Characters 88-106:\n  | Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2;;\n                         ^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval (VarX, x', y)) + (eval (VarY, x, y'))) / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x'+y')/2", "out": "Characters 88-90:\n  | Average (x', y') -> (x'+y')/2;;\n                         ^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x' + y') / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x+y)/2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x + y) / 2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x+y)/2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x + y) / 2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y)/2", "out": "Characters 58-66:\n  | Average (x', y') -> (x +. y)/2;;\n                        ^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y)/2", "out": "Characters 58-66:\n  | Average (x', y') -> (x +. y)/2;;\n                        ^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) / 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2", "out": "Characters 70-71:\n  | Average (x', y') -> (x +. y) /. 2;;\n                                    ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2.0", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin(pi *. eval(e'))\n| Cosine e'\t\t-> cos(pi *. eval(e'))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y", "out": "Characters 64-68:\n  | Sine e'\t\t-> sin(pi *. eval(e'))\n                              ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin (pi *. eval(e'))\n| Cosine e'\t\t-> cos (pi *. eval(e'))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y", "out": "Characters 65-69:\n  | Sine e'\t\t-> sin (pi *. eval(e'))\n                               ^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times   (x', y')\t-> x *. y", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times   (x', y')\t-> x *. y\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = failwith \"to be implemented\"", "out": "", "min": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()\nelse\nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match rand with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()\nelse\nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match rand with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nlet num = rand in\nif depth = 0\nthen \nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()\nelse\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = rand in\n  if depth = 0\n  then match num with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,6) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,6) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Divides  of expr * expr\n| Cubes    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divides of expr* expr\n  | Cubes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Divides  of expr * expr\n| Cubes    of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divides of expr* expr\n  | Cubes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divides of expr* expr\n  | Cubes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot of expr\n| FunckyCube of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt eval(e',x,y)\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e',x,x)) (sqrt eval(e',x,y)) (sqrt eval(e',y,y)))", "out": "Characters 411-421:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e',x,x)) (sqrt eval(e',x,y)) (sqrt eval(e',y,y)));;\n    ^^^^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor FunckyRoot does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt eval (e', x, y)\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot of expr\n| FunckyRoot of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyCube (e1,e2,e3)   -> \n\"sqrt(sqrt(\"^exprToString e1^\")+sqrt(\"^exprToString e2^\")+sqrt(\"^exprToString e3^\"))\"", "out": "Characters 478-488:\n  | FunckyCube (e1,e2,e3)   -> \n    ^^^^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor FunckyCube does not belong to type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckyCube (e1,e2,e3) ->\n      \"sqrt(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")+sqrt(\" ^\n              ((exprToString e2) ^ (\")+sqrt(\" ^ ((exprToString e3) ^ \"))\")))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyRoot (e1,e2,e3)   -> \n\"sqrt(sqrt(\"^exprToString e1^\")+sqrt(\"^exprToString e2^\")+sqrt(\"^exprToString e3^\"))\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckyRoot (e1,e2,e3) ->\n      \"sqrt(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")+sqrt(\" ^\n              ((exprToString e2) ^ (\")+sqrt(\" ^ ((exprToString e3) ^ \"))\")))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e',x,x)) (sqrt eval(e',x,y)) (sqrt eval(e',y,y)))", "out": "Characters 445-449:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e',x,x)) (sqrt eval(e',x,y)) (sqrt eval(e',y,y)));;\n                                    ^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e',x,x))) (sqrt (eval(e',x,y))) (sqrt (eval(e',y,y))))", "out": "Characters 456-458:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e',x,x))) (sqrt (eval(e',x,y))) (sqrt (eval(e',y,y))));;\n                                               ^^\nError: Unbound value e'\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e', x, x))) (sqrt (eval (e', x, y)))\n           (sqrt (eval (e', y, y))));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(ee3,y,y))))", "out": "Characters 444-465:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(ee3,y,y))));;\n                                   ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\n           (sqrt (eval (ee3, y, y))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(e3,y,y))))", "out": "Characters 444-465:\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(e3,y,y))));;\n                                   ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\n           (sqrt (eval (e3, y, y))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> (sqrt (eval(e1,x,x))) *.  (sqrt (eval(e2,x,y))) *. (sqrt (eval(e3,y,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\n        (sqrt (eval (e3, y, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyRoot (e1,e2,e3)   -> \n\"sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*sqrt(\"^exprToString e3^\"))\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckyRoot (e1,e2,e3) ->\n      \"sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*sqrt(\" ^ ((exprToString e3) ^ \"))\")))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckyRoot\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckyRoot\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\n        (sqrt (eval (e3, y, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckyRoot\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckyRoot (e1,e2,e3) ->\n      \"sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*sqrt(\" ^ ((exprToString e3) ^ \"))\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot of expr\n| FunckySine of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckySine (e1,e2,e3)   -> \"sin(\"^exprToString e1^\")*sine(\"^exprToString e2^\")*sin(\"^exprToString e3^\"))\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckySine (e1,e2,e3) ->\n      \"sin(\" ^\n        ((exprToString e1) ^\n           (\")*sine(\" ^\n              ((exprToString e2) ^ (\")*sin(\" ^ ((exprToString e3) ^ \"))\")))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildY()                       = VarY", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet buildY () = VarY;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckySine (e1,e2,e3) -> sin (eval(e1,x,x)) *.  sin (eval(e2,x,y)) *. sin (eval(e3,y,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckySine (e1,e2,e3) ->\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\n        (sin (eval (e3, y, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckySine (e1,e2,e3) -> sin (eval(e1,x,x)) *.  sin (eval(e2,x,y)) *. sin (eval(e3,y,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckySine (e1,e2,e3) ->\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\n        (sin (eval (e3, y, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckySine\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckySine\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckySine\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckySine (e1,e2,e3) ->\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\n        (sin (eval (e3, y, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckySine of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckySine\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckySine (e1,e2,e3) ->\n      \"sin(\" ^\n        ((exprToString e1) ^\n           (\")*sine(\" ^\n              ((exprToString e2) ^ (\")*sin(\" ^ ((exprToString e3) ^ \"))\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot  of expr\n| DivideByOne of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) )", "out": "Characters 448-460:\n  | DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) );;\n                                      ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) -. eval(e2,x,y) -. eval(e3,x,y) )", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) -. (eval (e2, x, y))) -. (eval (e3, x, y)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) -. (eval (e2, x, y))) -. (eval (e3, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDivideByOne (e1,e2,e3) = DivideByOne (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildDivideByOne\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | DivideByOne (e1,e2,e3) ->\n      \"(1/(\" ^\n        ((exprToString e1) ^\n           (\"-\" ^ ((exprToString e2) ^ (\"-\" ^ ((exprToString e3) ^ \"))\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| DivideByOne (e1,e2,e3)   -> \"(1/(\"^exprToString e1^\"*\"^exprToString e2^\"*\"^exprToString e3^\"))\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | DivideByOne (e1,e2,e3) ->\n      \"(1/(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y))  (1.0 /. eval(e2,x,y))  (1.0 /. eval(e3,x,y)))", "out": "Characters 444-465:\n  | DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y))  (1.0 /. eval(e2,x,y))  (1.0 /. eval(e3,x,y)));;\n                                  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        ((1.0 /. (eval (e1, x, y))) (1.0 /. (eval (e2, x, y)))\n           (1.0 /. (eval (e3, x, y))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) + (1.0 /. eval(e2,x,y)) + (1.0 /. eval(e3,x,y)))", "out": "Characters 444-465:\n  | DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) + (1.0 /. eval(e2,x,y)) + (1.0 /. eval(e3,x,y)));;\n                                  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) + (1.0 /. (eval (e2, x, y)))) +\n           (1.0 /. (eval (e3, x, y))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt ( 1 /. eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "out": "Characters 399-400:\n  | SquareRoot e'\t\t -> sqrt ( 1 /. eval(e',x,y))\n                              ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (1 /. (eval (e', x, y)))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (1.0 /. eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (1.0 /. (eval (e', x, y)))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> cos(sqrt (1.0 /. eval(e',x,y)))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> cos (sqrt (1.0 /. (eval (e', x, y))))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> cos (sqrt (1.0 /. (eval (e', x, y))))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDivideByOne (e1,e2,e3) = DivideByOne (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildDivideByOne\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | DivideByOne (e1,e2,e3) ->\n      \"(1/(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> cos(pi *. sqrt (1.0 /. eval(e',x,y)))\n| DivideByOne (e1,e2,e3) -> sin(pi *. (1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> cos (pi *. (sqrt (1.0 /. (eval (e', x, y)))))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((pi *. (1.0 /. (eval (e1, x, y)))) +. (1.0 /. (eval (e2, x, y))))\n           +. (1.0 /. (eval (e3, x, y))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareRoot  of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (eval(e',x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (abs (eval(e',x,y)))", "out": "Characters 402-416:\n  | SquareRoot e'\t\t -> sqrt (abs (eval(e',x,y)));;\n                                 ^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (abs (eval (e', x, y)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt (cos( pi *. (eval(e',x,y))))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (cos (pi *. (eval (e', x, y))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| SquareCosine  of expr\n| SquareSinCos  of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareCosine e'\t     -> \"sqrt(cos(pi*\"^exprToString e'^\"))\"\n| SquareSinCos (e1,e2,e3)   ->\n\"Sqrt(Sin(Cos(\"^exprToString e1^\")*cos(pi*\"^exprToString e2^\")*cos(pi*\"^exprToString e3^\")))\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareCosine e' -> \"sqrt(cos(pi*\" ^ ((exprToString e') ^ \"))\")\n  | SquareSinCos (e1,e2,e3) ->\n      \"Sqrt(Sin(Cos(\" ^\n        ((exprToString e1) ^\n           (\")*cos(pi*\" ^\n              ((exprToString e2) ^\n                 (\")*cos(pi*\" ^ ((exprToString e3) ^ \")))\")))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt (cos( pi *. (eval(e',x,y))))\n| SquareSinCos (e1,e2,e3) -> sqrt(sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (cos (pi *. (eval (e', x, y))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareCosine e = SquareCosine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (cos (pi *. (eval (e', x, y))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareCosine e = SquareCosine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareCosine e' -> \"sqrt(cos(pi*\" ^ ((exprToString e') ^ \"))\")\n  | SquareSinCos (e1,e2,e3) ->\n      \"Sqrt(Sin(Cos(\" ^\n        ((exprToString e1) ^\n           (\")*cos(pi*\" ^\n              ((exprToString e2) ^\n                 (\")*cos(pi*\" ^ ((exprToString e3) ^ \")))\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))\n| 8 -> buildSquareSinCos(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareCosine e = SquareCosine e;;\n\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\n     | 8 ->\n         buildSquareSinCos\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (cos (pi *. (eval (e', x, y))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareCosine e = SquareCosine e;;\n\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\n     | 8 ->\n         buildSquareSinCos\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareCosine e' -> \"sqrt(cos(pi*\" ^ ((exprToString e') ^ \"))\")\n  | SquareSinCos (e1,e2,e3) ->\n      \"Sqrt(Sin(Cos(\" ^\n        ((exprToString e1) ^\n           (\")*cos(pi*\" ^\n              ((exprToString e2) ^\n                 (\")*cos(pi*\" ^ ((exprToString e3) ^ \")))\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt (abs_float cos( pi *. (eval(e',x,y))))\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "out": "Characters 400-409:\n  | SquareCosine e'\t\t -> sqrt (abs_float cos( pi *. (eval(e',x,y))))\n                               ^^^^^^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float cos (pi *. (eval (e', x, y))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float(cos(pi *. (eval(e',x,y)))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "out": "Characters 474-483:\n  | SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))));;\n                                    ^^^^^^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "out": "Characters 476-485:\n  | SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))));;\n                                    ^^^^^^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float\n           (sin\n              (((cos (pi *. (eval (e1, x, y)))) *.\n                  (cos (pi *. (eval (e2, x, y)))))\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float\n           (sin\n              (((cos (pi *. (eval (e1, x, y)))) *.\n                  (cos (pi *. (eval (e2, x, y)))))\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float\n           (sin\n              (((cos (pi *. (eval (e1, x, y)))) *.\n                  (cos (pi *. (eval (e2, x, y)))))\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float\n           (sin\n              (((cos (pi *. (eval (e1, x, y)))) *.\n                  (cos (pi *. (eval (e2, x, y)))))\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareCosine e = SquareCosine e;;\n\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\n     | 8 ->\n         buildSquareSinCos\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareCosine e' -> \"sqrt(cos(pi*\" ^ ((exprToString e') ^ \"))\")\n  | SquareSinCos (e1,e2,e3) ->\n      \"Sqrt(Sin(Cos(\" ^\n        ((exprToString e1) ^\n           (\")*cos(pi*\" ^\n              ((exprToString e2) ^\n                 (\")*cos(pi*\" ^ ((exprToString e3) ^ \")))\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| []    ->    d\n| h::t  ->\nlet (ki, vi) = h in\nif k = ki\nthen vi\nelse assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\n", "type": ""}]}
