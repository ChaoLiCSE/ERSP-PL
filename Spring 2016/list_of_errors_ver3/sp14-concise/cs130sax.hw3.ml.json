{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = base + xs**2 in\nList.fold_left f base xs", "out": "Characters 71-75:\n  let base = base + xs**2 in\n             ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = base + (xs ** 2) in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = base**2 in\nlet base = base+a in\nList.fold_left f base xs", "out": "Characters 28-32:\n  let f a x = base**2 in\n              ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = base ** 2 in let base = base + a in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = base**2 in\nlet base = a in\nList.fold_left f base xs", "out": "Characters 28-32:\n  let f a x = base**2 in\n              ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = base ** 2 in let base = a in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a**2 in\nlet base = a in\nList.fold_left f base xs", "out": "Characters 31-32:\n  let f a x = a**2 in\n                 ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs = let f a x = a ** 2 in let base = a in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = int a**2 in\nlet base = a in\nList.fold_left f base xs", "out": "Characters 28-31:\n  let f a x = int a**2 in\n              ^^^\nError: Unbound value int\n", "min": "\nlet sqsum xs =\n  let f a x = (int a) ** 2 in let base = a in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+base in\nlet base = a in\nList.fold_left f base xs", "out": "Characters 30-34:\n  let f a x = a+base in\n                ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a + base in let base = a in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a in\nlet base = a in\nList.fold_left f base xs", "out": "Characters 44-45:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet sqsum xs = let f a x = a in let base = a in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = a in\nList.fold_left f base xs", "out": "Characters 46-47:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet sqsum xs = let f a x = (+) in let base = a in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = base + f a x in\nList.fold_left f base xs", "out": "Characters 46-50:\n  let base = base + f a x in\n             ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = base + (f a x) in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = f a x in\nList.fold_left f base xs", "out": "Characters 48-49:\n  let base = f a x in\n               ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = f a x in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = base in\nList.fold_left f base xs", "out": "Characters 46-50:\n  let base = base in\n             ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs = let f a x = (+) in let base = base in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = a ** 2 in\nList.fold_left f base xs", "out": "Characters 46-47:\n  let base = a ** 2 in\n             ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = a ** 2 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = 3**2 in\nList.fold_left f base xs", "out": "Characters 46-47:\n  let base = 3**2 in\n             ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = 3 ** 2 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = 2 in\nList.fold_left f base xs", "out": "Characters 68-72:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "min": "\nlet sqsum xs = let f a x = (+) in let base = 2 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = base + 1 in\nList.fold_left f base xs", "out": "Characters 46-50:\n  let base = base + 1 in\n             ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = base + 1 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+) in\nlet base = 0 in\nList.fold_left f base xs", "out": "Characters 68-72:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "min": "\nlet sqsum xs = let f a x = (+) in let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = base + a**2\nin\nList.fold_left f base xs", "out": "Characters 46-50:\n  let base = base + a**2\n             ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = base + (a ** 2) in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = a**2\nin\nList.fold_left f base xs", "out": "Characters 46-47:\n  let base = a**2\n             ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = a ** 2 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f a**2 x\nin\nList.fold_left f base xs", "out": "Characters 48-49:\n  let base = f a**2 x\n               ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = (f a) ** (2 x) in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 x\nin\nList.fold_left f base xs", "out": "Characters 50-51:\n  let base = f 2 x\n                 ^\nError: Unbound value x\n", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = f 2 x in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (+) in let base = f 2 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a**2 in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "Characters 31-32:\n  let f a x = a**2 in\n                 ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs =\n  let f a x = a ** 2 in let base = f 2 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + base in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "Characters 32-36:\n  let f a x = a + base in\n                  ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a + base in let base = f 2 xs in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = a in let base = f 0 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 2 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = []\nin\nList.fold_left f base xs", "out": "Characters 69-73:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs = let f a x = a * a in let base = [] in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> []\n| x::xs' -> f x xs'\nin\nList.fold_left f base xs", "out": "Characters 84-91:\n  | x::xs' -> f x xs'\n              ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> [] | x::xs' -> f x xs' in\n  List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 2 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "Characters 78-80:\n  List.fold_left f base xs;;\n                        ^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet sqsum xs =\n  let f a x = x * x in let base = f 2 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs = let f a x = a * a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 4 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd + f a tl\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "Characters 64-65:\n  | hd::tl -> hd * hd + f a tl\n                        ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | hd::tl -> (hd * hd) + (f a tl) in\n  let base = f 4 xs in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd + (f a tl)\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "Characters 65-66:\n  | hd::tl -> hd * hd + (f a tl)\n                         ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | hd::tl -> (hd * hd) + (f a tl) in\n  let base = f 4 xs in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "Characters 108-110:\n  List.fold_left f base xs;;\n                        ^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet sqsum xs =\n  let f a x = match x with | hd::tl -> hd * hd in\n  let base = f 4 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 4 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "Characters 82-84:\n  List.fold_left f base xs;;\n                        ^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "Characters 82-84:\n  List.fold_left f base xs;;\n                        ^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f a xs\nin\nList.fold_left f base xs", "out": "Characters 48-49:\n  let base = f a xs\n               ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f a xs in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f base xs\nin\nList.fold_left f base xs", "out": "Characters 48-52:\n  let base = f base xs\n               ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f base xs in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f (f a xs) xs\nin\nList.fold_left f base xs", "out": "Characters 51-52:\n  let base = f (f a xs) xs\n                  ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f (f a xs) xs in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f (f 0 xs) xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f (f 0 xs) xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f (f 4 xs) xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f (f 4 xs) xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 4 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 thing\nin\nList.fold_left f base xs", "out": "Characters 50-55:\n  let base = f 4 thing\n                 ^^^^^\nError: Unbound value thing\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 4 thing in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 4 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "Characters 82-84:\n  List.fold_left f base xs;;\n                        ^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = base + f 4 xs\nin\nList.fold_left f base xs", "out": "Characters 46-50:\n  let base = base + f 4 xs\n             ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = base + (f 4 xs) in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f base xs\nin\nList.fold_left f base xs", "out": "Characters 48-52:\n  let base = f base xs\n               ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f base xs in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f xs xs\nin\nList.fold_left f base xs", "out": "Characters 79-81:\n  List.fold_left f base xs;;\n                        ^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 8 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> base\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs", "out": "Characters 69-73:\n  | [] -> base\n          ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> base | hd::tl -> f (f base hd) tl in\n  List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs", "out": "Characters 88-92:\n  | hd::tl -> f (f base hd) tl\n                   ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 0 | hd::tl -> f (f base hd) tl in\n  List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f 0 hd) tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 0 | hd::tl -> f (f 0 hd) tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 4\n| hd::tl -> f (f 2 hd) tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 4 | hd::tl -> f (f 2 hd) tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  \nmatch xs with\n| [] -> a\n| hd::tl -> f (f a hd) tl in\nlet base = 0\nin\nList.fold_left f base xs", "out": "Characters 66-67:\n  | hd::tl -> f (f a hd) tl in\n              ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> f (f a hd) tl in\n  let base = 0 in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet rec f a x =  \nmatch xs with\n| [] -> a\n| hd::tl -> f (f a hd) tl in\nlet base = 0\nin\nList.fold_left f base xs", "out": "Characters 81-83:\n  | hd::tl -> f (f a hd) tl in\n                         ^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet sqsum xs =\n  let rec f a x = match xs with | [] -> a | hd::tl -> f (f a hd) tl in\n  let base = 0 in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 4\n| hd::tl -> f (f 2 hd) tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 4 | hd::tl -> f (f 2 hd) tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 4\n| hd::tl -> f (f 3 hd) tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 4 | hd::tl -> f (f 3 hd) tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = base\nin\nList.fold_left f base xs", "out": "Characters 46-50:\n  let base = base\n             ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = base in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 2 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = (+)a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "out": "Characters 28-32:\n  let f a x = (+)a*a in\n              ^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs =\n  let f a x = ((+) a) * a in let base = f 2 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 9 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 9 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs", "out": "Characters 93-97:\n  | hd::tl -> f (f base hd) tl\n                   ^^^^\nError: Unbound value base\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> f 0 xs | hd::tl -> f (f base hd) tl in\n  List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f a hd) tl\nin\nList.fold_left f base xs", "out": "Characters 93-94:\n  | hd::tl -> f (f a hd) tl\n                   ^\nError: Unbound value a\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> f 0 xs | hd::tl -> f (f a hd) tl in\n  List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> f 0 xs | hd::tl -> f (f hd hd) tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 9 xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> f 9 xs | hd::tl -> f (f hd hd) tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs", "out": "Characters 84-98:\n  | hd::tl -> f (f hd hd) tl\n              ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> xs | hd::tl -> f (f hd hd) tl in\n  List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | hd::tl -> f (f hd hd) tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd + f tl tl\nin\nList.fold_left f base xs", "out": "Characters 85-87:\n  | hd::tl -> f hd hd + f tl tl\n                          ^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | hd::tl -> (f hd hd) + (f tl tl) in\n  List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd + f (f hd hd) tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | hd::tl -> (f hd hd) + (f (f hd hd) tl) in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | hd::tl -> f hd hd in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f hd hd\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 0 | hd::tl -> f hd hd in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f hd tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 0 | hd::tl -> f hd tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f hd tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (a * a) in\n  let base = match xs with | [] -> 0 | hd::tl -> f hd tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f hd tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 0 | hd::tl -> f hd tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 8\n| hd::tl -> f hd tl\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 8 | hd::tl -> f hd tl in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> f hd tl in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "out": "Characters 64-65:\n  | hd::tl -> f hd tl in\n              ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> f hd tl in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> hd*hd in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> hd * hd in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = []\nin\nList.fold_left f base xs", "out": "Characters 112-116:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = [] in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = f 4 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch x with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "out": "Characters 120-122:\n  List.fold_left f base xs;;\n                        ^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + x*x in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "out": "Characters 91-93:\n  let base = f 0 xs\n                 ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (x * x) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "out": "Characters 87-93:\n  | hd::tl -> f 0 hd\n              ^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> [] | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "out": "Characters 77-79:\n  | [] -> f 0 []\n              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> f 0 [] | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> f 0 0 | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> -1\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> (-1) | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f -1 hd\nin\nList.fold_left f base xs", "out": "Characters 87-88:\n  | hd::tl -> f -1 hd\n              ^\nError: This expression has type int -> int -> int\n       but an expression was expected of type int\n", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f - (1 hd) in\n  List.fold_left f base xs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\n(*match xs with\n| [] -> 0\n| hd::tl -> f 0 hd*)\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 0\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base = 0\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = 0\nin\nList.fold_left f base fs", "out": "Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = x\nin\nList.fold_left f base fs", "out": "Characters 54-55:\n  let base = x\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x x = a x in let base = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "Characters 83-84:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> 0\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base x = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "Characters 81-82:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "min": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "Characters 83-84:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = x\nin\nList.fold_left f base fs", "out": "Characters 54-55:\n  let base = x\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x x = a x in let base = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> a\nin\nList.fold_left f base fs", "out": "Characters 63-64:\n  let base = fun x -> a\n                      ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x x = a x in let base x = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> 0\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base x = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a (x) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y ->  y a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "Characters 86-87:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x y = y a x in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y ->  a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x y = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y ->  a (y x) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "Characters 88-89:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n", "min": "\nlet pipe fs =\n  let f a x y = a (y x) in let base x = x in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x k a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x k = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x k a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x k(f a k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "Characters 40-41:\n  let f a x = fun k -> x k(f a k) in\n                           ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x k = x k (f a k) in let base x = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x k(k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x k k in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x k a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x k = x a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x k = a x in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x k = a x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x x = a x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x k = a x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> a k(x) in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "Characters 86-87:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b -> 'c) -> 'b -> 'a -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) -> 'b -> 'a -> 'b -> 'c\n       The type variable 'c occurs inside 'b -> 'c\n", "min": "\nlet pipe fs =\n  let f a x k = a k x in let base y = y in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x k = a x in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = \nmatch sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = \nmatch sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = \nmatch sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = \nmatch sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nList.map f l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> a x k in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "Characters 85-86:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x k = a x k in let base y = y in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x a k in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x a k in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x a (k) in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x a k in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x a (k) in\nlet base = fun y -> x\nin\nList.fold_left f base fs", "out": "Characters 67-68:\n  let base = fun y -> x\n                      ^\nError: Unbound value x\n", "min": "\nlet pipe fs =\n  let f a x k = x a k in let base y = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x a (k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x a k in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x k a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x k a in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x a k in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x a k in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x k a in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x k a in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x (k a) in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "Characters 87-88:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x k = x (k a) in let base y = y in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun k -> x (a k) in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x k = x (a k) in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n > 0 with\n| true -> x::(clone x n-1)\n| false -> x", "out": "Characters 51-60:\n  | true -> x::(clone x n-1)\n                ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: ((clone x n) - 1) | false  -> x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n > 0 with\n| true -> x::(clone x n-1)\n| false -> x::[]", "out": "Characters 51-60:\n  | true -> x::(clone x n-1)\n                ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: ((clone x n) - 1) | false  -> [x];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n > 0 with\n| true -> x @ clone x n-1\n| false -> x @ []", "out": "Characters 51-62:\n  | true -> x @ clone x n-1\n                ^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x @ ((clone x n) - 1) | false  -> x @ [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n > 0 with\n| true -> x @ clone x n-1\n| false -> []", "out": "Characters 51-62:\n  | true -> x @ clone x n-1\n                ^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x @ ((clone x n) - 1) | false  -> [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n = 0 with\n| true -> x\n| false -> x @ clone x n-1", "out": "Characters 64-73:\n  | false -> x @ clone x n-1;;\n                 ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> x | false  -> x @ ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n = 0 with\n| true -> (x)\n| false -> (x) @ (clone x n-1)", "out": "Characters 69-78:\n  | false -> (x) @ (clone x n-1);;\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> x | false  -> x @ ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) @ (clone x n-1)", "out": "Characters 68-77:\n  | false -> (x) @ (clone x n-1);;\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x @ ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) :: (clone x n-1)", "out": "Characters 69-78:\n  | false -> (x) :: (clone x n-1);;\n                     ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) @ (clone x n-1)", "out": "Characters 68-77:\n  | false -> (x) @ (clone x n-1);;\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x @ ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) :: (clone x n-1)", "out": "Characters 69-78:\n  | false -> (x) :: (clone x n-1);;\n                     ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x n-1)", "out": "Characters 71-80:\n  | false -> (x) :: (clone x n-1);;\n                     ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "out": "", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: clone x (n-1)", "out": "", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet rec clonehelper x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: clonehelper x (n-1)\nin\nclonehelper x n", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper x n =\n    match n = 0 with | true  -> [] | false  -> x :: (clonehelper x (n - 1)) in\n  clonehelper x n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: clone x (n-1)", "out": "", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> x :: clone x (n-1)", "out": "", "min": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> tx :: clone tx (tn - 1)\nin\nclonehelper x abs(n)", "out": "Characters 119-130:\n  clonehelper x abs(n);;\n  ^^^^^^^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with | true  -> [] | false  -> tx :: (clone tx (tn - 1)) in\n  clonehelper x abs n;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> tx :: clonehelper tx (tn - 1)\nin\nclonehelper x abs(n)", "out": "Characters 125-136:\n  clonehelper x abs(n);;\n  ^^^^^^^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x abs n;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> tx :: clonehelper tx (tn - 1)\nin\nclonehelper x (abs n)", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "out": "Characters 155-201:\n  clone 0 (List.length l2 - List.length l1) @ l1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\n(clone 0 (List.length l1 - List.length l2)) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "out": "Characters 157-203:\n  clone 0 (List.length l2 - List.length l1) @ l1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\n(clone 0 (List.length l1 - List.length l2)) @ l2\nelse if (List.length l1 < List.length l2) then\n(clone 0 (List.length l2 - List.length l1)) @ l1", "out": "Characters 157-205:\n  (clone 0 (List.length l2 - List.length l1)) @ l1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "out": "Characters 155-201:\n  clone 0 (List.length l2 - List.length l1) @ l1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "out": "Characters 155-201:\n  clone 0 (List.length l2 - List.length l1) @ l1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::(clone 0 (List.length l1 - List.length l2) @ l2)\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "out": "Characters 65-113:\n  l1::(clone 0 (List.length l1 - List.length l2) @ l2)\n      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::(clone 0 (List.length l1 - List.length l2) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::(clone 0 (List.length l2 - List.length l1) @ l1)", "out": "Characters 65-113:\n  l1::(clone 0 (List.length l1 - List.length l2) @ l2)\n      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ l1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ l1)", "out": "Characters 65-115:\n  l1::((clone 0 (List.length l1 - List.length l2)) @ l2)\n      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ l1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ l1)", "out": "Characters 65-115:\n  l1::((clone 0 (List.length l1 - List.length l2)) @ l2)\n      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ l1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ [l2])\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ [l1])", "out": "Characters 113-115:\n  l1::((clone 0 (List.length l1 - List.length l2)) @ [l2])\n                                                      ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::(clone 0 (List.length l1 - List.length l2) @ [l2])\nelse if (List.length l1 < List.length l2) then\nl2::(clone 0 (List.length l2 - List.length l1) @ [l1])", "out": "Characters 111-113:\n  l1::(clone 0 (List.length l1 - List.length l2) @ [l2])\n                                                    ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ [l2])\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ [l1])", "out": "Characters 113-115:\n  l1::((clone 0 (List.length l1 - List.length l2)) @ [l2])\n                                                      ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ [l2])\nelse if (List.length l1 < List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2", "out": "Characters 113-115:\n  l1::((clone 0 (List.length l1 - List.length l2)) @ [l2])\n                                                      ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1@[(clone 0 (List.length l1 - List.length l2)) @ [l2]]\nelse if (List.length l1 < List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2", "out": "Characters 112-114:\n  l1@[(clone 0 (List.length l1 - List.length l2)) @ [l2]]\n                                                     ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 @ [(clone 0 ((List.length l1) - (List.length l2))) @ [l2]]\n  else\n    if (List.length l1) < (List.length l2)\n    then ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> l1::((clone 0 (List.length l1 - List.length l2)) @ l2)\n| false -> ((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2", "out": "Characters 77-127:\n  | true -> l1::((clone 0 (List.length l1 - List.length l2)) @ l2)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  | false  -> ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)", "out": "Characters 189-191:\n  | false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2);;\n                                                              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ [l1]), l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)", "out": "Characters 189-191:\n  | false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2);;\n                                                              ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ [l1]), l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ l1),l2)", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ l1),l2)", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l =\nlet rec removeZH templ =\nmatch templ with\n| [] -> []\n| hd::tl -> \nif (hd = 0) then\nremoveZH tl\nelse\nhd::removeZH tl\nin\nremoveZH l", "out": "", "min": "\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: (removeZH tl) in\n  removeZH l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l =\nlet rec removeZH templ =\nmatch templ with\n| [] -> []\n| hd::tl -> \nif (hd = 0) then\nremoveZH tl\nelse\nhd::tl\nin\nremoveZH l", "out": "", "min": "\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l =\nlet rec removeZH templ =\nmatch templ with\n| [] -> []\n| hd::tl -> \nif (hd = 0) then removeZH tl\nelse hd::tl\nin\nremoveZH l", "out": "", "min": "\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 127-131:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 109-135:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 112-138:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [0] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 131-135:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [0] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 9 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 112-138:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 9 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 112-138:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 136-140:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 136-140:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 137-141:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([],[]) in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 144-148:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([], []) in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 134-138:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = () in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl -> (hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with | [] -> [] | hd::tl -> (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i/10 != 0) then\n(hd*i%10)::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 114-115:\n  (hd*i%10)::(hd*i/10 + mBDhelper i tl)\n       ^\nError: Unbound value %\n", "min": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) % 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i/10 != 0) then\n(hd*i mod 10)::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 135-149:\n  (hd*i mod 10)::(hd*i/10 + mBDhelper i tl)\n                            ^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) mod 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i/10 != 0) then\nhd*i mod 10::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 133-147:\n  hd*i mod 10::(hd*i/10 + mBDhelper i tl)\n                          ^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) mod 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> 0\n| hd::tl ->\nif (hd*i/10 != 0) then\n(hd*i mod 10)::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 108-149:\n  (hd*i mod 10)::(hd*i/10 + mBDhelper i tl)\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> 0\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) mod 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(hd*i mod 10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 134-148:\n  (hd*i/10)::(hd*i mod 10 + mBDhelper i tl)\n                            ^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (((hd * i) mod 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a (hd::tl) =\na + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 151-188:\n  (hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  let comb a (hd::tl) = a + hd in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> a\n| hd::tl -> a + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 179-216:\n  (hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> a | hd::tl -> a + hd in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> (a)\n| hd::tl -> (a + hd)\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 183-220:\n  (hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> a | hd::tl -> a + hd in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]::tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 79-80:\n  | hd::tl -> [a + hd]::tl\n               ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] :: tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]::[tl]\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 79-80:\n  | hd::tl -> [a + hd]::[tl]\n               ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [[a + hd]; tl] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]@[tl]\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "Characters 88-90:\n  | hd::tl -> [a + hd]@[tl]\n                        ^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] @ [tl] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]@tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] @ tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 135-139:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = () in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) ->\nlet new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) ->\nlet new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\n(*removeZero (add (padZero l1 l2))*)\nadd(padZero l1 l2)", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch a with\n| (carry, acc) -> carry\nin\nmatch x with\n| (addend_a,addend_b) ->\nlet new_carry = (carry + addend_a + addend_b) / 10 in\nlet digit = (carry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,acc) -> (new_carry, digit::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "Characters 96-97:\n  match x with\n        ^\nError: Unbound value x\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet _ =\n  let bigAdd l1 l2 =\n    let add (l1,l2) =\n      let f a x = match a with | (carry,acc) -> carry in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,acc) -> (new_carry, (digit :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\n(*let carry =\nmatch a with\n| (x, y) -> x\nin*)\nmatch x with\n| (addend_a,addend_b) ->\nlet new_carry = (carry + addend_a + addend_b) / 10 in\nlet digit = (carry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (carry,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "Characters 106-111:\n  let new_carry = (carry + addend_a + addend_b) / 10 in\n                   ^^^^^\nError: Unbound value carry\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (carry,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\n(*let carry =\nmatch a with\n| (x, y) -> x\nin*)\nmatch x with\n| (addend_a,addend_b) ->\nlet carry = match a with\n| (x,y) -> x\nin\nlet new_carry = (carry + addend_a + addend_b) / 10 in\nlet digit = (carry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let carry = match a with | (x,y) -> x in\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x,y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,y) -> \nif ((x,y)=(0,[])) then \n(new_carry, (prevcarry + addend_a + addend_b)::y)\nelse (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,y) ->\n               if (x, y) = (0, [])\n               then (new_carry, (((prevcarry + addend_a) + addend_b) :: y))\n               else (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x,y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,y) -> \nif ((x,y)=(0,[])) then \n(new_carry, new_carry::digit::y)\nelse (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,y) ->\n               if (x, y) = (0, [])\n               then (new_carry, (new_carry :: digit :: y))\n               else (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x,y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,y) -> \nif ((x,y)=(0,[])) then \n(new_carry, digit::new_carry::y)\nelse (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,y) ->\n               if (x, y) = (0, [])\n               then (new_carry, (digit :: new_carry :: y))\n               else (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x,y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,y) -> \nif ((x,y)=(0,[])) then \n(new_carry, digit::y)\nelse (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,y) ->\n               if (x, y) = (0, [])\n               then (new_carry, (digit :: y))\n               else (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x,hd::tl) -> x-hd in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,hd::tl) -> x - hd in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, []) -> x\n| (x,hd::tl) -> x-hd in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,[]) -> x | (x,hd::tl) -> x - hd in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::digit) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "Characters 297-302:\n  | (x,[]) -> (new_carry, new_carry::digit) \n                                     ^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, (new_carry :: digit))\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::(digit)) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "Characters 297-304:\n  | (x,[]) -> (new_carry, new_carry::(digit)) \n                                     ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, (new_carry :: digit))\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::digit) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "Characters 297-302:\n  | (x,[]) -> (new_carry, new_carry::digit) \n                                     ^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, (new_carry :: digit))\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::[digit]) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, [new_carry; digit])\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| _ -> (new_carry, new_carry::[digit])\n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | _ -> (new_carry, [new_carry; digit])\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) \n| _ -> (new_carry, new_carry::[digit]) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\n(*| _ -> (new_carry, new_carry::[digit]) in*)\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y)\n| _ -> (new_carry, new_carry::[digit]) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]@tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] @ tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> List.append [a + hd] tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,List.append((clone 0 (List.length l1 - List.length l2)) l2))\n| false -> ((List.append(clone 0 (List.length l2 - List.length l1)) l1),l2)", "out": "Characters 89-132:\n  | true -> (l1,List.append((clone 0 (List.length l1 - List.length l2)) l2))\n                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1,\n        (List.append ((clone 0 ((List.length l1) - (List.length l2))) l2)))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,(List.append (clone 0 (List.length l1 - List.length l2)) l2))\n| false -> ((List.append(clone 0 (List.length l2 - List.length l1)) l1),l2)", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l =\nlet rec removeZH templ =\nmatch templ with\n| [] -> []\n| hd::tl -> \nif (hd = 0) then removeZH tl\nelse hd::tl\nin\nremoveZH l", "out": "", "min": "\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 146-152:\n  | hd::tl -> List.append (x,hd) (argmaker x tl)\n                          ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,[hd]) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 146-154:\n  | hd::tl -> List.append (x,[hd]) (argmaker x tl)\n                          ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, [hd]) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,0)\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 145-151:\n  | hd::tl -> List.append (x,hd) (argmaker x tl)\n                          ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, 0)\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 146-152:\n  | hd::tl -> List.append (x,hd) (argmaker x tl)\n                          ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append ((x,hd)) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 146-154:\n  | hd::tl -> List.append ((x,hd)) (argmaker x tl)\n                          ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then (x,hd) \nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 149-172:\n  else (x,hd)::(argmaker x tl)\n       ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then (x, hd) else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd) ]\nelse (x,hd)@(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 151-157:\n  else (x,hd)@(argmaker x tl)\n       ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) @ (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd) ]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = List.combine a x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 239-240:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type 'a list -> 'b list -> 'a list\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = List.combine a x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = a::x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 227-228:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = a :: x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> List.append [a + hd] tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (templ1,l2digit) ->\nlet multres = \nmulByDigit l2digit templ1 in\nbigAdd (a::[0]) multres\nin\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 336-337:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int list * int -> int list\n       but an expression was expected of type int -> int list * int -> int\n       Type int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd [a; 0] multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (templ1,l2digit) ->\nlet multres = \nmulByDigit l2digit templ1\nin\nbigAdd (a::(0)) multres\nin\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 122-125:\n  bigAdd (a::(0)) multres\n             ^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a :: 0) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (templ1,l2digit) ->\nlet multres = \nmulByDigit l2digit templ1\nin\nbigAdd (a@[0]) multres\nin\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 337-341:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a @ [0]) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (templ1,l2digit) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a::[0]) multres)\nin\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 340-341:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int list * int -> int * int list\n       but an expression was expected of type int -> int list * int -> int\n       Type int * int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (templ1,l2digit) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a::[0]) multres)\nin\nlet base = ([0], []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 342-343:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int list * int -> int * int list\n       but an expression was expected of type int -> int list * int -> int\n       Type int * int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = ([0], []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a::[0]) multres)\nin\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [(hd),x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 340-341:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int * int list -> int * int list\n       but an expression was expected of type int -> int * int list -> int\n       Type int * int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a::[0]) multres)\nin\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 338-339:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int * int list -> int * int list\n       but an expression was expected of type int -> int * int list -> int\n       Type int * int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,(bigAdd (a::[0]) multres))\nin\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 340-341:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int * int list -> int * int list\n       but an expression was expected of type int -> int * int list -> int\n       Type int * int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a::[0]) multres)\nin\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 338-339:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int * int list -> int * int list\n       but an expression was expected of type int -> int * int list -> int\n       Type int * int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a@[0]) multres) in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 337-338:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list -> int * int list -> int * int list\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int * int list is not compatible with type int list \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (a @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\nbigAdd (a@[0]) multres in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 335-339:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a @ [0]) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a@[0]) multres) in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 337-338:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list -> int * int list -> int * int list\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int * int list is not compatible with type int list \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (a @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a@[0]) multres) in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 337-338:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list -> int * int list -> int * int list\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int * int list is not compatible with type int list \n", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (a @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = \nmatch sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nList.map f l", "out": "", "min": "\nlet stringOfList f l = List.map f l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nsepConcat \"\" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\nList.map f (sepConcat \"\" l)", "out": "Characters 34-50:\n  List.map f (sepConcat \"\" l);;\n             ^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l =\n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> \nif (tn < 0) then []\nelse tx :: clonehelper tx (tn - 1)\nin\nclonehelper x (abs n)", "out": "", "min": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> if tn < 0 then [] else tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nif (n<0 or n = 0) then []\nelse\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> tx :: clonehelper tx (tn - 1)\nin\nclonehelper x (abs n)", "out": "", "min": "\nlet rec clone x n =\n  if (n < 0) or (n = 0)\n  then []\n  else\n    (let rec clonehelper tx tn =\n       match tn = 0 with\n       | true  -> []\n       | false  -> tx :: (clonehelper tx (tn - 1)) in\n     clonehelper x (abs n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n =\nif (n<0 || n = 0) then []\nelse\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> tx :: clonehelper tx (tn - 1)\nin\nclonehelper x (abs n)", "out": "", "min": "\nlet rec clone x n =\n  if (n < 0) || (n = 0)\n  then []\n  else\n    (let rec clonehelper tx tn =\n       match tn = 0 with\n       | true  -> []\n       | false  -> tx :: (clonehelper tx (tn - 1)) in\n     clonehelper x (abs n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
