{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList (tl xs));;\n", "out": "Characters 66-68:\n  let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n                                                                    ^^\nError: Unbound value tl\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList List.tl xs);;\n", "out": "Characters 57-64:\n  let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs;;\n                                                           ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else (match n with | f::b -> f);;\n", "out": "Characters 57-61:\n  let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f;;\n                                                           ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n", "out": "Characters 56-69:\n  let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10;;\n                                                          ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10)", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n", "out": "Characters 57-70:\n  let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10);;\n                                                           ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else (n mod 10) :: (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n*10))", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n * 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10))", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10)))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n=0 then [0] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10))))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10))", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = let x = (digits n) in persistenceHelper x", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n = let x = digits n in persistenceHelper x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec adder a = if (sumList a)<10 then (sumList a) else adder (digit (sumList a))", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digit (sumList a));;\n", "out": "Error: Unbound value digit\nHint: Did you mean digits?\nError: Unbound value digit\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 65-70:\n  let rec adder a = if (sumList a)<10 then (sumList a) else adder (digit (sumList a));;\n                                                                   ^^^^^\nError: Unbound value digit\nHint: Did you mean digits?\n"}, {"type": "scope", "in": "let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n", "out": "Characters 68-73:\n  let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x;;\n                                                                      ^^^^^\nError: Unbound value adder\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n", "out": ""}]}
