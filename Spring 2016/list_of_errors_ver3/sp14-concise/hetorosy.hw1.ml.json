{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 66-68:\n  let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n                                                                    ^^\nError: Unbound value tl\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList (tl xs));;\n", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-64:\n  let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs;;\n                                                           ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList List.tl xs);;\n", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-61:\n  let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f;;\n                                                           ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else (match n with | f::b -> f);;\n", "in": "let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-69:\n  let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10;;\n                                                          ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-70:\n  let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10);;\n                                                           ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n*10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n=0 then [0] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = let x = (digits n) in persistenceHelper x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value digit\nHint: Did you mean digits?\nError: Unbound value digit\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 65-70:\n  let rec adder a = if (sumList a)<10 then (sumList a) else adder (digit (sumList a));;\n                                                                   ^^^^^\nError: Unbound value digit\nHint: Did you mean digits?\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digit (sumList a));;\n", "in": "let rec adder a = if (sumList a)<10 then (sumList a) else adder (digit (sumList a))"}, {"type": "scope", "out": "Characters 68-73:\n  let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x;;\n                                                                      ^^^^^\nError: Unbound value adder\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n", "in": "let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)"}]}
