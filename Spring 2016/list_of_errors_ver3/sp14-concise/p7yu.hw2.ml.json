{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> \nmatch h with \n| (s,n) -> \nif s = k then n else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> \nmatch h with \n| (s,n) -> \nif s = k then n else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-70:\n  let halff = rand(0,2) in\n              ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-70:\n  let halff = rand(0,2) in\n              ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-95:\n  if halff = 0 then  buildY()\n             ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = makeRand (0, 2) in\n      if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 66-67:\n  let halff = r = makeRand(0,2) in\n              ^\nError: Unbound value r\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = r = (makeRand (0, 2)) in\n      if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 136-140:\n  let halff = rand(0,2) in\n              ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 -> let halff = rand in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-70:\n  let halff = rand(0,2) in\n              ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-70:\n  let halff = rand(0,2) in\n              ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-70:\n  let halff = rand(0,2) in\n              ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 161-162:\n  if halff = 0 then Cosine(build(rand, depth-1)) \n             ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,4) in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,4) in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-87:\n  let halff = rand(0,2) in\n              ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand in\n  match rdm with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-87:\n  let halff = rand(0,2) in\n              ^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand in\n  match rdm with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-73:\n  let rdm = rand(0,7) in\n            ^^^^\nError: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | (a,b) ->\n      let rdm = rand (0, 7) in\n      (match rdm with\n       | 0 -> buildY ()\n       | 1 -> buildX ()\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 -> Sine (build (rand, (depth - 1)))\n       | 4 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with \n| (a,b) -> \nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-73:\n  let rdm = rand(a,b) in\n            ^^^^\nError: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | (a,b) ->\n      let rdm = rand (a, b) in\n      (match rdm with\n       | 0 -> buildY ()\n       | 1 -> buildX ()\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 -> Sine (build (rand, (depth - 1)))\n       | 4 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) =\nmatch rand with \n| (a,b) -> \nlet rdm = rand(a,b) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> build(rand,depth-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> \nmatch h with \n| (s,n) -> \nif s = k then n else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = build(r,5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = build(r,5)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 14-17:\n  let b = build(rnd,5);;\n                ^^^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet r = makeRand (0, 7);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand (0, 7) in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n\nlet rnd = r (0, 8);;\n\nlet b = build (rnd, 5);;\n", "in": "let b = build(rnd,5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = build(r,5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> if(depth = 0) then buildY() else Cosine(build(rand, depth-1)) \n| 3 -> if(depth = 0) then buildX() else Sine(build(rand,depth-1))\n| 4 -> if(depth = 0) then buildY() else Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> if(depth = 0) then buildX() else Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> if(depth = 0) then buildY() \nelse Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> if(depth = 0) then buildX() else build(rand,depth-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = build(r,5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = build(r,8)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let b = build(r,8)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> if(depth = 0) then buildY() else Cosine(build(rand, depth-1)) \n| 3 -> if(depth = 0) then buildX() else Sine(build(rand,depth-1))\n| 4 -> if(depth = 0) then buildY() else Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> if(depth = 0) then buildX() else Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> if(depth = 0) then buildY() \nelse Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> if(depth = 0) then buildX() else build(rand,depth-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,8) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> if(depth = 0) then buildX() else Cosine(build(rand, depth-1)) \n| 3 -> if(depth = 0) then buildY() else Sine(build(rand,depth-1))\n| 4 -> if(depth = 0) then buildX() else Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> if(depth = 0) then buildY() else Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> if(depth = 0) then buildX() \nelse Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> if(depth = 0) then buildY() else build(rand,depth-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> if(depth = 0) then buildX() else Cosine(build(rand, depth-1)) \n| 3 -> if(depth = 0) then buildY() else Sine(build(rand,depth-1))\n| 4 -> if(depth = 0) then buildX() else Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> if(depth = 0) then buildY() else Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> if(depth = 0) then buildX() \nelse Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> if(depth = 0) then buildY() else build(rand,depth-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> \nmatch h with \n| (s,n) -> \nif s = k then n else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> if(depth = 0) then buildX() else Cosine(build(rand, depth-1)) \n| 3 -> if(depth = 0) then buildY() else Sine(build(rand,depth-1))\n| 4 -> if(depth = 0) then buildX() else Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> if(depth = 0) then buildY() else Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> if(depth = 0) then buildX() \nelse Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> if(depth = 0) then buildX()\nelse Half(build(rand,depth-1))\n| 8 -> if(depth = 0) then buildY()\nelse ThreeAve(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> if(depth = 0) then buildY() else build(rand,depth-1)"}]}
