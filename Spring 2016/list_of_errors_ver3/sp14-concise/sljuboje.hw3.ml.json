{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a * a + x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (a * a) + x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "out": "Characters 45-49:\n  let base = base in\n             ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = () in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = (+) in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = a in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "out": "Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = () in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = f in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = (+) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = (+) in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "out": "Characters 47-48:\n  let base = 0(+) in\n             ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "out": "Characters 47-48:\n  let base = 0(+) in\n             ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x (a p) in let base = p in List.fold_left f base fs;;\n", "out": "Characters 32-33:\n  let f a x = x (a p) in\n                   ^\nError: Unbound value p\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs p = \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs", "min": "\nlet pipe fs p =\n  let f a x = x (a p) in let base = p in List.fold_left f base fs;;\n", "out": "Characters 73-77:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a -> 'b\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a ) in\nlet base = fun x->x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun x->x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x p = x (a p) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun p->p in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x p = x (a p) in let base p = p in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun p -> p in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x p = x (a p) in let base p = p in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ h in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ h in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep  in\nlet base = h in\nlet l =  sepConcat sep t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = h in let l = sepConcat sep t in List.fold_left f base l;;\n", "out": "Characters 156-157:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sepConcat sep t  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sepConcat sep t) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ sepConcat sep t  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" List.map f l ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "out": "Characters 29-38:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" List.map f l ^ \"]\";;\n                               ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "out": "Characters 30-39:\n  let stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\";;\n                                ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) ) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x n-1\nin \nhelper n", "min": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1) in\n  helper n;;\n", "out": "Characters 70-81:\n  | _ -> x :: clone x n-1\n              ^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x (n-1)\nin \nhelper n", "min": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: (clone x (n - 1)) in\n  helper n;;\n", "out": "Characters 88-94:\n  helper n;;\n  ^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n", "min": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "out": "Characters 70-76:\n  | _ -> x :: helper n-1\n              ^^^^^^\nError: Unbound value helper\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n", "min": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "out": "Characters 74-80:\n  | _ -> x :: helper n-1\n              ^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: (helper n-1)\nin \nhelper n", "min": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "out": "Characters 75-81:\n  | _ -> x :: (helper n-1)\n               ^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n", "min": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "out": "Characters 69-75:\n  | _ -> helper n-1\n         ^^^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nlet rec helper n = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n", "min": "\nlet rec clone x n =\n  let rec helper n = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "out": "Characters 71-79:\n  | _ -> helper n-1\n         ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x n-1)", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1);;\n", "out": "Characters 58-67:\n  | _ -> x :: (clone x n-1);;\n               ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nif n > 0 then\nx :: (clone x (n-1) )\nelse\n[]", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = (l1 @ (clone (List.length l2 - List.length l1) 0 ),\nl2 @ (clone (List.length l1 - List.length l2) 0 ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((l1 @ (clone ((List.length l2) - (List.length l1)) 0)),\n    (l2 @ (clone ((List.length l1) - (List.length l2)) 0)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = (l1 @ (clone ((List.length l2) - (List.length l1)) 0 ),\nl2 @ (clone (List.length l1 - List.length l2) 0 ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((l1 @ (clone ((List.length l2) - (List.length l1)) 0)),\n    (l2 @ (clone ((List.length l1) - (List.length l2)) 0)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = (l1 @ (clone 0 ((List.length l2) - (List.length l1)) ),\nl2 @ (clone 0 ((List.length l1) - (List.length l2)) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((l1 @ (clone 0 ((List.length l2) - (List.length l1)))),\n    (l2 @ (clone 0 ((List.length l1) - (List.length l2)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = ((clone 0 ((List.length l2) - (List.length l1)) @ l1 ),\n(clone 0 ((List.length l1) - (List.length l2)) ) @ l2)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = ((clone 0 ((List.length l2) - (List.length l1)) @ l1 ),\n(clone 0 ((List.length l1) - (List.length l2)) @ l2 ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []    ->  []\n| h::t  ->  if h = 0 \nthen\nremoveZero t\nelse\nl", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []    ->  []\n| h::t  ->  if h = 0 \nthen\nremoveZero t\nelse\nl", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (List.rev l1) (List.rev l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 (0 :: l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 (0 :: l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 (0 :: l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x1,x2) = failwith \"tbd\" in\nlet base = failwith \"to be implemented\" in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x1,x2) = failwith \"tbd\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 (0 :: l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 (0 :: l2)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev 0::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 169-170:\n  let args = List.combine (List.rev 0::l1) (List.rev 0::l2) in\n                                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n| 0 ->  [0]\n| 1 ->  l\n| _ ->  bigAdd l (mulByDigit (i-1) l)", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2 ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet mul (l1,l2) = \nlet f (a1,a2) (x1,x2) = failwith \"\" in\nlet base = (0,[]) in\nlet args =  List.combine (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (mul (padZero l1 (l2) ))", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigMul l1 l2 =\n  let mul (l1,l2) =\n    let f (a1,a2) (x1,x2) = failwith \"\" in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 (mulByDigit x (l2 @ (clone a1 0)) ) )  in\nlet base = (0,[]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f (a1,a2) x =\n    ((a1 + 1), (bigAdd a2 (mulByDigit x (l2 @ (clone a1 0))))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 ((mulByDigit x l2) @ (clone a1 0) ) )  in\nlet base = (0,[]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f (a1,a2) x =\n    ((a1 + 1), (bigAdd a2 ((mulByDigit x l2) @ (clone a1 0)))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 (mulByDigit x (l2 @ (clone a1 0)) ) )  in\nlet base = (0,[]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f (a1,a2) x =\n    ((a1 + 1), (bigAdd a2 (mulByDigit x (l2 @ (clone a1 0))))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 (mulByDigit x (l2 @ (clone 0 a1)) ) )  in\nlet base = (0,[]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f (a1,a2) x =\n    ((a1 + 1), (bigAdd a2 (mulByDigit x (l2 @ (clone 0 a1))))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 (mulByDigit x (l2 @ (clone 0 a1)) ) )  in\nlet base = (0,[0]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f (a1,a2) x =\n    ((a1 + 1), (bigAdd a2 (mulByDigit x (l2 @ (clone 0 a1))))) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun p -> p in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x p = x (a p) in let base p = p in List.fold_left f base fs;;\n", "out": ""}]}
