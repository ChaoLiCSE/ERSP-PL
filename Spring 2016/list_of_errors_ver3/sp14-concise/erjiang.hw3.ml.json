{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-64:\n  | (h::t) -> f (a+(h*h)) t in\n              ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> f (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-72:\n  | (h::t) -> sqsum (a+(h*h)) t in\n              ^^^^^\nError: Unbound value sqsum\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> sqsum (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> sqsum (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-68:\n  | (h::t) -> f (a+(h*h)) t in\n              ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> f (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-68:\n  | (h::t) -> f a+(h*h) t in\n              ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> (f a) + ((h * h) t) in\n  let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f a+(h*h) t in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-68:\n  | (h::t) -> f (a+(h*h)) t in\n              ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> f (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (a + (x*x)) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = b in\n             ^\nError: Unbound value b\n", "min": "\nlet pipe fs = let f a x = x a in let base = b in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs num = \nlet f a x = x a in\nlet base = num in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-86:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type (('a -> 'b) -> 'a -> 'b) list\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base a = fs a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a -> fs a in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-49:\n  let base = base in\n             ^^^^\nError: Unbound value base\n", "min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-83:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe = fun x -> fun2 (fun1 x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe = fun base -> fun2 (fun1 base)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-48:\n  let base = int in\n             ^^^\nError: Unbound value int\n", "min": "\nlet pipe fs = let f a x = x a in let base = int in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = int in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 22-23:\n  let pipe = let base = x in fun x -> fun2 (fun1 base);;\n                        ^\nError: Unbound value x\n", "min": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe = let base = x in fun x  -> fun2 (fun1 base);;\n", "in": "let pipe = let base = x in fun x -> fun2 (fun1 base)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 31-35:\n  let pipe = fun x -> fun2 (fun1 base);;\n                                 ^^^^\nError: Unbound value base\n", "min": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 (fun1 base);;\n", "in": "let pipe = fun x -> fun2 (fun1 base)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe = fun x -> fun2 (fun1 x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe = fun x y -> y x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe = fun x y -> y x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 16-20:\n  let pipe = fun2 fun1;;\n                  ^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe = fun2 fun1;;\n", "in": "let pipe = fun2 fun1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 25-29:\n  let pipe = fun x -> fun2 fun1;;\n                           ^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1;;\n", "in": "let pipe = fun x -> fun2 fun1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 20-24:\n  let pipe = fun x -> fun2 fun1 x;;\n                      ^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1 x;;\n", "in": "let pipe = fun x -> fun2 fun1 x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe = fun x -> fun2 (fun1 x)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 20-24:\n  let pipe = fun x -> fun2 x (fun1 x);;\n                      ^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 x (fun1 x);;\n", "in": "let pipe = fun x -> fun2 x (fun1 x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe = fun x -> fun2 (fun1 x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe = fun x -> fun2 (fun1 x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs p = \nlet f a x = x a in\nlet base = p in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-60:\n  | (h::t) -> pipe;;\n              ^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type 'b list\n", "min": "\nlet rec pipe fs = match fs with | [] -> [] | h::t -> pipe;;\n", "in": "let rec pipe fs = \nmatch fs with\n| [] -> []\n| (h::t) -> pipe"}, {"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec pipe fs = \nmatch fs with\n| [] -> fun x -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec pipe fs = \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [] -> fun x -> x\n| (h::t) -> h (pipe t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec pipe fs = \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [] -> 3\n| (h::t) -> h (pipe t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 89-97:\n  | (h::t) -> h (pipe t);;\n                ^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "min": "\nlet rec pipe fs =\n  let fsrev = List.rev fs in\n  match fsrev with | x::[] -> x | h::t -> h (pipe t);;\n", "in": "let rec pipe fs = \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [x] -> x \n| (h::t) -> h (pipe t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-67:\n  | (h::t) -> h (pipe t);;\n                ^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "min": "\nlet rec pipe fs = match fs with | x::[] -> x | h::t -> h (pipe t);;\n", "in": "let rec pipe fs = \nmatch fs with\n| [x] -> x \n| (h::t) -> h (pipe t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-67:\n  | (h::t) -> h (pipe t);;\n                ^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "min": "\nlet rec pipe fs = match fs with | x::[] -> x | h::t -> h (pipe t);;\n", "in": "let rec pipe fs = \nmatch fs with\n| [x] -> x \n| (h::t) -> h (pipe t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 41-42:\n  | [] -> x \n          ^\nError: Unbound value x\n", "min": "\nlet rec pipe fs = match fs with | [] -> x | h::t -> h (pipe t);;\n", "in": "let rec pipe fs = \nmatch fs with\n| [] -> x \n| (h::t) -> h (pipe t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec pipe fs = \nmatch fs with\n| [] -> 0\n| (h::t) -> h (pipe t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec pipe fs = \nmatch fs with\n| [] -> fun x -> x\n| (h::t) -> h (pipe t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs p = \nlet f a x = x a in\nlet base = p in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base y = y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base y = y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 23-31:\n  let stringOfList f l = List.map f sepConcat l;;\n                         ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f sepConcat l;;\n", "in": "let stringOfList f l = List.map f sepConcat l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 33-45:\n  let stringOfList f l = sepConcat (List.map f);;\n                                   ^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f);;\n", "in": "let stringOfList f l = sepConcat (List.map f)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 38-50:\n  let stringOfList f l = sepConcat \"; \" (List.map f);;\n                                        ^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f);;\n", "in": "let stringOfList f l = sepConcat \"; \" (List.map f)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \"; \" (List.map f l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs p = \nlet f a x = x a in\nlet base = p in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse\nx::(clone x (n-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet shorter = \nif List.length l1 < List.length l2 then l1\nelse l2 in\nlet zeros = \nif shorter = l1 then ((List.length l2) - (List.length l1))\nelse ((List.length l1) - (List.length l2)) in\nif shorter = l1 then (List.append (clone 0 zeros) shorter, l2)\nelse (l1, List.append (clone 0 zeros) shorter)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 =\nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet shorter = \nif len1 < len2 then l1\nelse l2 in\nlet zeros = \nif shorter = l1 then (len2 - len1)\nelse (len1 - len2) in\nif shorter = l1 then (List.append (clone 0 zeros) shorter, l2)\nelse (l1, List.append (clone 0 zeros) shorter)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| (h::t) -> if h = 0 then removeZero t else l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-111:\n  (a,b) -> if (a + b) > 9 then 1::((a+b)-10)::a else (a+b)::a in\n                                              ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (a,b) ->\n          if (a + b) > 9 then 1 :: ((a + b) - 10) :: a else (a + b) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(a,b) -> if (a + b) > 9 then 1::((a+b)-10)::a else (a+b)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 250-254:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n) ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(m,n) -> if (m+n) > 9 then 1::((m+n)-10)::a else (m+n)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 252-256:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n)::[] ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n[(m,n)] -> if (m+n) > 9 then 1::((m+n)-10)::a else (m+n)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 250-254:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n) ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(m,n) -> if (m+n) > 9 then 1::((m+n)-10)::a else (m+n)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| (h::t) -> if h = 0 then removeZero t else l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs p = \nlet f a x = x a in\nlet base = p in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-153:\n  let args = match (List.rev (List.combine l1,l2)) with \n                             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args = match List.rev ((List.combine l1), l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (m,n) -> (m+n)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1,l2)) with \n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-153:\n  let args = match (List.rev (List.combine l1,l2)) with \n                             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args =\n      match List.rev ((List.combine l1), l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (m,n) -> (m+n)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1,l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 229-233:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (m,n) -> (m+n)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 231-235:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let add (m,n) = m + n in (add x)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 233-237:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in [add x] :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let add (m,n) = m + n in [(add x)]::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 233-237:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = [m + n] in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let add (m,n) = [m + n] in (add x)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 217-221:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let add (m,n) = m + n in (add x)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 231-235:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let add (m,n) = m + n in (add x)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 225-229:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int * int\n       but an expression was expected of type 'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in 0 :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let add (m,n) = m + n in 0::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 222-226:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int * int\n       but an expression was expected of type 'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let add (m,n) = m + n in a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-160:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = [] in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) = n1 in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) = n1 in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 9 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun arg -> x (a arg) in\nlet base = fun arg -> arg in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 then (1, 1::(digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail (h::t) = t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = if carry = 1 then getTail (getSum a) else getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 then (1, 1::(digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail (h::t) = t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail l = match l with \n| [] -> []\n| (h::t) -> t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail l = match l with \n| [] -> []\n| (h::t) -> if t = [] then [h] else t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| (h::t) -> if h = 0 then removeZero t else l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail l = match l with \n| [] -> []\n| (h::t) -> if t = [] then [h] else t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail l = match l with \n| [] -> []\n| (h::t) -> if t = [] then [h] else t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail l = match l with \n| [] -> []\n| (h::t) -> t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 129-172:\n  then ((mulByDigit i t)+(prod/10))::[prod mod 10]\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let revl = List.rev l in\n  match revl with\n  | [] -> 0\n  | h::t ->\n      let prod = h * i in\n      if prod > 9\n      then [(mulByDigit i t) + (prod / 10); prod mod 10]\n      else [mulByDigit i t; prod];;\n", "in": "let rec mulByDigit i l = \nlet revl = List.rev l in\nmatch revl with\n| []     -> 0\n| (h::t) -> \nlet prod = h*i in\nif prod > 9\nthen ((mulByDigit i t)+(prod/10))::[prod mod 10]\nelse (mulByDigit i t)::[prod]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-67:\n  if i > 0 then bigAdd (mulByDigit (i-1) l);;\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd (mulByDigit (i - 1) l);;\n", "in": "let rec mulByDigit i l = \nif i > 0 then bigAdd (mulByDigit (i-1) l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then [0]\nelse bigAdd (mulByDigit (i-1) l) [0]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then [0]\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) [0]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nif i = 0 then [0]\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 180-193:\n  if pos > 0 then (pos+1, bigAdd (mulByDigit x l1)::(clone 0 pos) prod)\n                                                    ^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let getPos (p,l) = p in\n    let pos = getPos a in\n    let getProd (p,l) = l in\n    let prod = getProd a in\n    if pos > 0\n    then ((pos + 1), ((bigAdd (mulByDigit x l1)) :: ((clone 0 pos) prod)))\n    else (1, (bigAdd (mulByDigit x l1) prod)) in\n  let base = (0, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet getPos (p, l) = p in\nlet pos = getPos a in\nlet getProd (p, l) = l in\nlet prod = getProd a in\nif pos > 0 then (pos+1, bigAdd (mulByDigit x l1)::(clone 0 pos) prod)\nelse (1, bigAdd (mulByDigit x l1) prod) in\nlet base = (0, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet getPos (p, l) = p in\nlet pos = getPos a in\nlet getProd (p, l) = l in\nlet prod = getProd a in\nif pos > 0 \nthen (pos+1, bigAdd (List.append (mulByDigit x l1) (clone 0 pos)) prod)\nelse (1, bigAdd (mulByDigit x l1) prod) in\nlet base = (0, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse\nx::(clone x (n-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| (h::t) -> if h = 0 then removeZero t else l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail l = match l with \n| [] -> []\n| (h::t) -> t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet getPos (p, l) = p in\nlet pos = getPos a in\nlet getProd (p, l) = l in\nlet prod = getProd a in\nif pos > 0 \nthen (pos+1, bigAdd (List.append (mulByDigit x l1) (clone 0 pos)) prod)\nelse (1, bigAdd (mulByDigit x l1) prod) in\nlet base = (0, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 =\nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet zeros = abs (len1 - len2) in\nif len1 < len2 then (List.append (clone 0 zeros) l1, l2)\nelse (l1, List.append (clone 0 zeros) l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n <= 0 then [] \nelse x::(clone x (n-1))"}]}
