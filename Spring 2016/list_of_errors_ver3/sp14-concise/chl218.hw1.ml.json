{"event": "eval", "ocaml": [{"in": "listReverse [1;2;3;4]", "out": "Characters 0-11:\n  listReverse [1;2;3;4];;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [1; 2; 3; 4];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let aux_palindrome xs xs' =\nxs", "out": "", "min": "\nlet aux_palindrome xs xs' = xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "palindrome \"racecar\"", "out": "Characters 0-10:\n  palindrome \"racecar\";;\n  ^^^^^^^^^^\nError: Unbound value palindrome\n", "min": "\nlet _ = palindrome \"racecar\";;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse xs = match xs with\n| []      -> []\n| [_]     -> []\n| x::xs'  -> append (listReverse xs') x", "out": "Characters 80-86:\n  | x::xs'  -> append (listReverse xs') x;;\n               ^^^^^^\nError: Unbound value append\n", "min": "\nlet listReverse xs =\n  match xs with\n  | [] -> []\n  | _::[] -> []\n  | x::xs' -> append (listReverse xs') x;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []    -> 0\n| x::xs' -> x + sumList xs'", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse append (digitsOfInt (n / 10)) (n mod 10)", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif n / 10 = 0\nthen 0\nelse additivePersistence (sumList(digitsOfInt n)) + 1", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n / 10 = 0\nthen n\nelse digitalRoot (sumList(digitsOfInt n))", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n| []      -> []\n| x::xs'  -> append (listReverse xs') x", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec aux_palindrome xs xs' = match xs, xs' with\n| [],[]     -> true\n| [],_      -> false\n| _, []     -> false\n| h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2", "out": "", "min": "\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \naux_palindrome (explode w) (listReverse (explode w))", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse append (digitsOfInt (n / 10)) (n mod 10)", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse append (digitsOfInt (n / 10)) (n mod 10)", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n / 10 = 0\nthen n\nelse digitalRoot (sumList(digitsOfInt n))", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n| []      -> []\n| x::xs'  -> append (listReverse xs') x", "out": "", "min": "\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec aux_palindrome xs xs' = match xs, xs' with\n| [],[]            -> true\n| [],_             -> false\n| _, []            -> false\n| h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2", "out": "", "min": "\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "type": ""}]}
