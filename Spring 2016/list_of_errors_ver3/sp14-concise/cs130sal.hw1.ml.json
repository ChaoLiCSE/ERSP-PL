{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n < 0)\nthen []\nelse (n mod 10 :: digitsOfInt n)", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else (n mod 10) :: (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n < 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n mod 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n <= 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n mod 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n <= 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n mod 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n / 10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n/10 :: []", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n / 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt(n/10) :: []", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "out": "Characters 48-65:\n  else digitsOfInt(n/10) :: [];;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt(n/10) :: []", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "out": "Characters 48-65:\n  else digitsOfInt(n/10) :: [];;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse [n mod 10] @ digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10)@ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList n in\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList n in num + (additivePersistence num));;\n", "out": "Characters 102-103:\n  let num = sumList n in\n                    ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet counter = counter + 1 in\nlet num = sumList myList in\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then counter\n  else\n    (let myList = digits n in\n     let counter = counter + 1 in\n     let num = sumList myList in num + (additivePersistence num));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then counter\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then counter\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = 0 in\ncounter = counter + 1\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then counter\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let counter = 0 in\n     counter = ((counter + (1 num)) + (additivePersistence num)));;\n", "out": "Characters 157-158:\n  counter = counter + 1\n                      ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then []\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "out": "Characters 119-142:\n  num + additivePersistence num;;\n        ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\n(*let num = sumList myList in*)\nmyList", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  if n < 10 then [] else (let myList = digits n in myList);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet sum = num + additivePersistence num in\ncounter = additivePersistence num + 1", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let sum = num + (additivePersistence num) in\n     counter = ((additivePersistence num) + 1));;\n", "out": "Characters 155-192:\n  counter = additivePersistence num + 1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet sum = num + additivePersistence num in\n1 + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let sum = num + (additivePersistence num) in\n     1 + (additivePersistence num));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\n1 + additivePersistence num", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in 1 + (additivePersistence num));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence sumList (digits n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "out": "Characters 63-82:\n  1 + additivePersistence sumList (digits n);;\n      ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence (sumList (digits n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nlet number = additivePersistence ( sumList (digits n)) in\nn", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10\n  then n\n  else (let number = additivePersistence (sumList (digits n)) in n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else additivePersistence (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif (n < 10)\nthen digRoot = n\nelse\nadditivePersistence ( sumList (digits n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then digRoot = n else additivePersistence (sumList (digits n));;\n", "out": "Error: Unbound value digRoot\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 42-49:\n  then digRoot = n\n       ^^^^^^^\nError: Unbound value digRoot\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then root = n else additivePersistence (sumList (digits n));;\n", "out": "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 42-46:\n  then root = n\n       ^^^^\nError: Unbound value root\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then root = n else additivePersistence (sumList (digits n));;\n", "out": "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 42-46:\n  then root = n\n       ^^^^\nError: Unbound value root\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else additivePersistence (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\ndigitalRoot ( additivePersistence n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (additivePersistence n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\ndigitalRoot(sumList(digits n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "out": "Characters 48-66:\n  else digitsOfInt (n/10) :: [n mod 10];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse [n mod 10]::digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10::digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> 0", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> 0;;\n", "out": "Characters 59-60:\n  | h::t -> 0;;\n            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> []", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse t :: h", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "out": "Characters 72-85:\n  | h::t -> listReverse t :: h;;\n            ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> (listReverse t) :: h", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "out": "Characters 72-87:\n  | h::t -> (listReverse t) :: h;;\n            ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse ( append ( t [h] ) )", "min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "out": "Characters 95-96:\n  | h::t -> listReverse ( append ( t [h] ) );;\n                                   ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse append ( t [h] )", "min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse append (t [h]);;\n", "out": "Characters 72-83:\n  | h::t -> listReverse append ( t [h] );;\n            ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append ( t [h] ))", "min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "out": "Characters 94-95:\n  | h::t -> listReverse (append ( t [h] ));;\n                                  ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )", "min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append t [h]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )", "min": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append t [h]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "out": "Characters 72-78:\n  | h::t -> listReverse (append t [h] );;\n                         ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "min": "\nlet append list1 list2 = match list1 with | [] -> list2 | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "min": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "out": "Characters 82-83:\n  | h::t -> listReverse (append t [h] );;\n                                   ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "min": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append [] t);;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append [h] t )", "min": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append [] t);;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append [h] t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "min": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append (listReverse t :: [h])", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append [listReverse t; h];;\n", "out": "Characters 59-65:\n  | h::t -> append (listReverse t :: [h]);;\n            ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append ( t [h])", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> append (t [h]);;\n", "out": "Characters 59-65:\n  | h::t -> append ( t [h]);;\n            ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append t [h]", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> append t [h];;\n", "out": "Characters 59-65:\n  | h::t -> append t [h];;\n            ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h])", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "out": "Characters 72-78:\n  | h::t -> listReverse (append t [h]);;\n                         ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> listReverse (append t [h]);;\n", "out": "Characters 71-77:\n  | h::t -> listReverse (append t [h]);;\n                         ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> append t [h]", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> append t [h];;\n", "out": "Characters 58-64:\n  | h::t -> append t [h];;\n            ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append (listReverse t) [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n", "out": "Characters 59-65:\n  | h::t -> append (listReverse t) [h];;\n            ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlet myList = n mod 10::digitsOfInt (n/10) in\nlistReverse myList", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let myList = (n mod 10) :: (digitsOfInt (n / 10)) in listReverse myList);;\n", "out": "Characters 94-105:\n  listReverse myList;;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlet myList = n mod 10::digitsOfInt (n/10) in\nmyList", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let myList = (n mod 10) :: (digitsOfInt (n / 10)) in myList);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (n mod 10::digitsOfInt (n/10) )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "out": "Characters 49-60:\n  listReverse (n mod 10::digitsOfInt (n/10) );;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([n mod 10] append digitsOfInt (n/10) )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ([n mod 10] append digitsOfInt (n / 10));;\n", "out": "Characters 49-60:\n  listReverse ([n mod 10] append digitsOfInt (n/10) );;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([(n mod 10)] append digitsOfInt (n/10) )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ([n mod 10] append digitsOfInt (n / 10));;\n", "out": "Characters 49-60:\n  listReverse ([(n mod 10)] append digitsOfInt (n/10) );;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] digitsOfInt (n/10) )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse (append [n mod 10] digitsOfInt (n / 10));;\n", "out": "Characters 49-60:\n  listReverse (append [n mod 10] digitsOfInt (n/10) );;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] (digitsOfInt (n/10)) )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse (append [n mod 10] (digitsOfInt (n / 10)));;\n", "out": "Characters 49-60:\n  listReverse (append [n mod 10] (digitsOfInt (n/10)) );;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \n(append  (digitsOfInt (n/10)) [n mod 10] )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "out": "Characters 50-56:\n  (append  (digitsOfInt (n/10)) [n mod 10] );;\n   ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = match w with \n| \"\" -> true\n| _ -> \nlet myString = explode w in\nlet reverseString = listReverse myString in\nif myString = reverseString\nthen true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  match w with\n  | \"\" -> true\n  | _ ->\n      let myString = explode w in\n      let reverseString = listReverse myString in\n      if myString = reverseString then true else false;;\n", "out": "Characters 102-113:\n  let reverseString = listReverse myString in\n                      ^^^^^^^^^^^\nError: Unbound value listReverse\n"}]}
