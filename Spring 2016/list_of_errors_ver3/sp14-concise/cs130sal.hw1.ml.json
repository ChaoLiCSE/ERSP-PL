{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n < 0)\nthen []\nelse (n mod 10 :: digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n < 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n <= 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n <= 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n / 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n/10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-65:\n  else digitsOfInt(n/10) :: [];;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt(n/10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-65:\n  else digitsOfInt(n/10) :: [];;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt(n/10) :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse [n mod 10] @ digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10)@ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| hd::tl -> listReverse tl @ [hd]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 102-103:\n  let num = sumList n in\n                    ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList n in num + (additivePersistence num));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList n in\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet counter = counter + 1 in\nlet num = sumList myList in\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 157-158:\n  counter = counter + 1\n                      ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then counter\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let counter = 0 in\n     counter = ((counter + (1 num)) + (additivePersistence num)));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = 0 in\ncounter = counter + 1\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 119-142:\n  num + additivePersistence num;;\n        ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then []\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\n(*let num = sumList myList in*)\nmyList"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 155-192:\n  counter = additivePersistence num + 1;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let sum = num + (additivePersistence num) in\n     counter = ((additivePersistence num) + 1));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet sum = num + additivePersistence num in\ncounter = additivePersistence num + 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet sum = num + additivePersistence num in\n1 + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\n1 + additivePersistence num"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-82:\n  1 + additivePersistence sumList (digits n);;\n      ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence sumList (digits n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nlet number = additivePersistence ( sumList (digits n)) in\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value digRoot\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 42-49:\n  then digRoot = n\n       ^^^^^^^\nError: Unbound value digRoot\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then digRoot = n else additivePersistence (sumList (digits n));;\n", "in": "let rec digitalRoot n = \nif (n < 10)\nthen digRoot = n\nelse\nadditivePersistence ( sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 42-46:\n  then root = n\n       ^^^^\nError: Unbound value root\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then root = n else additivePersistence (sumList (digits n));;\n", "in": "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 42-46:\n  then root = n\n       ^^^^\nError: Unbound value root\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then root = n else additivePersistence (sumList (digits n));;\n", "in": "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\ndigitalRoot ( additivePersistence n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\ndigitalRoot(sumList(digits n))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-66:\n  else digitsOfInt (n/10) :: [n mod 10];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse [n mod 10]::digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10::digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-60:\n  | h::t -> 0;;\n            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> 0;;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-85:\n  | h::t -> listReverse t :: h;;\n            ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse t :: h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-87:\n  | h::t -> (listReverse t) :: h;;\n            ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> (listReverse t) :: h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-96:\n  | h::t -> listReverse ( append ( t [h] ) );;\n                                   ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse ( append ( t [h] ) )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-83:\n  | h::t -> listReverse append ( t [h] );;\n            ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse append (t [h]);;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse append ( t [h] )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-95:\n  | h::t -> listReverse (append ( t [h] ));;\n                                  ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append ( t [h] ))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append [h] t )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append (listReverse t :: [h])"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 59-65:\n  | h::t -> append (listReverse t :: [h]);;\n            ^^^^^^\nError: Unbound value append\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append [listReverse t; h];;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append ( t [h])"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 59-65:\n  | h::t -> append ( t [h]);;\n            ^^^^^^\nError: Unbound value append\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> append (t [h]);;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append t [h]"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = listReverse [1; 2; 3; 4];;\n          ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> append t [h]"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = listReverse [1; 2; 3; 4];;\n          ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append (listReverse t) [h]"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n          ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlet myList = n mod 10::digitsOfInt (n/10) in\nlistReverse myList"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = digitsOfInt 3124;;\n          ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlet myList = n mod 10::digitsOfInt (n/10) in\nmyList"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (n mod 10::digitsOfInt (n/10) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n          ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([n mod 10] append digitsOfInt (n/10) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([(n mod 10)] append digitsOfInt (n/10) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-60:\n  listReverse ([(n mod 10)] append digitsOfInt (n/10) );;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ([n mod 10] append digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] digitsOfInt (n/10) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] (digitsOfInt (n/10)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \n(append  (digitsOfInt (n/10)) [n mod 10] )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 102-113:\n  let reverseString = reverseList myString in\n                      ^^^^^^^^^^^\nError: Unbound value reverseList\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  match w with\n  | \"\" -> true\n  | _ ->\n      let myString = explode w in\n      let reverseString = reverseList myString in\n      if myString = reverseString then true else false;;\n", "in": "let palindrome w = match w with \n| \"\" -> true\n| _ -> \nlet myString = explode w in\nlet reverseString = listReverse myString in\nif myString = reverseString\nthen true\nelse false"}]}
