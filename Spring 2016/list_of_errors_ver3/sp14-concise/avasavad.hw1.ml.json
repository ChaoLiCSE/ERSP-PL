{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"\n1 + 2", "out": "", "min": "\nlet rec sumList xs = (failwith \"TBD:sumList\" 1) + 2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = (* failwith \"TBD:sumList\" *)\n1 + 2", "out": "", "min": "\nlet rec sumList xs = 1 + 2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen digitsOfInt (n/10) @ n mod 10 :: []\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digits n = digitsOfInt (abs n)\n\ndigits (-124074)", "out": "Characters 19-30:\n  let rec digits n = digitsOfInt (abs n)\n                     ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec digits n = digitsOfInt (abs n) digits (-124074);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n > 10\nthen digitalRoot ( sumList (digitsOfInt n) )\nelse n", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet rec digitalRoot n =\n  if n > 10 then digitalRoot (sumList (digitsOfInt n)) else n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = failwith \"TBD\"", "out": "", "min": "\nlet rec additivePersistence n = failwith \"TBD\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\nh::t -> (listReverse t) @ h :: []\n| [] -> []", "out": "", "min": "\nlet rec listReverse l =\n  match l with | h::t -> (listReverse t) @ [h] | [] -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = match listReverse (explode w) with\nh :: t -> listReverse (explode w) = explode w\n| [] -> true", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | h::t -> (listReverse t) @ [h] | [] -> [];;\n\nlet palindrome w =\n  match listReverse (explode w) with\n  | h::t -> (listReverse (explode w)) = (explode w)\n  | [] -> true;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "palindrome \"bob\"", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | h::t -> (listReverse t) @ [h] | [] -> [];;\n\nlet palindrome w =\n  match listReverse (explode w) with\n  | h::t -> (listReverse (explode w)) = (explode w)\n  | [] -> true;;\n\nlet _ = palindrome \"bob\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec inc i n = \nif n>9 \nthen inc (i+1) sumList (digitsOfInt n)\nelse i", "out": "Characters 42-49:\n  then inc (i+1) sumList (digitsOfInt n)\n                 ^^^^^^^\nError: This expression has type int list -> int\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet rec inc i n = if n > 9 then inc (i + 1) sumList (digitsOfInt n) else i;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec inc i n = \nif n>9 \nthen inc (i+1) ( sumList (digitsOfInt n) )\nelse i", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet rec inc i n = if n > 9 then inc (i + 1) (sumList (digitsOfInt n)) else i;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \ninc 0 n", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet rec inc i n = if n > 9 then inc (i + 1) (sumList (digitsOfInt n)) else i;;\n\nlet rec additivePersistence n = inc 0 n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec inc i n = \nif(n>9) \nthen inc (i+1) ( sumList (digitsOfInt n) )\nelse i in\ninc 0 n", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet additivePersistence n =\n  let rec inc i n =\n    if n > 9 then inc (i + 1) (sumList (digitsOfInt n)) else i in\n  inc 0 n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet rec inc i n = \nif(n>9) \nthen inc (i+1) ( sumList (digitsOfInt n) )\nelse i in\ninc 0 n", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet rec additivePersistence n =\n  let rec inc i n =\n    if n > 9 then inc (i + 1) (sumList (digitsOfInt n)) else i in\n  inc 0 n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
