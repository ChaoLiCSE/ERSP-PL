{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + (sumList t)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = match n with \n[] -> t\n| h::t -> [h]::digistOfInt(t)", "min": "\nlet rec digitsOfInt n =\n  match n with | [] -> t | h::t -> [h] :: (digistOfInt t);;\n", "out": "Characters 44-45:\n  [] -> t\n        ^\nError: Unbound value t\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = match n with \n[] -> h\n| h::t -> [h]::digistOfInt(t)", "min": "\nlet rec digitsOfInt n =\n  match n with | [] -> h | h::t -> [h] :: (digistOfInt t);;\n", "out": "Characters 44-45:\n  [] -> h\n        ^\nError: Unbound value h\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = match n with \n[] -> []\n| h::t -> [h]::digistOfInt(t)", "min": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digistOfInt t);;\n", "out": "Characters 62-73:\n  | h::t -> [h]::digistOfInt(t);;\n                 ^^^^^^^^^^^\nError: Unbound value digistOfInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = match n with \n[] -> []\n| h::t -> [h]::digitstOfInt t", "min": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitstOfInt t);;\n", "out": "Characters 62-74:\n  | h::t -> [h]::digitstOfInt t;;\n                 ^^^^^^^^^^^^\nError: Unbound value digitstOfInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = match n with \n[] -> []\n| h::t -> [h]::digitsOfInt t", "min": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = match n with \n0 -> []\n| n -> [n % 10]::digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | n -> [n % 10] :: (digitsOfInt (n / 10));;\n", "out": "Characters 56-57:\n  | n -> [n % 10]::digitsOfInt (n/10);;\n            ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10)::n mod 10\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "out": "Characters 39-56:\n  if n > 0 then digitsOfInt(n/10)::n mod 10\n                ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt n/10::n mod 10\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) :: (n mod 10) else [];;\n", "out": "Characters 39-52:\n  if n > 0 then digitsOfInt n/10::n mod 10\n                ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n >0 then n/10::n mod 10\nelse []", "min": "\nlet rec digitsOfInt n = if n > 0 then (n / 10) :: (n mod 10) else [];;\n", "out": "Characters 44-52:\n  if n >0 then n/10::n mod 10\n                     ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n >0 then digitsOfInt n/10::[n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then [(digitsOfInt n) / 10; n mod 10] else [];;\n", "out": "Characters 38-51:\n  if n >0 then digitsOfInt n/10::[n mod 10]\n               ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n >0 then (digitsOfInt n/10)::[n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then [(digitsOfInt n) / 10; n mod 10] else [];;\n", "out": "Characters 39-52:\n  if n >0 then (digitsOfInt n/10)::[n mod 10]\n                ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n >0 then (digitsOfInt n/10)@[n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "out": "Characters 38-56:\n  if n >0 then (digitsOfInt n/10)@[n mod 10]\n               ^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n >0 then digitsOfInt n/10@[n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "out": "Characters 38-54:\n  if n >0 then digitsOfInt n/10@[n mod 10]\n               ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n >0 then [digitsOfInt n/10]::[n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then [[(digitsOfInt n) / 10]; n mod 10] else [];;\n", "out": "Characters 39-52:\n  if n >0 then [digitsOfInt n/10]::[n mod 10]\n                ^^^^^^^^^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + (sumList t)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n >0 then n::[n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> t::[listReverse h]", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; listReverse h];;\n", "out": "Characters 74-75:\n  | h::t -> t::[listReverse h];;\n                            ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = match n with\n| [] -> []\n| h :: t -> h + additivePersistence t", "min": "\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> h + (additivePersistence t);;\n", "out": "Characters 72-93:\n  | h :: t -> h + additivePersistence t;;\n                  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \n\nif n >0 then n::[n mod 10]", "min": "\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10];;\n", "out": "Characters 40-42:\n  if n >0 then n::[n mod 10];;\n                ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + (sumList t)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \n\nif n > 0 then digitsOfInt n :: n mod 10", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) :: (n mod 10);;\n", "out": "Characters 54-56:\n  if n > 0 then digitsOfInt n :: n mod 10;;\n                              ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \n\nif n > 0 then (n mod 10) :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": "Characters 51-53:\n  if n > 0 then (n mod 10) :: digitsOfInt (n/10);;\n                           ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \n\nif n > 0 then (n mod 10) :: (digitsOfInt (listReverse(n/10)))\nelse []", "min": "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (listReverse (n / 10))) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \n\nif n > 0 then listReverse (n mod 10) :: (digitsOfInt (n/10))\nelse []", "min": "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "if n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "min": "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "out": "Characters 3-4:\n  if n > 0 then (n mod 10) :: (digitsOfInt (n/10))\n     ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: listReverse (digitsOfInt (n/10))\nelse []", "min": "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (listReverse (digitsOfInt (n / 10))) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then (digitsOfInt (n/10)) :: [n mod 10]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n / 10); n mod 10] else [];;\n", "out": "Characters 39-59:\n  if n > 0 then (digitsOfInt (n/10)) :: [n mod 10]\n                ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n > 0 then digitsofInt(n/10) :: (n mod 10) \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsofInt (n / 10)) :: (n mod 10) else [];;\n", "out": "Characters 39-50:\n  if n > 0 then digitsofInt(n/10) :: (n mod 10) \n                ^^^^^^^^^^^\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) :: (n mod 10) \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "out": "Characters 39-56:\n  if n > 0 then digitsOfInt(n/10) :: (n mod 10) \n                ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ (n mod 10) \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ (n mod 10) else [];;\n", "out": "Characters 59-69:\n  if n > 0 then digitsOfInt(n/10) @ (n mod 10) \n                                    ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > -1 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > (-1) then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = match n with\n| [] -> []\n| h :: t -> t + digitsOfInt (additivePersistence h)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> t + (digitsOfInt (additivePersistence h));;\n", "out": "Characters 68-69:\n  | h :: t -> t + digitsOfInt (additivePersistence h);;\n              ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let additivePersistence n = \nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  if n < 10 then count else ((sumList (digitsOfInt n)), (count + 1));;\n", "out": "Characters 44-49:\n  if n < 10 then count\n                 ^^^^^\nError: Unbound value count\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else ((sumList (digitsOfInt n)), (count + 1));;\n", "out": "Characters 72-108:\n  else (sumList (digitsOfInt n), count + 1);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList (digitsOfInt n) count + 1", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else (sumList (digitsOfInt n) count) + 1;;\n", "out": "Characters 72-79:\n  else sumList (digitsOfInt n) count + 1;;\n       ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in if n < 10 then count else sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nif listReverse(explode(w))  = explode(w) then true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = failwith \"TBD\";;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> t::[listReverse h]", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; listReverse h];;\n", "out": "Characters 74-75:\n  | h::t -> t::[listReverse h];;\n                            ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + (sumList t)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n(* | h::t -> t::[listReverse h] *)\n| h::t -> listReverse t @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n(* | h::t -> t::[listReverse h] *)\n| h::t -> listReverse t @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n(* | h::t -> t::[listReverse h] *)\n| h::t -> listReverse t @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in if n < 10 then count else sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse count + 1 sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else count + (1 sumList (digitsOfInt n));;\n", "out": "Characters 80-81:\n  else count + 1 sumList(digitsOfInt n);;\n               ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse count + 1 in sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ =\n  let additivePersistence n =\n    let count = 0 in if n < 10 then count else count + 1 in\n  sumList (digitsOfInt n);;\n", "out": "Characters 105-106:\n  else count + 1 in sumList(digitsOfInt n);;\n                                        ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in if n < 10 then 1 else 1 + (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in if n < 10 then 1 else 1 + (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in if n < 10 then 1 else 1 + (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = \n1 + sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = 1 + (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n = \n1 + sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = 1 + (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence sumList(digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence sumList (digitsOfInt n));;\n", "out": "Characters 59-78:\n  else 1 + additivePersistence sumList(digitsOfInt n);;\n           ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitalRoot n = \nlet sum = 0 in\nif n < 10 then n + sum\nelse sum = digitalRoot(sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let sum = 0 in\n  if n < 10 then n + sum else sum = (digitalRoot (sumList (digitsOfInt n)));;\n", "out": "Characters 68-109:\n  else sum = digitalRoot(sumList(digitsOfInt n));;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet sum = 0 in\nif n < 10 then n\nelse digitalRoot(sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let sum = 0 in if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot(sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse additivePersistence (sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else additivePersistence (sumList (digitsOfInt n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 0\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot(sumList(digitsOfInt n))", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "out": ""}]}
