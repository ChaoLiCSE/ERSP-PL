{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 71-72:\n  let base = x*x in\n             ^\nError: Unbound value x\n", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = x * x in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = x*x in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 43-44:\n  let f a x = List.fold_left f a x in\n                             ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = List.fold_left f a x in\n  let base = x * x in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = List.fold_left f a x in\nlet base = x*x in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 43-44:\n  let f a x = List.fold_left f a b in\n                             ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = List.fold_left f a b in\n  let base = x * x in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = List.fold_left f a b in\nlet base = x*x in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-95:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = a x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-68:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 47-48:\n  let base = a(0) in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = a x in let base = a 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = a(0) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-69:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-57:\n  let base = match base with\n                   ^^^^\nError: Unbound value base\n", "min": "\nlet pipe fs =\n  let f a x = a x in\n  let base = match base with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = match base with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-54:\n  let base = match x with\n                   ^\nError: Unbound value x\n", "min": "\nlet pipe fs =\n  let f a x = a x in\n  let base = match x with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = match x with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-97:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = a x in\n  let base = match fs with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = match fs with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-68:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x) in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 27-28:\n  let f a x = f a x in\n              ^\nError: Unbound value f\n", "min": "\nlet pipe fs = let f a x = f a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = f a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-96:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x = function | g -> g a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function g -> g a x in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-96:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x = function | g -> g x a in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function g -> g x a in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-102:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = function | g -> g (x a) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function g -> g(x a) in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-100:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = function | g -> g x in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function g -> g(x) in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 100-104:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = function | g -> g (a x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function g -> g (a(x)) in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x a in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 99-103:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = function | g -> g (a x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function g -> g( a x) in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> a( x g)  in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 97-98:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = function | g -> a (g x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function g -> a(g x)  in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> a(x g)  in\nlet base = function x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> a(x g)  in\nlet base = function y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x(a g)  in\nlet base = function y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a) g  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-99:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x = function | g -> x (g a) in\n  let base = function | b -> b in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = function g -> x (g a)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> a (x g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 147-148:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sep in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sep in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-90:\n  if x.length < 2\n       ^^^^^^\nError: Unbound record field length\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x.length < 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif x.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 85-91:\n  if sl.length < 2\n        ^^^^^^\nError: Unbound record field length\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if sl.length < 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif sl.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-97:\n  if List.length < 2\n                   ^\nError: This expression has type int but an expression was expected of type\n         'a list -> int\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if List.length < 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-97:\n  if List.length = 2\n                   ^\nError: This expression has type int but an expression was expected of type\n         'a list -> int\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if List.length = 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-90:\n  if t.length = 2\n       ^^^^^^\nError: Unbound record field length\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if t.length = 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif t.length = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 106-111:\n  then a ^ x in\n       ^^^^^\nError: This expression has type string but an expression was expected of type\n         unit\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) = 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 1\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 1\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 1\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 3\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 1\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 1\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 0\nthen a ^ x ^ sep\nelse a ^ x  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 93-96:\n  if List.length(l) = 0\n                ^^^\nError: Unbound value l\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length l) = 0 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(l) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-95:\n  if List.length() = 0\n                ^^\nError: This variant expression is expected to have type 'a list\n       The constructor () does not belong to type list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length ()) = 0 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length() = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) < 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) < -1\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) < 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) < 1\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 138-142:\n  else if List.length(s1) > 1\n                     ^^^^\nError: Unbound value s1\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x =\n        if (List.length sl) > 2\n        then a ^ (x ^ sep)\n        else if (List.length s1) > 1 then a ^ x else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse if List.length(s1) > 1\nthen a ^ x \nelse x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse if List.length(sl) > 1\nthen a ^ x \nelse x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse if List.length(sl) > 1\nthen a ^ x \nelse a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse if List.length(sl) > 1\nthen a ^ x \nelse x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ x ^ sep\nelse if List.length(sl) > 0\nthen a ^ x \nelse x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ x ^ sep\nelse a in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 0\nthen a ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > -1\nthen a ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 0\nthen a ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen h ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ x ^ sep\nelse h in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ h ^ sep\nelse h in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ x ^ sep\nelse h in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ x ^ sep\nelse a ^ a in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse a ^ a in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse a in \nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 198-199:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) > 2 then a ^ (x ^ sep) else x ^ x in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ x ^ sep\nelse x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ x\nelse x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ x\nelse x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ x ^ sep\nelse x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ x ^ sep\nelse a in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse a in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse a in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen sep ^ a ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen sep ^ a ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen sep ^ a ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 3\nthen sep ^ a ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 50\nthen sep ^ a ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen sep ^ a ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h ^ sep\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = \nif List.length(sl) > 1\nthen h\nelse h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-56:\n  let stringOfList f l = List.map (fun a -> a l) sepConcat;;\n                                                 ^^^^^^^^^\nError: This expression has type string -> string list -> string\n       but an expression was expected of type ('a -> 'b) list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun a  -> a l) sepConcat;;\n", "in": "let stringOfList f l = List.map (fun a -> a l) sepConcat"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-56:\n  let stringOfList f l = List.map (fun a -> a l) sepConcat;;\n                                                 ^^^^^^^^^\nError: This expression has type string -> string list -> string\n       but an expression was expected of type ('a -> 'b) list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun a  -> a l) sepConcat;;\n", "in": "let stringOfList f l = List.map (fun a -> a l) sepConcat"}, {"type": "", "out": "", "min": "", "in": "let rec clone x n = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = List.map (fun a -> a l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = List.map (fun a -> a l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = List.map (sepConcat(l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 42-50:\n  let stringOfList f l = List.map (sepConcat(\";\", l));;\n                                            ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\";\", l));;\n", "in": "let stringOfList f l = List.map (sepConcat(\";\", l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 32-59:\n  let stringOfList f l = sepConcat(\";\", List.map(fun c -> l));;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (fun c  -> l)));;\n", "in": "let stringOfList f l = sepConcat(\";\", List.map(fun c -> l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 32-61:\n  let stringOfList f l = sepConcat(\";\", List.map(fun c -> c l));;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (fun c  -> c l)));;\n", "in": "let stringOfList f l = sepConcat(\";\", List.map(fun c -> c l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 32-63:\n  let stringOfList f l = sepConcat(\";\", (List.map(fun c -> c l)));;\n                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (fun c  -> c l)));;\n", "in": "let stringOfList f l = sepConcat(\";\", (List.map(fun c -> c l)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-61:\n  let stringOfList f l = sepConcat \";\" (List.map(fun c -> c l));;\n                                       ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a -> 'b) list -> 'b list\n       but an expression was expected of type string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun c  -> c l));;\n", "in": "let stringOfList f l = sepConcat \";\" (List.map(fun c -> c l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-61:\n  let stringOfList f l = sepConcat \";\" (List.map(fun c -> f l));;\n                                       ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun c  -> f l));;\n", "in": "let stringOfList f l = sepConcat \";\" (List.map(fun c -> f l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-61:\n  let stringOfList f l = sepConcat \";\" (List.map(fun f -> f l));;\n                                       ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a -> 'b) list -> 'b list\n       but an expression was expected of type string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun f  -> f l));;\n", "in": "let stringOfList f l = sepConcat \";\" (List.map(fun f -> f l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 23-32:\n  let stringOfList f l = sepConcat \";\" List.map f l;;\n                         ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map f l;;\n", "in": "let stringOfList f l = sepConcat \";\" List.map f l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map f l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-52:\n  let stringOfList f l = sepConcat \";\" (List.map(f l));;\n                                       ^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (f l));;\n", "in": "let stringOfList f l = sepConcat \";\" (List.map(f l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map f l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map f (l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map f (l) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a )  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f (l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f (l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map f (l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map f (l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \na ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \na ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \";\" (List.map f (l) )) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l ) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map (f) (l) ) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map (f) l ) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 1\nthen a ^ sep ^ x \nelse a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map (f) l ) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 81-84:\n  in \"[\" ^str ^ \"]\";;\n          ^^^\nError: Unbound value str\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let string str = sepConcat \";\" (List.map f l) in \"[\" ^ (str ^ \"]\");;\n", "in": "let stringOfList f l = \nlet string str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 82-85:\n  in \"[\" ^str ^ \"]\";;\n          ^^^\nError: Unbound value str\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let string str = sepConcat \"; \" (List.map f l) in \"[\" ^ (str ^ \"]\");;\n", "in": "let stringOfList f l = \nlet string str = sepConcat \"; \" (List.map (f) l )\nin \"[\" ^str ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \"; \" (List.map (f) l )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \" ;\" (List.map (f) l )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \" ;\" (List.map (f) l )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map (f) l )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map (f) l ) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l)  ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x a (g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function h -> h in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-44:\n  let stringOfList f l = \"[\" ^ sepConcat (\"; \" (List.map (f) l))  ^ \"]\";;\n                                          ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\"; \" (List.map f l))) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ sepConcat (\"; \" (List.map (f) l))  ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-63:\n  let stringOfList f l = \"[\" ^ sepConcat (\"; \", (List.map (f) l))  ^ \"]\";;\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\"; \", (List.map f l))) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ sepConcat (\"; \", (List.map (f) l))  ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x (a (g))  in\nlet base = function h -> h in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x + a*a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = function g -> x(a(g))  in\nlet base = function h -> h in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 43-47:\n  |h::t ->\n   ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec clone x n = match n with | 0 -> [] | h::t -> x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = match n with\n|0 -> []\n|h::t ->\nx::clone x n-1"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 26-28:\n  if n =< 0\n       ^^\nError: Unbound value =<\n", "min": "\nlet rec clone x n = if n =< 0 then [] else x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nif n =< 0\nthen []\nelse x::clone x n-1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-55:\n  else x::clone x n-1;;\n          ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nif n < 1\nthen []\nelse x::clone x n-1"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 48-57:\n  else x:: (clone x n-1);;\n            ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x n-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x (n-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n < 1\nthen []\nelse x::clone x (n-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map (f) l)  ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 73-74:\n  if a > 0\n     ^\nError: Unbound value a\n", "min": "\nlet padZero l1 l2 =\n  let int a = (List.length l1) - (List.length l2) in\n  if a > 0 then \"hi\" else \"bye\";;\n", "in": "let padZero l1 l2 = \nlet int a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-82:\n  then l1 * (clone 0 a)\n       ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else \"bye\";;\n", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen l1 * (clone 0 a)\nelse \"bye\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-82:\n  then l1 * (clone 0 a)\n       ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else l1 * l2;;\n", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen l1 * (clone 0 a)\nelse l1 * l2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-83:\n  then (l1 * (clone 0 a))\n        ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else l1 * l2;;\n", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse l1 * l2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-83:\n  then (l1 * (clone 0 a))\n        ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else l1 * l2;;\n", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse (l1 * l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 85-95:\n  then (l1,(List.apend (clone 0 a) l2))\n            ^^^^^^^^^^\nError: Unbound value List.apend\nHint: Did you mean append?\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then (l1, (List.apend (clone 0 a) l2)) else (l1, l2);;\n", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.apend (clone 0 a) l2))\nelse (l1,l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (l1,l2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 119-153:\n  else (List.append ( clone 0 (0 -a)) l2);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a list * int list\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else List.append (clone 0 (0 - a)) l2;;\n", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (List.append ( clone 0 (0 -a)) l2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 120-149:\n  else (List.append ( clone 0 (0 -a)), l2);;\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else ((List.append (clone 0 (0 - a))), l2);;\n", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (List.append ( clone 0 (0 -a)), l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse ((List.append (clone 0 (0-a)) l1), l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n|[] -> []\n|h::t -> \nif h = 0\nthen removeZero l\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n|[] -> []\n|h::t -> \nif h = 0\nthen removeZero l\nelse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n|[] -> []\n|h::t -> \nif h = 0\nthen removeZero t\nelse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n|[] -> []\n|h::t -> \nif h = 0\nthen removeZero t\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 159-185:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-158:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}, {"type": "type", "out": "Characters 154-158:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let rec mulByDigit i l = failwith \"to be implemented\""}, {"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-15:\n  let _ = padZero [1;0;0;2] [9;9];;\n          ^^^^^^^\nError: Unbound value padZero\n", "min": "\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n", "in": "let rec removeZero l = match l with\n|[] -> []\n|h::t -> \nif h = 0\nthen removeZero t\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 128-132:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  l1 in\nlet base = [] in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-134:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  l1 in\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-134:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  l1 in\nlet base = [0] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-135:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [0] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  l1 in\nlet base = [0] in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 130-134:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [0] in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  l1 in\nlet base = [0] in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-136:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [0] in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  l1 in\nlet base = [0] in\nlet args = [l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 115-141:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [0] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a,x) in\nlet base = [0] in\nlet args = [l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-15:\n  let _ = padZero [1;0;0;2] [9;9];;\n          ^^^^^^^\nError: Unbound value padZero\n", "min": "\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n", "in": "let rec removeZero l = match l with\n|[] -> []\n|h::t -> \nif h = 0\nthen removeZero t\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 143-144:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, x) in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 146-150:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list list\n       Type 'a * 'b is not compatible with type int list \n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 144-148:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 148-152:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = (_, 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 74-75:\n  let base = (a , 0) in\n              ^\nError: Unbound value a\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (a, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = (l1 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 150-154:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * int\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (l1, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-153:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = (0, 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 148-152:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 148-152:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 144-148:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = [0, []] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-153:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type (int * 'a list) list\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [(0, [])] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-153:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"incomplete\" in\nlet base = failwith \"incomplete\" in\nlet args = failwith \"incomplete\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}, {"type": "scope", "out": "Characters 219-226:\n  removeZero (add (padZero l1 l2));;\n                   ^^^^^^^\nError: Unbound value padZero\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"incomplete\" in\n    let base = failwith \"incomplete\" in\n    let args = failwith \"incomplete\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let rec mulByDigit i l = failwith \"to be implemented\""}, {"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-13:\n  let _ = sqsum [(-1); (-2); (-3); (-4)];;\n          ^^^^^\nError: Unbound value sqsum\n", "min": "\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n", "in": "let pipe fs = \nlet f a x = function g -> x(a(g))  in\nlet base = function h -> h in\nList.fold_left f base fs"}]}
