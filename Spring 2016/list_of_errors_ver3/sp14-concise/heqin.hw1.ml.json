{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = List.fold_left ( + ) 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = List.fold_left ( + ) 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-47:\n  else a :: digitsOfInt n;;\n       ^\nError: Unbound value a\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else a :: (digitsOfInt n);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 47-48:\n  else n%10;;\n        ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else n % 10;;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n%10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-54:\n  else n mod 10;;\n       ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else n mod 10;;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n mod 10"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-47:\n  else h:: digitsOfInt n mod 10;;\n       ^\nError: Unbound value h\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else h :: ((digitsOfInt n) mod 10);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse h:: digitsOfInt n mod 10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-59:\n  else digitsOfInt n mod 10;;\n       ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else (digitsOfInt n) mod 10;;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt n mod 10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-64:\n  else digitsOfInt (n/10) mod 10 :: [];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [(digitsOfInt (n / 10)) mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) mod 10 :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then n\nelse digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then n\nelse digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then 1\nelse digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then 1\nelse digitsOfInt (n mod 10) in\ndigitsOfInt [] n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-82:\n  digitsOfInt [] n;;\n  ^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet _ =\n  let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n mod 10) in\n  digitsOfInt [] n;;\n", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 113-114:\n  digit [] d;;\n           ^\nError: Unbound value d\n", "min": "\nlet digitsOfInt n =\n  let rec digit acc d =\n    if d < 10 then d :: acc else digit ((d mod 10) :: acc) (d / 10) in\n  digit [] d;;\n", "in": "let digitsOfInt n = \nlet rec digit acc d =\nif d < 10 then d::acc\nelse digit ((d mod 10)::acc) (d/10) in\ndigit [] d"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 113-114:\n  digit [] d;;\n           ^\nError: Unbound value d\n", "min": "\nlet digitsOfInt n =\n  let rec digit acc d =\n    if d < 10 then d :: acc else digit ((d mod 10) :: acc) (d / 10) in\n  digit [] d;;\n", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-115:\n  else digit ((n mod 10)::acc) (n/10) in\n             ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit (n/10) ((n mod 10)::acc) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 132-134:\n  digit [] n;;\n        ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 100-103:\n  else if n == '-' then n::acc\n               ^^^\nError: This expression has type char but an expression was expected of type\n         int\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10\n       then n :: acc\n       else if n == '-' then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-135:\n  digit [] n;;\n        ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nn [] digit"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 127-128:\n  n [] digit;;\n  ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     n [] digit);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] digit"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-135:\n  digit [] digit;;\n        ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] digit);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| n < 10 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n == 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n == 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n = 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n = 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =\nif n < 10 then 0  \nelse \nlet rec dig n =\nif n < 10 then n\nelse 1+ dig ((n mod 10) + dig (n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\ndigitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 93-94:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot n\nelse n in digitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 171-172:\n  else n in digitalRoot n;;\n                        ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot n else n in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse n in digitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 171-172:\n  else n in digitalRoot n;;\n                        ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else n in\n  digitalRoot n;;\n", "in": "let digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse n in digitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 167-168:\n  else n in digitalRoot n;;\n                        ^\nError: Unbound value n\n", "min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet _ =\n  let digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else n in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 172-173:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 172-173:\n  digitalRoot x;;\n              ^\nError: Unbound value x\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot x;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then 1 + digitalRoot x\nelse 1 in \ndigitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 176-177:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then 1 + (digitalRoot x) else 1 in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 195-196:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    if n < 10\n    then n\n    else\n      (let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n       let x = digits n in if x > 9 then digitalRoot x else 1) in\n  digitalRoot n;;\n", "in": "let digitalRoot n = \nif n < 10 then n\nelse \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 191-192:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n", "min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet _ =\n  let digitalRoot n =\n    if n < 10\n    then n\n    else\n      (let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n       let x = digits n in if x > 9 then digitalRoot x else 1) in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 172-173:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = failwith \"TBD\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits(n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n = \nif n < 10 then n\nelse (n mod 10) + digitalRoot (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse (n mod 10) + digitalRoot (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 168-169:\n  else x in digitalRoot n;;\n                        ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else x in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 170-171:\n  else x in digitalRoot n;;\n                        ^\nError: Unbound value n\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else x in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse 1 in digitalRoot x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 170-171:\n  else 1 in digitalRoot x;;\n                        ^\nError: Unbound value x\n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot x;;\n", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse 1 in\naddTimes n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n =\nif n < 10 then n\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then n\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n =\nif n < 10 then n\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-77:\n  | hd::l' -> 1 + listReverse l;;\n                  ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l);;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::l' -> 1 + listReverse l'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-78:\n  | hd::l' -> 1 + listReverse l';;\n                  ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l');;\n", "in": "let rec listReverse l = match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> 0\n| _::tl -> 1 + listReverse _"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> _ + listReverse tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-73:\n  | _::tl -> listReverse tl + tl;;\n             ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n", "in": "let rec listReverse l = match l with\n| 0 -> []\n| _::tl -> listReverse tl + tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-54:\n  | _::tl -> listReverse tl + tl;;\n    ^^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec listReverse l =\n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl + tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-73:\n  | _::tl -> listReverse tl + tl;;\n             ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> listReverse l\n| _::tl -> listReverse tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec reverseHelper a l = match l with\n| [] -> a\n| _::tl -> reverseHelper a tl\nin reverseHelper 0 l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec reverseHelper l tl = match l with\n| [] -> []\n| _::tl -> reverseHelper tl l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> 0\n| hd::l -> listReverse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec reverseHelper acc = \nif [] then acc\nelse h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 53-55:\n  if [] then acc\n     ^^\nError: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n", "min": "\nlet listReverse l =\n  let rec reverseHelper acc = if [] then acc else reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "in": "let listReverse l = \nlet rec reverseHelper acc = \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-100:\n  | h::t -> reverseHelper (h::acc) t in\n            ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "in": "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 19-30:\n  let _ = palindrome \"malayalam\";;\n                     ^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if w = (listReverse w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n", "in": "let palindrome w = \nif explode w = listReverse w then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-48:\n  if explode w = listReverse w then true\n                             ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "in": "let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: l -> hd + sumList l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-100:\n  | h::t -> reverseHelper (h::acc) t in\n            ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "in": "let listReverse l = \nlet rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::acc) in\nreverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 107-110:\n  | h::t -> reverseHelper t (h::acc) in\n                                ^^^\nError: Unbound value acc\n", "min": "\nlet listReverse l =\n  let rec reverseHelper ln lo =\n    match ln with | [] -> lo | h::t -> reverseHelper t (h :: acc) in\n  reverseHelper l [];;\n", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper tl lo =\nmatch tl with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec reverseHelper tl lo =\nmatch tl with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec reverseHelper lst newList =\nmatch lst with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec reverseHelper lst newList =\nmatch lst with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper lst []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 146-149:\n  reverseHelper lst [];;\n                ^^^\nError: Unbound value lst\nHint: Did you mean fst, lsl or lsr?\n", "min": "\nlet listReverse l =\n  let rec reverseHelper lst newList =\n    match lst with | [] -> newList | h::tl -> reverseHelper tl (h :: newList) in\n  reverseHelper lst [];;\n", "in": "let listReverse l = \nlet rec reverseHelper l newList =\nmatch l with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let listReverse l = \nlet rec reverseHelper l newList =\nmatch l with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []"}]}
