{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = List.fold_left ( + ) 0", "min": "\nlet rec sumList xs = List.fold_left (+) 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = List.fold_left ( + ) 0", "min": "\nlet rec sumList xs = List.fold_left (+) 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: digitsOfInt n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else a :: (digitsOfInt n);;\n", "out": "Characters 46-47:\n  else a :: digitsOfInt n;;\n       ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else n :: (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n%10", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else n % 10;;\n", "out": "Characters 47-48:\n  else n%10;;\n        ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n mod 10", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else n mod 10;;\n", "out": "Characters 46-54:\n  else n mod 10;;\n       ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse h:: digitsOfInt n mod 10", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else h :: ((digitsOfInt n) mod 10);;\n", "out": "Characters 46-47:\n  else h:: digitsOfInt n mod 10;;\n       ^\nError: Unbound value h\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt n mod 10", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else (digitsOfInt n) mod 10;;\n", "out": "Characters 46-59:\n  else digitsOfInt n mod 10;;\n       ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) mod 10 :: []", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [(digitsOfInt (n / 10)) mod 10];;\n", "out": "Characters 46-64:\n  else digitsOfInt (n/10) mod 10 :: [];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then n\nelse digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = if n < 0 then n else digitsOfInt (n / 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then n\nelse digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = if n < 0 then n else digitsOfInt (n / 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif n < 0 then 1\nelse digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n / 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n =\nif n < 0 then 1\nelse digitsOfInt (n mod 10) in\ndigitsOfInt [] n", "min": "\nlet _ =\n  let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n mod 10) in\n  digitsOfInt [] n;;\n", "out": "Characters 71-82:\n  digitsOfInt [] n;;\n  ^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digitsOfInt n = \nlet rec digit acc d =\nif d < 10 then d::acc\nelse digit ((d mod 10)::acc) (d/10) in\ndigit [] d", "min": "\nlet digitsOfInt n =\n  let rec digit acc d =\n    if d < 10 then d :: acc else digit ((d mod 10) :: acc) (d / 10) in\n  digit [] d;;\n", "out": "Characters 113-114:\n  digit [] d;;\n           ^\nError: Unbound value d\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  let rec digit acc n =\n    if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n  digit [] n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  let rec digit acc n =\n    if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n  digit [] n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  let rec digit acc n =\n    if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n  digit [] n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  let rec digit acc n =\n    if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n  digit [] n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "out": "Characters 98-115:\n  else digit ((n mod 10)::acc) (n/10) in\n             ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit (n/10) ((n mod 10)::acc) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "out": "Characters 132-134:\n  digit [] n;;\n        ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse if n == '-' then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10\n       then n :: acc\n       else if n == '-' then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "out": "Characters 100-103:\n  else if n == '-' then n::acc\n               ^^^\nError: This expression has type char but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] n", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "out": "Characters 133-135:\n  digit [] n;;\n        ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nn [] digit", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     n [] digit);;\n", "out": "Characters 127-128:\n  n [] digit;;\n  ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] digit", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] digit);;\n", "out": "Characters 133-135:\n  digit [] digit;;\n        ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n == 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n == 0 then acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n == 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n == 0 then acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n = 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n = 0 then acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n = 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n = 0 then acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =\nif n < 10 then 0  \nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "min": "\nlet additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let rec addTimes n =\n       let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n       let x = digits n in if x > 9 then 1 + (addTimes x) else 1 in\n     addTimes n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n = 0 then acc else digit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [] | _ -> digit n []);;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\ndigitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n  digitalRoot n;;\n", "out": "Characters 93-94:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)", "min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)", "min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot n\nelse n in digitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot n else n in\n  digitalRoot n;;\n", "out": "Characters 171-172:\n  else n in digitalRoot n;;\n                        ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse n in digitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else n in\n  digitalRoot n;;\n", "out": "Characters 171-172:\n  else n in digitalRoot n;;\n                        ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse n in digitalRoot n", "min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet _ =\n  let digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else n in\n  digitalRoot n;;\n", "out": "Characters 167-168:\n  else n in digitalRoot n;;\n                        ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot n;;\n", "out": "Characters 172-173:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot x", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot x;;\n", "out": "Characters 172-173:\n  digitalRoot x;;\n              ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then 1 + digitalRoot x\nelse 1 in \ndigitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then 1 + (digitalRoot x) else 1 in\n  digitalRoot n;;\n", "out": "Characters 176-177:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    if n < 10\n    then n\n    else\n      (let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n       let x = digits n in if x > 9 then digitalRoot x else 1) in\n  digitalRoot n;;\n", "out": "Characters 195-196:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digitalRoot n = \nif n < 10 then n\nelse \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n", "min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet _ =\n  let digitalRoot n =\n    if n < 10\n    then n\n    else\n      (let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n       let x = digits n in if x > 9 then digitalRoot x else 1) in\n  digitalRoot n;;\n", "out": "Characters 191-192:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot n;;\n", "out": "Characters 172-173:\n  digitalRoot n;;\n              ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot (n/10)", "min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet digitalRoot n = if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n = \nif n < 10 then n\nelse (n mod 10) + digitalRoot (n/10)", "min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet digitalRoot n = if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet digitalRoot n = if n < 10 then n else (n mod 10) + (digitalRoot (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse (n mod 10) + digitalRoot (n/10)", "min": "\nlet rec digitalRoot n =\n  if n < 10 then n else (n mod 10) + (digitalRoot (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits (n/10) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else x in\n  digitalRoot n;;\n", "out": "Characters 168-169:\n  else x in digitalRoot n;;\n                        ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else x in\n  digitalRoot n;;\n", "out": "Characters 170-171:\n  else x in digitalRoot n;;\n                        ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse 1 in digitalRoot x", "min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot x;;\n", "out": "Characters 170-171:\n  else 1 in digitalRoot x;;\n                        ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "min": "\nlet digitalRoot n =\n  if n < 10\n  then 0\n  else\n    (let rec addTimes n =\n       let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n       let x = digits n in if x > 9 then 1 + (addTimes x) else 1 in\n     addTimes n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "min": "\nlet digitalRoot n =\n  if n < 10\n  then 0\n  else\n    (let rec addTimes n =\n       let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n       let x = digits n in if x > 9 then 1 + (addTimes x) else 1 in\n     addTimes n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse 1 in\naddTimes n", "min": "\nlet digitalRoot n =\n  if n < 10\n  then 0\n  else\n    (let rec addTimes n =\n       let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n       let x = digits n in if x > 9 then addTimes x else 1 in\n     addTimes n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n", "min": "\nlet digitalRoot n =\n  if n < 10\n  then 0\n  else\n    (let rec addTimes n =\n       let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n       let x = digits n in if x > 9 then addTimes x else x in\n     addTimes n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n =\nif n < 10 then n\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then n\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n", "min": "\nlet digitalRoot n =\n  if n < 10\n  then n\n  else\n    (let rec addTimes n =\n       let rec digits n =\n         if n <= 0 then n else (n mod 10) + (digits (n / 10)) in\n       let x = digits n in if x > 9 then addTimes x else x in\n     addTimes n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n =\nif n < 10 then n\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n", "min": "\nlet digitalRoot n =\n  if n < 10\n  then n\n  else\n    (let rec addTimes n =\n       let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n       let x = digits n in if x > 9 then addTimes x else x in\n     addTimes n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::l' -> 1 + listReverse l'", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l');;\n", "out": "Characters 64-78:\n  | hd::l' -> 1 + listReverse l';;\n                  ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'", "min": "\nlet rec listReverse l =\n  match l with | [] -> 0 | hd::l' -> 1 + (listReverse l');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> 0\n| _::tl -> 1 + listReverse tl", "min": "\nlet rec listReverse l =\n  match l with | [] -> 0 | _::tl -> 1 + (listReverse tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl + tl", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n", "out": "Characters 59-73:\n  | _::tl -> listReverse tl + tl;;\n             ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec listReverse l = match l with\n| 0 -> []\n| _::tl -> listReverse tl + tl", "min": "\nlet rec listReverse l =\n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n", "out": "Characters 49-54:\n  | _::tl -> listReverse tl + tl;;\n    ^^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl + tl", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n", "out": "Characters 59-73:\n  | _::tl -> listReverse tl + tl;;\n             ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl", "min": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> listReverse l\n| _::tl -> listReverse tl", "min": "\nlet rec listReverse l =\n  match l with | [] -> listReverse l | _::tl -> listReverse tl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec reverseHelper a l = match l with\n| [] -> a\n| _::tl -> reverseHelper a tl\nin reverseHelper 0 l", "min": "\nlet listReverse l =\n  let rec reverseHelper a l =\n    match l with | [] -> a | _::tl -> reverseHelper a tl in\n  reverseHelper 0 l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| hd::l -> listReverse l", "min": "\nlet rec listReverse l = match l with | [] -> [] | hd::l -> listReverse l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> 0\n| hd::l -> listReverse l", "min": "\nlet rec listReverse l = match l with | [] -> 0 | hd::l -> listReverse l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let listReverse l = \nlet rec reverseHelper acc = \nif [] then acc\nelse reverseHelper (h::acc) t in\nreverseHelper [] l", "min": "\nlet listReverse l =\n  let rec reverseHelper acc = if [] then acc else reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "out": "Characters 53-55:\n  if [] then acc\n     ^^\nError: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let listReverse l = \nlet rec reverseHelper acc = match acc with \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "out": "Characters 87-100:\n  | h::t -> reverseHelper (h::acc) t in\n            ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | e::l -> e + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = \nif explode w = listReverse w then true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "out": "Characters 47-48:\n  if explode w = listReverse w then true\n                             ^\nError: This expression has type string but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: l -> hd + sumList l", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::l -> hd + (sumList l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::acc) in\nreverseHelper l []", "min": "\nlet listReverse l =\n  let rec reverseHelper ln lo =\n    match ln with | [] -> lo | h::t -> reverseHelper t (h :: acc) in\n  reverseHelper l [];;\n", "out": "Characters 107-110:\n  | h::t -> reverseHelper t (h::acc) in\n                                ^^^\nError: Unbound value acc\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []", "min": "\nlet listReverse l =\n  let rec reverseHelper ln lo =\n    match ln with | [] -> lo | h::t -> reverseHelper t (h :: lo) in\n  reverseHelper l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper tl lo =\nmatch tl with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []", "min": "\nlet listReverse l =\n  let rec reverseHelper tl lo =\n    match tl with | [] -> lo | h::t -> reverseHelper t (h :: lo) in\n  reverseHelper l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec reverseHelper tl lo =\nmatch tl with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []", "min": "\nlet listReverse l =\n  let rec reverseHelper tl lo =\n    match tl with | [] -> lo | h::t -> reverseHelper t (h :: lo) in\n  reverseHelper l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec reverseHelper lst newList =\nmatch lst with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []", "min": "\nlet listReverse l =\n  let rec reverseHelper lst newList =\n    match lst with | [] -> newList | h::tl -> reverseHelper tl (h :: newList) in\n  reverseHelper l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let listReverse l = \nlet rec reverseHelper lst newList =\nmatch lst with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper lst []", "min": "\nlet listReverse l =\n  let rec reverseHelper lst newList =\n    match lst with | [] -> newList | h::tl -> reverseHelper tl (h :: newList) in\n  reverseHelper lst [];;\n", "out": "Characters 146-149:\n  reverseHelper lst [];;\n                ^^^\nError: Unbound value lst\nHint: Did you mean fst, lsl or lsr?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec reverseHelper l newList =\nmatch l with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []", "min": "\nlet listReverse l =\n  let rec reverseHelper l newList =\n    match l with | [] -> newList | h::tl -> reverseHelper tl (h :: newList) in\n  reverseHelper l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec reverseHelper l newList =\nmatch l with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []", "min": "\nlet listReverse l =\n  let rec reverseHelper l newList =\n    match l with | [] -> newList | h::tl -> reverseHelper tl (h :: newList) in\n  reverseHelper l [];;\n", "out": ""}]}
