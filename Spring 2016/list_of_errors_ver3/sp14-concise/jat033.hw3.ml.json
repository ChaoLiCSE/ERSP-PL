{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base =  fun y -> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\"", "out": "Characters 29-38:\n  let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\";;\n                               ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nlet helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n", "out": "Characters 81-87:\n  helper a' x (n-1)\n  ^^^^^^\nError: Unbound value helper\n", "min": "\nlet rec clone x n =\n  let helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nlet rec helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 length1 then (\nList.append (clone 0 (length1 - length2)) l1, l2)\nelse (l1,l2)", "out": "Characters 171-178:\n  else if length2 length1 then (\n          ^^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length1 - length2)) l1, l2)\nelse (l1,l2)", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair(t1,t2)\n| ([], []) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 200-207:\n  | (h1::t1, h2::t2) -> (h1,h2)::pair(t1,t2)\n                                     ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair (t1, t2))\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| ([], []) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 256-282:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 255-281:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 435-456:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nadd (padZero l1 l2)", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair List.rev l1 List.rev l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nadd (padZero l1 l2)", "out": "Characters 338-342:\n  in pair List.rev l1 List.rev l2\n     ^^^^\nError: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nadd (padZero l1 l2)", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> (0,0)\nin pair (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 332-337:\n  | (_ , _) -> (0,0)\n               ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> (0, 0) in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> [(0,0)]\nin pair (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [(0, 0)] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet helper a i l = match l with\n| [] -> a\n| h::t -> let a' = h*i::a in\nhelper a' i t\nin helper [] i l", "out": "Characters 96-102:\n  helper a' i t\n  ^^^^^^\nError: Unbound value helper\n", "min": "\nlet rec mulByDigit i l =\n  let helper a i l =\n    match l with | [] -> a | h::t -> let a' = (h * i) :: a in helper a' i t in\n  helper [] i l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper a i l = match l with\n| [] -> a\n| h::t -> let a' = h*i::a in\nhelper a' i t\nin helper [] i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper a i l =\n    match l with | [] -> a | h::t -> let a' = (h * i) :: a in helper a' i t in\n  helper [] i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper a c i l = match l with\n| [] -> a\n| h::t -> let x = (h*i + c) in \nlet n = if x > 9 then x mod 10 else x in\nlet c' = if x > 9 then x - 10 else 0 in\nlet a' = n::a in\nhelper a' c' i t\nin helper [] 0 i l", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper a c i l =\n    match l with\n    | [] -> a\n    | h::t ->\n        let x = (h * i) + c in\n        let n = if x > 9 then x mod 10 else x in\n        let c' = if x > 9 then x - 10 else 0 in\n        let a' = n :: a in helper a' c' i t in\n  helper [] 0 i l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet c' = if x > 9 then x - 10 else 0 in\nlet a' = n::a in\nhelper a' c' i t\nin helper [] 0 i (List.rev l)", "out": "Characters 210-211:\n  let a' = n::a in\n              ^\nError: Unbound value a\n", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let c' = if x > 9 then x - 10 else 0 in\n        let a' = n :: a in helper a' c' i t in\n  helper [] 0 i (List.rev l);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x - 10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev l)", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x - 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev l)", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair ((h1, h2) :: acc) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 325-332:\n  | (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n                                              ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc (h1, h2)) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> (0,0)::acc\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> (0, 0) :: acc in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n| (_ , _) -> List.append acc (0,0)\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 325-332:\n  | (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n                                              ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc (h1, h2)) t1 t2\n        | (_,_) -> List.append acc (0, 0) in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> List.append acc [(0,0)]\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin removeZero (helper [] 0 i (List.rev (0::l)))", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 362-377:\n  digitProducts a::acc (place+1) t l2 in\n  ^^^^^^^^^^^^^^^\nError: This expression has type int -> int list -> int list -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          (digitProducts a) :: (acc (place + 1) t l2) in\n    digitsProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 403-417:\n  digitsProducts [] 0 l1 l2 in\n  ^^^^^^^^^^^^^^\nError: Unbound value digitsProducts\nHint: Did you mean digitProducts?\n", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitsProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 430-456:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, 0) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 86-87:\n  | _ -> (0, 0) in\n             ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, 0) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Characters 493-497:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))", "out": "", "min": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = (* x a *) failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x =  fun b -> x (a b) in\nlet base = fun b -> b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
