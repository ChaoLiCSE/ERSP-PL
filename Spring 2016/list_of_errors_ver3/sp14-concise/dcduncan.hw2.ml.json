{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h rest ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h rest then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\n(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  helper ([], l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem ( h t ) ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h t) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 125-126:\n  let seen' = if ( List.mem ( h t ) ) then seen else h::seen in\n                                ^\nError: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h rest ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h rest then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h seen ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = f b in\nif b then wwhile f a else a", "min": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile f a else a;;\n", "out": "Characters 64-65:\n  if b then wwhile f a else a;;\n                   ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then wwhile f a else a", "min": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile f a else a;;\n", "out": "Characters 66-67:\n  if b then wwhile f a else a;;\n                   ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then wwhile (f a) else a", "min": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile (f a) else a;;\n", "out": "Characters 66-71:\n  if b then wwhile (f a) else a;;\n                   ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\n5", "min": "\nlet rec wwhile (f,b) = let (a,b) = f b in 5;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then 5 else 4", "min": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then 5 else 4;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then 5 else 4", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then 5 else 4;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then f b' else b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "out": "Characters 72-74:\n  if c' then f b' else b';;\n                       ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then wwhile (f b') else b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f b') else b';;\n", "out": "Characters 69-75:\n  if c' then wwhile (f b') else b';;\n                    ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile f b' else b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "out": "Characters 67-68:\n  if c' then wwhile f b' else b';;\n                    ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 513) in wwhile (f,2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 513)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 512)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (( f ),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 512)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( f ), b", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (( f ), b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( f , b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')\nin helper (f, b)", "min": "\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| _ -> \nlet seen' = if ( List.mem  0 seen ) then seen else 0::seen in\nlet rest' = [0] in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | _ ->\n        let seen' = if List.mem 0 seen then seen else 0 :: seen in\n        let rest' = [0] in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h seen ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\nVarX x -> x\n| VarY y -> y\n| Sine s -> Sine ( exprToString s )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX x -> x | VarY y -> y | Sine s -> Sine (exprToString s);;\n", "out": "Characters 38-44:\n  VarX x -> x\n  ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> Sine ( exprToString s )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Sine (exprToString s);;\n", "out": "Characters 82-105:\n  | Sine s -> Sine ( exprToString s );;\n              ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> buildSine( s )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine s;;\n", "out": "Characters 82-96:\n  | Sine s -> buildSine( s );;\n              ^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> Printf.printf buildSine( s )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Printf.printf buildSine s;;\n", "out": "Characters 96-105:\n  | Sine s -> Printf.printf buildSine( s );;\n                            ^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit) format =\n           ('a -> 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> Format.printf buildSine( s )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Format.printf buildSine s;;\n", "out": "Characters 96-105:\n  | Sine s -> Format.printf buildSine( s );;\n                            ^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit) format =\n           ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> buildSine", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine;;\n", "out": "Characters 82-91:\n  | Sine s -> buildSine;;\n              ^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type unit -> expr\n       Type expr is not compatible with type unit \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": "Characters 81-86:\n  | (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t );;\n                                          ^^^^^\nError: Unbound value assoc\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h rest ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h rest then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h seen ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf \"sin(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "out": "Characters 372-391:\n  -> Format.sprintf ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n                    ^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         ('a, unit, string) format =\n           ('a, unit, string, string, string, string)\n           CamlinternalFormatBasics.format6\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf \"sin(pi*%s)\" exprToString( e' )\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> Format.sprintf \"sin(pi*%s)\" exprToString e'\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "out": "Characters 126-138:\n  -> Format.sprintf \"sin(pi*%s)\" exprToString( e' )\n                    ^^^^^^^^^^^^\nError: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf (\"sin(pi*%s)\" exprToString( e' ))\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> Format.sprintf (\"sin(pi*%s)\" exprToString e')\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "out": "Characters 127-139:\n  -> Format.sprintf (\"sin(pi*%s)\" exprToString( e' ))\n                     ^^^^^^^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf \"sin(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf \"\" ^ ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval e' x y ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "out": "Characters 94-96:\n  -> sin ( pi *. ( eval e' x y ) )\n                        ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e' x y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e' x y)))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "out": "Characters 95-97:\n  -> sin ( pi *. ( eval (e' x y ) ) )\n                         ^^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "out": "Characters 139-143:\n  -> cos ( pi *. ( eval e' x y ) )\n                   ^^^^\nError: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "out": "Characters 233-234:\n  -> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n                                                      ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "out": "Characters 261-265:\n  -> ( eval e1 x y ) *. ( eval e2 x y )\n       ^^^^\nError: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "out": "Characters 349-350:\n  -> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y );;\n               ^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "out": "Characters 368-369:\n  -> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y );;\n                                  ^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = failwith \"to be implemented\"", "min": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand,depth) = \nif depth > 0 then \nlet x = rand( 0, 6 ) in \nmatch x with\n0 \n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine( build (rand,depth - 1) )\n| 3\n-> buildCosine( build (rand,depth - 1) )\n| 4\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 5\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 6\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let x = rand (0, 6) in\n    match x with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Characters 93-101:\n  -> buildX()\n     ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 0, 6 ) in \nmatch x with\n0 \n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine( build (rand,depth - 1) )\n| 3\n-> buildCosine( build (rand,depth - 1) )\n| 4\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 5\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 6\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 2, 6 ) in \nmatch x with\n2\n-> buildSine( build (rand,depth - 1) )\n| 3\n-> buildCosine( build (rand,depth - 1) )\n| 4\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 5\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 6\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (2, 6) in\n     match x with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 0, 4 ) in \nmatch x with\n0\n-> buildSine( build (rand,depth - 1) )\n| 1\n-> buildCosine( build (rand,depth - 1) )\n| 2\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 3\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 4\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 4) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 0, 4 ) in \nmatch x with\n0\n-> buildSine( build (rand,depth - 1) )\n| 1\n-> buildCosine( build (rand,depth - 1) )\n| 2\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 3\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 4\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 4) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 0, 4 ) in \nmatch x with\n0\n-> buildSine( build (rand,depth - 1) )\n| 1\n-> buildCosine( build (rand,depth - 1) )\n| 2\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 3\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| _\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 4) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| _\n-> buildY()\nelse\nlet x = rand( 0, 4 ) in \nmatch x with\n0\n-> buildSine( build (rand,depth - 1) )\n| 1\n-> buildCosine( build (rand,depth - 1) )\n| 2\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 3\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| _\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let x = rand (0, 4) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let x = rand (0, 4) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| _\n-> buildY()\nelse\nlet x = rand( 0, 6 ) in \nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine( build (rand,depth - 1) )\n| 3\n-> buildCosine( build (rand,depth - 1) )\n| 4\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 5\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| _\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf \"sin(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf \"\" ^ ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\"\n| Factorial e'\n->\nFormat.sprintf \"((\" ^ (exprToString e') ^ \")!)\"\n| Sum3 ( e1, e2, e3 )\n-> Format.sprintf \"(\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \"+\" ^ ( exprToString e3 ) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))))\n  | Factorial e' -> (Format.sprintf \"((\") ^ ((exprToString e') ^ \")!)\")\n  | Sum3 (e1,e2,e3) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e' ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1 ) +. eval( e2 ) +. eval( e3 )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial ((eval e'), 1)\n  | Sum3 (e1,e2,e3) -> ((eval e1) +. (eval e2)) +. (eval e3);;\n", "out": "Characters 459-476:\n  -> factorial( eval( e' ), 1 )\n              ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e', x, y ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial ((eval (e', x, y)), 1)\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n", "out": "Characters 459-482:\n  -> factorial( eval( e', x, y ), 1 )\n              ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial (eval( e', x, y )) 1.0 \n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval (e', x, y)) 1.0\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let buildFactorial(e)              = Factorial(a)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet buildFactorial e = Factorial a;;\n", "out": "Characters 46-49:\n  let buildFactorial(e)              = Factorial(a);;\n                                                ^^^\nError: Unbound value a\n"}, {"type": "", "in": "let buildSum3(e1,e2,e3)            = Sum3(e1,e2,e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet buildSum3 (e1,e2,e3) = Sum3 (e1, e2, e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildFactorial(e)              = Factorial(e)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet buildFactorial e = Factorial e;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval (e', x, y)) 1.0\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFactorial e = Factorial e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSum3 (e1,e2,e3) = Sum3 (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildFactorial (build (rand, (depth - 1)))\n     | _ ->\n         buildSum3\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))))\n  | Factorial e' -> (Format.sprintf \"((\") ^ ((exprToString e') ^ \")!)\")\n  | Sum3 (e1,e2,e3) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b' = b then b' else wwhile (f, b')\nin wwhile( f, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b' = b then b' else wwhile (f, b') in\n  wwhile (f, b);;\n", "out": "Characters 69-70:\n  if b' = b then b' else wwhile (f, b')\n                                 ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( ((f), ( ( f b ) = b )),b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "out": "Characters 30-52:\n  let fixpoint (f,b) = wwhile ( ((f), ( ( f b ) = b )),b);;\n                                ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( f, ( ( f b ) = b )),b", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (f, ((f b) = b))), b);;\n", "out": "Characters 45-46:\n  let fixpoint (f,b) = wwhile ( f, ( ( f b ) = b )),b;;\n                                               ^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( (f, ( ( f b ) = b ))), b", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (f, ((f b) = b))), b);;\n", "out": "Characters 46-47:\n  let fixpoint (f,b) = wwhile ( (f, ( ( f b ) = b ))), b;;\n                                                ^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let corn f b = wwhile f b", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet corn f b = wwhile f b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( (f, ( ( f b ) = b ))), b", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (f, ((f b) = b))), b);;\n", "out": "Characters 46-47:\n  let fixpoint (f,b) = wwhile ( (f, ( ( f b ) = b ))), b;;\n                                                ^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( (f, ( b, ( f b ) = b ))), b", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (f, (b, ((f b) = b)))), b);;\n", "out": "Characters 43-44:\n  let fixpoint (f,b) = wwhile ( (f, ( b, ( f b ) = b ))), b;;\n                                             ^\nError: This expression has type 'a but an expression was expected of type\n         'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( f b, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( (f b), b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( (f b) = b , b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "out": "Characters 30-39:\n  let fixpoint (f,b) = wwhile ( (f b) = b , b );;\n                                ^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( f, (f b) = b , b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "out": "Characters 28-48:\n  let fixpoint (f,b) = wwhile ( f, (f b) = b , b );;\n                              ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( b' = b ) \n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((b' = b), b));;\n", "out": "Characters 52-54:\n  let f' b' = f b in ( b' = b ) \n                       ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( b' = b ) \n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((b' = b), b));;\n", "out": "Characters 47-57:\n  let b' = f b in ( b' = b ) \n                  ^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 512)) in\n     ((wwhile (f, 2)), b));;\n", "out": "Characters 77-89:\n  let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)\n                                                ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f x = x*x*x in (xx, xx < 512)\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f x = (x * x) * x in ((xx, (xx < 512)), b));;\n", "out": "Characters 50-64:\n  let f x = x*x*x in (xx, xx < 512)\n                     ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, b' = b)\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "out": "Characters 47-59:\n  let b' = f b in ( f, b' = b)\n                  ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( ( f, b' = b)\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile ((f, (b' = b)), b);;\n", "out": "Characters 47-59:\n  let b' = f b in wwhile( ( f, b' = b)\n                          ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( ( f , b' = b)\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile ((f, (b' = b)), b);;\n", "out": "Characters 47-60:\n  let b' = f b in wwhile( ( f , b' = b)\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( f , b' = b\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile (f, (b' = b), b);;\n", "out": "Characters 45-63:\n  ......................( f , b' = b\n  , b )..\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( f', b' = b )\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f', (b' = b)), b));;\n", "out": "Characters 50-64:\n  let f' b' = f b in ( f', b' = b )\n                     ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, b' = b )\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "out": "Characters 47-60:\n  let b' = f b in ( f, b' = b )\n                  ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, (b' = b) )\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "out": "Characters 47-62:\n  let b' = f b in ( f, (b' = b) )\n                  ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f b, b = b' ) in f b\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = ((f b), (b = b')) in ((f b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, (b = b')) in ((f b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = ( f, b = b' ) in f b\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = (f, (b = b')) in ((f b), b));;\n", "out": "Characters 49-51:\n  let b' = ( f, b = b' ) in f b\n                    ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, (b = b')) in ((f b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = f b ) in f b\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "out": "Characters 64-65:\n  , b );;\n    ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = ( f b ) ) in f b\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "out": "Characters 68-69:\n  , b );;\n    ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \n( f, b = ( f b ) )\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, (b = (f b))), b);;\n", "out": "Characters 31-49:\n  ( f, b = ( f b ) )\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = ( f b ) ) in f b\n, b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "out": "Characters 68-69:\n  , b );;\n    ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = ( f b ) ) in f b , b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "out": "Characters 68-69:\n  let f' = ( f, b = ( f b ) ) in f b , b );;\n                                       ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = ( f b ) ) in f b , f' )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), f'));;\n", "out": "Characters 68-70:\n  let f' = ( f, b = ( f b ) ) in f b , f' );;\n                                       ^^\nError: This expression has type (('a -> 'a * bool) -> 'a -> 'a * bool) * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside\n       (('a -> 'a * bool) -> 'a -> 'a * bool) * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, f b = b )  in f b , b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, ((f b) = b)) in ((f b), b));;\n", "out": "Characters 65-66:\n  let f' = ( f, f b = b )  in f b , b );;\n                                    ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, f b = b ) in f b , b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, ((f b) = b)) in ((f b), b));;\n", "out": "Characters 67-68:\n  let f' b' = ( f, f b = b ) in f b , b );;\n                                      ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, f b = b ) in f b , b' )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, ((f b) = b)) in ((f b), b'));;\n", "out": "Characters 67-69:\n  let f' b' = ( f, f b = b ) in f b , b' );;\n                                      ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b = ( f, f b = b ) in f b , b )", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b = (f, ((f b) = b)) in ((f b), b));;\n", "out": "Characters 66-67:\n  let f' b = ( f, f b = b ) in f b , b );;\n                                     ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 512)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "wwhile (f,2)", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "wwhile (h,2)", "min": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = wwhile (h, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( \nh, b )", "min": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f,2)", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet _ = wwhile (f, 2);;\n", "out": "Characters 0-6:\n  wwhile (f,2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f,2)", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet _ = wwhile (f, 2);;\n", "out": "Characters 0-6:\n  wwhile (f,2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' =\nlet bb =\nf b in ( bb, bb = f b ) in wwhile( f', b) , b )", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    (let f' b' = let bb = f b in (bb, (bb = (f b))) in ((wwhile (f', b)), b));;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( \n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' =\nf b in ( f, f b = b ) , b )", "min": "\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f, ((f b) = b)), b));;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( \n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( \nlet f' =\nf b in ( f', f b = b ) , b )", "min": "\nlet fixpoint (f,b) = wwhile (let f' = f b in ((f', ((f b) = b)), b));;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( \n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f,2)", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet _ = wwhile (f, 2);;\n", "out": "Characters 0-6:\n  wwhile (f,2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "", "in": "let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')\nin helper (f, b)", "min": "\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f,2)", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet _ = wwhile (f, 2);;\n", "out": "Characters 0-6:\n  wwhile (f,2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "", "in": "let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')\nin helper (f, b)", "min": "\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
