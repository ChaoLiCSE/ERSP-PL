{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h rest ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\n(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 125-126:\n  let seen' = if ( List.mem ( h t ) ) then seen else h::seen in\n                                ^\nError: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h t) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem ( h t ) ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h rest ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h seen ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-65:\n  if b then wwhile f a else a;;\n                   ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile f a else a;;\n", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = f b in\nif b then wwhile f a else a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-67:\n  if b then wwhile f a else a;;\n                   ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile f a else a;;\n", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then wwhile f a else a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-71:\n  if b then wwhile (f a) else a;;\n                   ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile (f a) else a;;\n", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then wwhile (f a) else a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\n5"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then 5 else 4"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then 5 else 4"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-74:\n  if c' then f b' else b';;\n                       ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then f b' else b'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-75:\n  if c' then wwhile (f b') else b';;\n                    ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f b') else b';;\n", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then wwhile (f b') else b'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-68:\n  if c' then wwhile f b' else b';;\n                    ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile f b' else b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 513) in wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (( f ),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( f ), b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (( f ), b )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( f , b )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')\nin helper (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| _ -> \nlet seen' = if ( List.mem  0 seen ) then seen else 0::seen in\nlet rest' = [0] in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h seen ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX x -> x\n| VarY y -> y\n| Sine s -> Sine ( exprToString s )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 38-44:\n  VarX x -> x\n  ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX x -> x | VarY y -> y | Sine s -> Sine (exprToString s);;\n", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> Sine ( exprToString s )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-105:\n  | Sine s -> Sine ( exprToString s );;\n              ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Sine (exprToString s);;\n", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> buildSine( s )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-96:\n  | Sine s -> buildSine( s );;\n              ^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine s;;\n", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> Printf.printf buildSine( s )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-105:\n  | Sine s -> Printf.printf buildSine( s );;\n                            ^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit) format =\n           ('a -> 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Printf.printf buildSine s;;\n", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> Format.printf buildSine( s )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-105:\n  | Sine s -> Format.printf buildSine( s );;\n                            ^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit) format =\n           ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Format.printf buildSine s;;\n", "in": "let rec exprToString e = match e with\nVarX -> buildX\n| VarY -> buildY\n| Sine s -> buildSine"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-91:\n  | Sine s -> buildSine;;\n              ^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type unit -> expr\n       Type expr is not compatible with type unit \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine;;\n", "in": "let assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 81-86:\n  | (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t );;\n                                          ^^^^^\nError: Unbound value assoc\n", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h rest ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h seen ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 372-391:\n  -> Format.sprintf ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n                    ^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         ('a, unit, string) format =\n           ('a, unit, string, string, string, string)\n           CamlinternalFormatBasics.format6\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf \"sin(pi*%s)\" exprToString( e' )\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 126-138:\n  -> Format.sprintf \"sin(pi*%s)\" exprToString( e' )\n                    ^^^^^^^^^^^^\nError: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> Format.sprintf \"sin(pi*%s)\" exprToString e'\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf (\"sin(pi*%s)\" exprToString( e' ))\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 127-139:\n  -> Format.sprintf (\"sin(pi*%s)\" exprToString( e' ))\n                     ^^^^^^^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> Format.sprintf (\"sin(pi*%s)\" exprToString e')\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf \"sin(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf \"\" ^ ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval e' x y ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 94-96:\n  -> sin ( pi *. ( eval e' x y ) )\n                        ^^\nError: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e' x y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-97:\n  -> sin ( pi *. ( eval (e' x y ) ) )\n                         ^^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e' x y)))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 139-143:\n  -> cos ( pi *. ( eval e' x y ) )\n                   ^^^^\nError: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 233-234:\n  -> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n                                                      ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 261-265:\n  -> ( eval e1 x y ) *. ( eval e2 x y )\n       ^^^^\nError: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 349-350:\n  -> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y );;\n               ^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 368-369:\n  -> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y );;\n                                  ^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value emitGrayscale\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 8-21:\n  let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\");;\n          ^^^^^^^^^^^^^\nError: Unbound value emitGrayscale\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n", "in": "let rec build (rand,depth) = failwith \"to be implemented\""}, {"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Printf.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-101:\n  -> buildX()\n     ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let x = rand (0, 6) in\n    match x with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 0, 6 ) in \nmatch x with\n0 \n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine( build (rand,depth - 1) )\n| 3\n-> buildCosine( build (rand,depth - 1) )\n| 4\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 5\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 6\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 2, 6 ) in \nmatch x with\n2\n-> buildSine( build (rand,depth - 1) )\n| 3\n-> buildCosine( build (rand,depth - 1) )\n| 4\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 5\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 6\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 0, 4 ) in \nmatch x with\n0\n-> buildSine( build (rand,depth - 1) )\n| 1\n-> buildCosine( build (rand,depth - 1) )\n| 2\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 3\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 4\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 0, 4 ) in \nmatch x with\n0\n-> buildSine( build (rand,depth - 1) )\n| 1\n-> buildCosine( build (rand,depth - 1) )\n| 2\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 3\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 4\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\nelse\nlet x = rand( 0, 4 ) in \nmatch x with\n0\n-> buildSine( build (rand,depth - 1) )\n| 1\n-> buildCosine( build (rand,depth - 1) )\n| 2\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 3\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| _\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| _\n-> buildY()\nelse\nlet x = rand( 0, 4 ) in \nmatch x with\n0\n-> buildSine( build (rand,depth - 1) )\n| 1\n-> buildCosine( build (rand,depth - 1) )\n| 2\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 3\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| _\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-21:\n  let _ = doRandomColor( 12, 9239, 32432 );;\n          ^^^^^^^^^^^^^\nError: Unbound value doRandomColor\n", "min": "\nlet _ = doRandomColor (12, 9239, 32432);;\n", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand,depth) = \nif depth <= 0 then\nlet x = rand( 0, 1 ) in\nmatch x with\n0\n-> buildX()\n| _\n-> buildY()\nelse\nlet x = rand( 0, 6 ) in \nmatch x with\n0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine( build (rand,depth - 1) )\n| 3\n-> buildCosine( build (rand,depth - 1) )\n| 4\n-> buildAverage( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| 5\n-> buildTimes( (build (rand,depth - 1)), (build (rand,depth - 1)) )\n| _\n-> buildThresh( (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)), (build (rand,depth - 1)) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 465-471:\n  -> factorial( eval( e' ) )\n                    ^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc = if x = 0 then acc else factorial (x - 1) (x * acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval e')\n  | Sum3 (e1,e2,e3) -> ((eval e1) + (eval e2)) + (eval e3);;\n", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf \"sin(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf \"\" ^ ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\"\n| Factorial e'\n->\nFormat.sprintf \"((\" ^ (exprToString e') ^ \")!)\"\n| Sum3 ( e1, e2, e3 )\n-> Format.sprintf \"(\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \"+\" ^ ( exprToString e3 ) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-62:\n  factorial ( x -. 1.0) ( x *. acc );;\n              ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet rec factorial x acc =\n  if x = 0 then acc else factorial (x -. 1.0) (x *. acc);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX\t\t\t\t\n-> Format.sprintf \"x\"\n| VarY\n-> Format.sprintf \"y\"\n| Sine e'\n-> Format.sprintf \"sin(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Cosine e'\n-> Format.sprintf \"cos(pi*\" ^ ( exprToString e' ) ^ \")\"\n| Average ( e1, e2 )\n-> Format.sprintf \"((\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \")/2)\"\n| Times ( e1, e2 )\n-> Format.sprintf \"\" ^ ( exprToString e1 ) ^ \"*\" ^ ( exprToString e2 )\n| Thresh ( a, b, a_less, b_less )\n-> Format.sprintf \"(\" ^ ( exprToString a ) ^ \"<\" ^ ( exprToString b )\n^ \"?\" ^ ( exprToString a_less ) ^ \":\" ^ ( exprToString b_less ) ^ \")\"\n| Factorial e'\n->\nFormat.sprintf \"((\" ^ (exprToString e') ^ \")!)\"\n| Sum3 ( e1, e2, e3 )\n-> Format.sprintf \"(\" ^ ( exprToString e1 ) ^ \"+\" ^ ( exprToString e2 ) ^ \"+\" ^ ( exprToString e3 ) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 465-471:\n  -> factorial( eval( e' ) )\n                    ^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval e')\n  | Sum3 (e1,e2,e3) -> ((eval e1) +. (eval e2)) +. (eval e3);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e' ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1 ) +. eval( e2 ) +. eval( e3 )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 459-476:\n  -> factorial( eval( e' ), 1 )\n              ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial ((eval e'), 1)\n  | Sum3 (e1,e2,e3) -> ((eval e1) +. (eval e2)) +. (eval e3);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e', x, y ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 450-459:\n  -> factorial eval( e', x, y ) 1 \n     ^^^^^^^^^\nError: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial eval (e', x, y) 1\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial (eval( e', x, y )) 1.0 \n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildFactorial(e)              = Factorial(a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildFactorial(e)              = Factorial(e)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b' = b then b' else wwhile (f, b')\nin wwhile( f, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-70:\n  if b' = b then b' else wwhile (f, b')\n                                 ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b' = b then b' else wwhile (f, b') in\n  wwhile (f, b);;\n", "in": "let fixpoint (f,b) = wwhile ( ((f), ( ( f b ) = b )),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-52:\n  let fixpoint (f,b) = wwhile ( ((f), ( ( f b ) = b )),b);;\n                                ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ( f, ( ( f b ) = b )),b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (f, ( ( f b ) = b ))), b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 43-44:\n  let fixpoint (f,b) = wwhile ( (f, ( b, ( f b ) = b ))), b;;\n                                             ^\nError: This expression has type 'a but an expression was expected of type\n         'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (f, (b, ((f b) = b)))), b);;\n", "in": "let fixpoint (f,b) = wwhile ( f b, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 18-25:\n  let _ = fixpoint (collatz, 9001);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile ( (f b), b )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (f b) = b , b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-39:\n  let fixpoint (f,b) = wwhile ( (f b) = b , b );;\n                                ^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "in": "let fixpoint (f,b) = wwhile ( f, (f b) = b , b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-48:\n  let fixpoint (f,b) = wwhile ( f, (f b) = b , b );;\n                              ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = let xx = f b in ( b' = b ) \n, b )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 52-54:\n  let f' b' = f b in ( b' = b ) \n                       ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((b' = b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( b' = b ) \n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-57:\n  let b' = f b in ( b' = b ) \n                  ^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((b' = b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-89:\n  let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)\n                                                ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 512)) in\n     ((wwhile (f, 2)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 50-64:\n  let f x = x*x*x in (xx, xx < 512)\n                     ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f x = (x * x) * x in ((xx, (xx < 512)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-59:\n  let b' = f b in ( f, b' = b)\n                  ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "in": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( ( f, b' = b)\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-59:\n  let b' = f b in wwhile( ( f, b' = b)\n                          ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile ((f, (b' = b)), b);;\n", "in": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( ( f , b' = b)\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-60:\n  let b' = f b in wwhile( ( f , b' = b)\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile ((f, (b' = b)), b);;\n", "in": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( f , b' = b\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 45-63:\n  ......................( f , b' = b\n  , b )..\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile (f, (b' = b), b);;\n", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 50-63:\n  let f' b' = f b in ( f, b' = b )\n                     ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f, (b' = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( f', b' = b )\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 50-64:\n  let f' b' = f b in ( f', b' = b )\n                     ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f', (b' = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, b' = b )\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-60:\n  let b' = f b in ( f, b' = b )\n                  ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, (b' = b) )\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-62:\n  let b' = f b in ( f, (b' = b) )\n                  ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f b, b = b' )\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( \nlet b' = ( f, b = b' ) in f b\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-51:\n  let b' = ( f, b = b' ) in f b\n                    ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = (f, (b = b')) in ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = f b ) in f b\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-65:\n  , b );;\n    ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = ( f b ) ) in f b\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-69:\n  , b );;\n    ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \n( f, b = ( f b ) )\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-49:\n  ( f, b = ( f b ) )\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, (b = (f b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = ( f b ) ) in f b\n, b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-69:\n  , b );;\n    ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = ( f b ) ) in f b , b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-69:\n  let f' = ( f, b = ( f b ) ) in f b , b );;\n                                       ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = ( f b ) ) in f b , f' )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-70:\n  let f' = ( f, b = ( f b ) ) in f b , f' );;\n                                       ^^\nError: This expression has type (('a -> 'a * bool) -> 'a -> 'a * bool) * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside\n       (('a -> 'a * bool) -> 'a -> 'a * bool) * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), f'));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, f b = b )  in f b , b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-66:\n  let f' = ( f, f b = b )  in f b , b );;\n                                    ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, ((f b) = b)) in ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, f b = b ) in f b , b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-68:\n  let f' b' = ( f, f b = b ) in f b , b );;\n                                      ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, ((f b) = b)) in ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, f b = b ) in f b , b' )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-69:\n  let f' b' = ( f, f b = b ) in f b , b' );;\n                                      ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, ((f b) = b)) in ((f b), b'));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b = ( f, f b = b ) in f b , b )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-67:\n  let f' b = ( f, f b = b ) in f b , b );;\n                                     ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b = (f, ((f b) = b)) in ((f b), b));;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (h,2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( \nh, b )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-24:\n  let f' b' = let bb = f b in ( bb, bb = f b );;\n                         ^\nError: Unbound value b\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = let bb = f b in ( bb, bb = f b , b )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-24:\n  let f' b' = let bb = f b in ( bb, bb = f b );;\n                         ^\nError: Unbound value b\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( b', b' = f b , b )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-24:\n  let f' b' = let bb = f b in ( bb, bb = f b );;\n                         ^\nError: Unbound value b\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' = let bb = f b in ( bb, bb = f b , b ))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-24:\n  let f' b' = let bb = f b in ( bb, bb = f b );;\n                         ^\nError: Unbound value b\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' =\nlet bb =\nf b in ( ( bb, bb = f b ) , b ) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-24:\n  let f' b' = let bb = f b in ( bb, bb = f b );;\n                         ^\nError: Unbound value b\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' =\nlet bb =\nf b' in ( ( bb, bb = f b ) , b ) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-24:\n  let f' b' = let bb = f b in ( bb, bb = f b );;\n                         ^\nError: Unbound value b\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' =\nlet bb =\nf b' in ( ( bb, bb = f b ) , b ) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( \n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    (let f' b' = let bb = f b in (bb, (bb = (f b))) in ((wwhile (f', b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' b' =\nf b in ( f, f b = b ) , b )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( \n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f, ((f b) = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( \nlet f' =\nf b in ( f', f b = b ) , b )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( \n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (let f' = f b in ((f', ((f b) = b)), b));;\n", "in": "wwhile (f,2)"}, {"type": "scope", "out": "Characters 0-6:\n  wwhile (f,2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet _ = wwhile (f, 2);;\n", "in": "let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')\nin helper (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f,2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )"}]}
